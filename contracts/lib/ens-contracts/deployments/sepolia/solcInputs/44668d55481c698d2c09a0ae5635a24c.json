{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-v5/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts-v5/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-v5/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts-v5/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@unruggable/gateways/contracts/GatewayFetcher.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {GatewayRequest, GatewayOP} from './GatewayRequest.sol';\n\n// only happens during request construction\nerror RequestOverflow();\n\nlibrary GatewayFetcher {\n    // verifier execution is only constrainted by stack and gas\n    // max outputs = 255\n    // NOTE: this is developer configurable\n    uint256 constant MAX_OPS = 8192;\n\n    using GatewayFetcher for GatewayRequest;\n\n    function newRequest(\n        uint8 outputs\n    ) internal pure returns (GatewayRequest memory) {\n        return newCommand().addByte(outputs);\n    }\n\n    function newCommand() internal pure returns (GatewayRequest memory) {\n        bytes memory v = new bytes(MAX_OPS);\n        assembly {\n            mstore(v, 0) // length = 0\n        }\n        return GatewayRequest(v);\n    }\n\n    function encode(\n        GatewayRequest memory r\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(r.ops);\n    }\n\n    function addByte(\n        GatewayRequest memory r,\n        uint8 i\n    ) internal pure returns (GatewayRequest memory) {\n        bytes memory v = r.ops;\n        uint256 n = v.length;\n        if (n >= MAX_OPS) revert RequestOverflow();\n        assembly {\n            mstore(v, add(n, 1)) // length += 1\n            mstore8(add(add(v, 32), n), i) // append(i)\n        }\n        return r;\n    }\n    function addBytes(\n        GatewayRequest memory r,\n        bytes memory v\n    ) internal pure returns (GatewayRequest memory) {\n        bytes memory buf = r.ops;\n        if (r.ops.length + v.length >= MAX_OPS) revert RequestOverflow();\n        assembly {\n            let dst := add(add(buf, 32), mload(buf)) // ptr to write\n            let src := add(v, 32) // ptr to start read\n            for {\n                let src_end := add(src, mload(v)) // ptr to stop read\n            } lt(src, src_end) {\n                src := add(src, 32)\n                dst := add(dst, 32)\n            } {\n                mstore(dst, mload(src)) // copy word\n            }\n            mstore(buf, add(mload(buf), mload(v))) // length += v.length\n        }\n        return r;\n    }\n\n    function debug(\n        GatewayRequest memory r,\n        string memory label\n    ) internal pure returns (GatewayRequest memory) {\n        bytes memory v = bytes(label);\n        if (v.length >= 256) revert RequestOverflow();\n        return r.addByte(GatewayOP.DEBUG).addByte(uint8(v.length)).addBytes(v);\n    }\n\n    function push(\n        GatewayRequest memory r,\n        bool x\n    ) internal pure returns (GatewayRequest memory) {\n        return r.push(x ? 1 : 0);\n    }\n    function push(\n        GatewayRequest memory r,\n        bytes32 x\n    ) internal pure returns (GatewayRequest memory) {\n        return r.push(uint256(x));\n    }\n    function push(\n        GatewayRequest memory r,\n        address x\n    ) internal pure returns (GatewayRequest memory) {\n        return r.push(uint160(x));\n    }\n    function push(\n        GatewayRequest memory r,\n        uint256 x\n    ) internal pure returns (GatewayRequest memory) {\n        // NOTE: compact request building is not necessary\n        // this could just be: return r.addByte(GatewayOP.PUSH_32).addBytes(abi.encode(x));\n        if (x == 0) return r.addByte(GatewayOP.PUSH_0);\n        uint8 n = clz(x); // number of leading zeros\n        x <<= (n << 3); // right pad\n        n = 32 - n; // width w/o pad\n        r.addByte(GatewayOP.PUSH_0 + n);\n        bytes memory v = r.ops;\n        assembly {\n            let len := mload(v)\n            mstore(add(add(v, 32), len), x) // append(x)\n            mstore(v, add(len, n)) // length += n\n        }\n        return r;\n    }\n    function clz(uint256 x) private pure returns (uint8 n) {\n        if (x < (1 << 128)) {\n            x <<= 128;\n            n |= 16;\n        }\n        if (x < (1 << 192)) {\n            x <<= 64;\n            n |= 8;\n        }\n        if (x < (1 << 224)) {\n            x <<= 32;\n            n |= 4;\n        }\n        if (x < (1 << 240)) {\n            x <<= 16;\n            n |= 2;\n        }\n        if (x < (1 << 248)) {\n            n |= 1;\n        }\n    }\n\n    function push(\n        GatewayRequest memory r,\n        string memory s\n    ) internal pure returns (GatewayRequest memory) {\n        return r.push(bytes(s));\n    }\n    function push(\n        GatewayRequest memory r,\n        GatewayRequest memory p\n    ) internal pure returns (GatewayRequest memory) {\n        return r.push(p.encode());\n    }\n    function push(\n        GatewayRequest memory r,\n        bytes memory v\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.PUSH_BYTES).push(v.length).addBytes(v);\n    }\n\n    function getSlot(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.GET_SLOT);\n    }\n    function getTarget(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.GET_TARGET);\n    }\n    function stackCount(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.STACK_SIZE);\n    }\n    function isContract(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.IS_CONTRACT);\n    }\n\n    function pushStack(\n        GatewayRequest memory r,\n        uint256 i\n    ) internal pure returns (GatewayRequest memory) {\n        return r.push(i).addByte(GatewayOP.PUSH_STACK);\n        // r.stackCount().push(1).subtract().push(i).subtract().addByte(GatewayOP.DUP);\n    }\n    function pushOutput(\n        GatewayRequest memory r,\n        uint256 i\n    ) internal pure returns (GatewayRequest memory) {\n        return r.push(i).addByte(GatewayOP.PUSH_OUTPUT);\n    }\n\n    function target(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.SET_TARGET);\n    }\n    function setTarget(\n        GatewayRequest memory r,\n        address a\n    ) internal pure returns (GatewayRequest memory) {\n        return r.push(a).target();\n    }\n\n    function output(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.SET_OUTPUT);\n    }\n    function setOutput(\n        GatewayRequest memory r,\n        uint8 i\n    ) internal pure returns (GatewayRequest memory) {\n        return r.push(i).output();\n    }\n    function eval(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.push(true).evalIf();\n    }\n    function evalIf(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.EVAL);\n    }\n    function evalLoop(\n        GatewayRequest memory r,\n        uint8 flags\n    ) internal pure returns (GatewayRequest memory) {\n        return r.evalLoop(flags, 255);\n    }\n    function evalLoop(\n        GatewayRequest memory r,\n        uint8 flags,\n        uint256 count\n    ) internal pure returns (GatewayRequest memory) {\n        return r.push(count).addByte(GatewayOP.EVAL_LOOP).addByte(flags);\n    }\n    function exit(\n        GatewayRequest memory r,\n        uint8 exitCode\n    ) internal pure returns (GatewayRequest memory) {\n        return r.push(false).assertNonzero(exitCode);\n    }\n    function assertNonzero(\n        GatewayRequest memory r,\n        uint8 exitCode\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.ASSERT).addByte(exitCode);\n    }\n    function requireContract(\n        GatewayRequest memory r,\n        uint8 exitCode\n    ) internal pure returns (GatewayRequest memory) {\n        return r.isContract().assertNonzero(exitCode);\n    }\n    function requireNonzero(\n        GatewayRequest memory r,\n        uint8 exitCode\n    ) internal pure returns (GatewayRequest memory) {\n        return r.dup().assertNonzero(exitCode);\n    }\n\n    function setSlot(\n        GatewayRequest memory r,\n        uint256 x\n    ) internal pure returns (GatewayRequest memory) {\n        return r.push(x).slot();\n    }\n    function offset(\n        GatewayRequest memory r,\n        uint256 dx\n    ) internal pure returns (GatewayRequest memory) {\n        return r.push(dx).addSlot();\n    }\n    function addSlot(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.ADD_SLOT);\n        // return r.getSlot().add().slot();\n    }\n    function slot(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.SET_SLOT);\n    }\n    function follow(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.FOLLOW);\n        // return r.getSlot().concat().keccak().slot();\n    }\n    function followIndex(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.getSlot().keccak().slot().addSlot();\n    }\n\n    function read(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.READ_SLOT);\n    }\n    function read(\n        GatewayRequest memory r,\n        uint256 n\n    ) internal pure returns (GatewayRequest memory) {\n        return r.push(n).addByte(GatewayOP.READ_SLOTS);\n    }\n    function readBytes(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.READ_BYTES);\n    }\n    function readHashedBytes(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.READ_HASHED_BYTES);\n    }\n    function readArray(\n        GatewayRequest memory r,\n        uint256 step\n    ) internal pure returns (GatewayRequest memory) {\n        return r.push(step).addByte(GatewayOP.READ_ARRAY);\n    }\n\n    function pop(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.POP);\n    }\n    function dup(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.dup(0);\n    }\n    function dup(\n        GatewayRequest memory r,\n        uint256 back\n    ) internal pure returns (GatewayRequest memory) {\n        return r.push(back).addByte(GatewayOP.DUP);\n    }\n    function swap(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.swap(1);\n    }\n    function swap(\n        GatewayRequest memory r,\n        uint256 back\n    ) internal pure returns (GatewayRequest memory) {\n        return r.push(back).addByte(GatewayOP.SWAP);\n    }\n\n    function concat(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.CONCAT);\n    }\n    function keccak(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.KECCAK);\n    }\n    function slice(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.SLICE);\n    }\n    function slice(\n        GatewayRequest memory r,\n        uint256 pos,\n        uint256 len\n    ) internal pure returns (GatewayRequest memory) {\n        return r.push(pos).push(len).slice();\n    }\n    function length(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.LENGTH);\n    }\n\n    function plus(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.PLUS);\n    }\n    function twosComplement(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.not().push(1).plus();\n    }\n    function subtract(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.twosComplement().plus();\n    }\n    function times(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.TIMES);\n    }\n    function divide(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.DIVIDE);\n    }\n    function mod(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.MOD);\n    }\n    function pow(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.POW);\n    }\n    function and(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.AND);\n    }\n    function or(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.OR);\n    }\n    function xor(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.XOR);\n    }\n    function isZero(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.IS_ZERO);\n    }\n    function not(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.NOT);\n    }\n    function shl(\n        GatewayRequest memory r,\n        uint8 shift\n    ) internal pure returns (GatewayRequest memory) {\n        return r.push(shift).addByte(GatewayOP.SHIFT_LEFT);\n    }\n    function shr(\n        GatewayRequest memory r,\n        uint8 shift\n    ) internal pure returns (GatewayRequest memory) {\n        return r.push(shift).addByte(GatewayOP.SHIFT_RIGHT);\n    }\n    function eq(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.EQ);\n    }\n    function lt(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.LT);\n    }\n    function gt(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.GT);\n    }\n    function neq(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.eq().isZero();\n    }\n    function lte(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.gt().isZero();\n    }\n    function gte(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.lt().isZero();\n    }\n    function dup2(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.dup(1).dup(1);\n    }\n    function min(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.dup2().gt().addByte(GatewayOP.SWAP).pop();\n    }\n    function max(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.dup2().lt().addByte(GatewayOP.SWAP).pop();\n    }\n}\n"
    },
    "@unruggable/gateways/contracts/GatewayFetchTarget.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {GatewayRequest} from './GatewayRequest.sol';\nimport {IGatewayVerifier} from './IGatewayVerifier.sol';\nimport {IGatewayProtocol} from './IGatewayProtocol.sol';\n\nerror OffchainLookup(\n    address from,\n    string[] urls,\n    bytes request,\n    bytes4 callback,\n    bytes carry\n);\n\nabstract contract GatewayFetchTarget {\n    struct Session {\n        IGatewayVerifier verifier;\n        bytes context;\n        GatewayRequest req;\n        bytes4 callback;\n        bytes carry;\n    }\n\n    function fetch(\n        IGatewayVerifier verifier,\n        GatewayRequest memory req,\n        bytes4 callback\n    ) internal view {\n        fetch(verifier, req, callback, '', new string[](0));\n    }\n\n    function fetch(\n        IGatewayVerifier verifier,\n        GatewayRequest memory req,\n        bytes4 callback,\n        bytes memory carry,\n        string[] memory urls\n    ) internal view {\n        bytes memory context = verifier.getLatestContext();\n        if (urls.length == 0) urls = verifier.gatewayURLs();\n        revert OffchainLookup(\n            address(this),\n            urls,\n            abi.encodeCall(IGatewayProtocol.proveRequest, (context, req)),\n            this.fetchCallback.selector,\n            abi.encode(Session(verifier, context, req, callback, carry))\n        );\n    }\n\n    function fetchCallback(\n        bytes calldata response,\n        bytes calldata carry\n    ) external view {\n        Session memory ses = abi.decode(carry, (Session));\n        (bytes[] memory values, uint8 exitCode) = ses.verifier.getStorageValues(\n            ses.context,\n            ses.req,\n            response\n        );\n        (bool ok, bytes memory ret) = address(this).staticcall(\n            abi.encodeWithSelector(ses.callback, values, exitCode, ses.carry)\n        );\n        if (ok) {\n            assembly {\n                return(add(ret, 32), mload(ret))\n            }\n        } else {\n            assembly {\n                revert(add(ret, 32), mload(ret))\n            }\n        }\n    }\n}\n"
    },
    "@unruggable/gateways/contracts/GatewayRequest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nstruct GatewayRequest {\n    bytes ops;\n}\n\nlibrary EvalFlag {\n    uint8 constant STOP_ON_SUCCESS = 1 << 0;\n    uint8 constant STOP_ON_FAILURE = 1 << 1;\n    uint8 constant ACQUIRE_STATE = 1 << 2;\n    uint8 constant KEEP_ARGS = 1 << 3;\n}\n\nlibrary GatewayOP {\n    uint8 constant PUSH_0 = 0;\n    uint8 constant PUSH_1 = 1;\n    uint8 constant PUSH_2 = 2;\n    uint8 constant PUSH_3 = 3;\n    uint8 constant PUSH_4 = 4;\n    uint8 constant PUSH_5 = 5;\n    uint8 constant PUSH_6 = 6;\n    uint8 constant PUSH_7 = 7;\n    uint8 constant PUSH_8 = 8;\n    uint8 constant PUSH_9 = 9;\n    uint8 constant PUSH_10 = 10;\n    uint8 constant PUSH_11 = 11;\n    uint8 constant PUSH_12 = 12;\n    uint8 constant PUSH_13 = 13;\n    uint8 constant PUSH_14 = 14;\n    uint8 constant PUSH_15 = 15;\n    uint8 constant PUSH_16 = 16;\n    uint8 constant PUSH_17 = 17;\n    uint8 constant PUSH_18 = 18;\n    uint8 constant PUSH_19 = 19;\n    uint8 constant PUSH_20 = 20;\n    uint8 constant PUSH_21 = 21;\n    uint8 constant PUSH_22 = 22;\n    uint8 constant PUSH_23 = 23;\n    uint8 constant PUSH_24 = 24;\n    uint8 constant PUSH_25 = 25;\n    uint8 constant PUSH_26 = 26;\n    uint8 constant PUSH_27 = 27;\n    uint8 constant PUSH_28 = 28;\n    uint8 constant PUSH_29 = 29;\n    uint8 constant PUSH_30 = 30;\n    uint8 constant PUSH_31 = 31;\n    uint8 constant PUSH_32 = 32;\n\n    uint8 constant GET_SLOT = 33;\n    uint8 constant GET_TARGET = 34;\n    uint8 constant STACK_SIZE = 35;\n\tuint8 constant IS_CONTRACT = 36;\n\n    uint8 constant PUSH_BYTES = 40;\n    uint8 constant PUSH_STACK = 41;\n    uint8 constant PUSH_OUTPUT = 42;\n\n    uint8 constant SET_TARGET = 50;\n    uint8 constant SET_OUTPUT = 51;\n    uint8 constant EVAL_LOOP = 52;\n    uint8 constant EVAL = 53;\n    uint8 constant ASSERT = 54;\n\n    uint8 constant READ_SLOT = 60;\n    uint8 constant READ_BYTES = 61;\n    uint8 constant READ_ARRAY = 62;\n    uint8 constant READ_HASHED_BYTES = 63;\n    uint8 constant READ_SLOTS = 64;\n\n    uint8 constant SET_SLOT = 70;\n    uint8 constant ADD_SLOT = 71;\n    uint8 constant FOLLOW = 72;\n\n    uint8 constant DUP = 80;\n    uint8 constant POP = 81;\n    uint8 constant SWAP = 82;\n\n    uint8 constant KECCAK = 90;\n    uint8 constant CONCAT = 91;\n    uint8 constant SLICE = 92;\n    uint8 constant LENGTH = 93;\n\n    uint8 constant PLUS = 100;\n    uint8 constant TIMES = 101;\n    uint8 constant DIVIDE = 102;\n    uint8 constant MOD = 103;\n\tuint8 constant POW = 104;\n\n    uint8 constant AND = 110;\n    uint8 constant OR = 111;\n    uint8 constant XOR = 112;\n    uint8 constant SHIFT_LEFT = 113;\n    uint8 constant SHIFT_RIGHT = 114;\n    uint8 constant NOT = 115;\n\n    uint8 constant IS_ZERO = 120;\n    uint8 constant EQ = 121;\n    uint8 constant LT = 122;\n    uint8 constant GT = 123;\n\n    uint8 constant DEBUG = 255;\n}\n"
    },
    "@unruggable/gateways/contracts/IGatewayProtocol.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {GatewayRequest} from './GatewayRequest.sol';\n\ninterface IGatewayProtocol {\n    function proveRequest(\n        bytes memory context,\n        GatewayRequest memory req\n    ) external pure returns (bytes memory);\n}\n"
    },
    "@unruggable/gateways/contracts/IGatewayVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {GatewayRequest} from './GatewayRequest.sol';\n\nerror CommitTooOld(uint256 latest, uint256 got, uint256 window);\nerror CommitTooNew(uint256 latest, uint256 got);\n\ninterface IGatewayVerifier {\n    function getLatestContext() external view returns (bytes memory);\n    function gatewayURLs() external view returns (string[] memory);\n\n    function getStorageValues(\n        bytes memory context,\n        GatewayRequest memory req,\n        bytes memory proof\n    ) external view returns (bytes[] memory values, uint8 exitCode);\n}\n"
    },
    "contracts/registry/ENS.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface ENS {\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n\n    // Logged when an operator is added or removed.\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        bytes32 label,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        bytes32 label,\n        address owner\n    ) external returns (bytes32);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setOwner(bytes32 node, address owner) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function owner(bytes32 node) external view returns (address);\n\n    function resolver(bytes32 node) external view returns (address);\n\n    function ttl(bytes32 node) external view returns (uint64);\n\n    function recordExists(bytes32 node) external view returns (bool);\n\n    function isApprovedForAll(\n        address owner,\n        address operator\n    ) external view returns (bool);\n}\n"
    },
    "contracts/resolvers/profiles/IAddressResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\n/// Interface for the new (multicoin) addr function.\ninterface IAddressResolver {\n    event AddressChanged(\n        bytes32 indexed node,\n        uint256 coinType,\n        bytes newAddress\n    );\n\n    function addr(\n        bytes32 node,\n        uint256 coinType\n    ) external view returns (bytes memory);\n}\n"
    },
    "contracts/resolvers/profiles/IAddrResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\n/// Interface for the legacy (ETH-only) addr function.\ninterface IAddrResolver {\n    event AddrChanged(bytes32 indexed node, address a);\n\n    /// Returns the address associated with an ENS node.\n    /// @param node The ENS node to query.\n    /// @return The associated address.\n    function addr(bytes32 node) external view returns (address payable);\n}\n"
    },
    "contracts/resolvers/profiles/IExtendedResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IExtendedResolver {\n    function resolve(\n        bytes memory name,\n        bytes memory data\n    ) external view returns (bytes memory);\n}\n"
    },
    "contracts/resolvers/profiles/INameResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface INameResolver {\n    event NameChanged(bytes32 indexed node, string name);\n\n    /// Returns the name associated with an ENS node, for reverse records.\n    /// Defined in EIP181.\n    /// @param node The ENS node to query.\n    /// @return The associated name.\n    function name(bytes32 node) external view returns (string memory);\n}\n"
    },
    "contracts/reverseRegistrar/IStandaloneReverseRegistrar.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Interface for a standalone reverse registrar.\ninterface IStandaloneReverseRegistrar {\n    /// @notice Emitted when the name for an address is changed.\n    ///\n    /// @param addr The address of the reverse record.\n    /// @param name The name of the reverse record.\n    event NameForAddrChanged(address indexed addr, string name);\n\n    /// @notice Returns the name for an address.\n    ///\n    /// @param addr The address to get the name for.\n    /// @return The name for the address.\n    function nameForAddr(address addr) external view returns (string memory);\n}\n"
    },
    "contracts/reverseRegistrar/L1ReverseResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ERC165, IERC165} from \"@openzeppelin/contracts-v5/utils/introspection/ERC165.sol\";\nimport {Ownable} from \"@openzeppelin/contracts-v5/access/Ownable.sol\";\nimport {GatewayFetchTarget, IGatewayVerifier} from \"@unruggable/gateways/contracts/GatewayFetchTarget.sol\";\nimport {GatewayFetcher, GatewayRequest} from \"@unruggable/gateways/contracts/GatewayFetcher.sol\";\n\nimport {INameResolver} from \"../resolvers/profiles/INameResolver.sol\";\nimport {IAddrResolver} from \"../resolvers/profiles/IAddrResolver.sol\";\nimport {IAddressResolver} from \"../resolvers/profiles/IAddressResolver.sol\";\nimport {HexUtils} from \"../utils/HexUtils.sol\";\nimport {IExtendedResolver} from \"../resolvers/profiles/IExtendedResolver.sol\";\nimport {IStandaloneReverseRegistrar} from \"./IStandaloneReverseRegistrar.sol\";\nimport {ENS} from \"../registry/ENS.sol\";\n\n/// @title L1 Reverse Resolver\n/// @notice Resolves reverse records for an L2 chain. Deployed on the L1 chain.\ncontract L1ReverseResolver is\n    GatewayFetchTarget,\n    IExtendedResolver,\n    ERC165,\n    Ownable\n{\n    using GatewayFetcher for GatewayRequest;\n\n    /// @notice The ENS registry contract.\n    ENS immutable ens;\n\n    /// @notice The gateway verifier contract, unique to each L2 chain.\n    IGatewayVerifier immutable verifier;\n\n    /// @notice The target registrar contract on the L2 chain.\n    address immutable target;\n\n    /// @notice A keccak256 hash of the DNS encoded reverse name.\n    ///         NOT using the ENS namehash algorithm\n    bytes32 internal immutable _dnsEncodedReverseNameHash;\n\n    /// @notice The length of the DNS encoded reverse name.\n    uint256 internal immutable _dnsEncodedReverseNameLength;\n\n    /// @notice The namehash of 'default.reverse'\n    bytes32 constant DEFAULT_REVERSE_NODE =\n        0x53a2e7cce84726721578c676b4798972d354dd7c62c832415371716693edd312;\n\n    /// @notice Storage slot for the names mapping in the target registrar contract.\n    uint256 internal constant NAMES_SLOT = 0;\n\n    /// @notice The length of an address in bytes.\n    uint256 internal constant ADDRESS_LENGTH = 40;\n\n    /// @notice The verifier gateway URLs.\n    string[] internal _urls;\n\n    /// @notice Emitted when the gateway URLs are changed.\n    event GatewayURLsChanged(string[] urls);\n\n    /// @notice Thrown when the name is not reachable in this resolver's namespace.\n    error Unreachable(bytes name);\n\n    /// @notice Thrown when the resolver profile is unknown.\n    error UnknownResolverProfile(bytes4 selector);\n\n    /// @notice Sets the initial state of the contract.\n    ///\n    /// @param owner_ The owner of the contract, able to modify the gateway URLs.\n    /// @param ens_ The ENS registry contract.\n    /// @param verifier_ The gateway verifier contract, unique to each L2 chain.\n    /// @param target_ The target registrar contract on the L2 chain.\n    /// @param dnsEncodedReverseName_ The DNS encoded reverse name.\n    /// @param urls_ The verifier gateway URLs.\n    constructor(\n        address owner_,\n        ENS ens_,\n        IGatewayVerifier verifier_,\n        address target_,\n        bytes memory dnsEncodedReverseName_,\n        string[] memory urls_\n    ) Ownable(owner_) {\n        ens = ens_;\n        verifier = verifier_;\n        target = target_;\n        _dnsEncodedReverseNameHash = keccak256(dnsEncodedReverseName_);\n        _dnsEncodedReverseNameLength = dnsEncodedReverseName_.length;\n        _urls = urls_;\n    }\n\n    /// @notice Sets the gateway URLs.\n    ///\n    /// @param urls The new gateway URLs.\n    function setGatewayURLs(string[] memory urls) external onlyOwner {\n        _urls = urls;\n        emit GatewayURLsChanged(urls);\n    }\n\n    /// @notice Gets the gateway URLs.\n    ///\n    /// @return The gateway URLs.\n    function gatewayURLs() external view returns (string[] memory) {\n        return _urls;\n    }\n\n    /// @notice Resolves and verifies `name` records on the target L2 chain's registrar contract,\n    ///         or falls back to the default resolver if the name is not found.\n    ///         Also supports `addr` calls for the L2 chain's reverse namespace,\n    ///         which resolves to the target L2 chain's registrar contract.\n    ///\n    /// @param name The DNS encoded ENS name to query.\n    /// @param data The resolver calldata.\n    /// @return result The result of the call.\n    function resolve(\n        bytes calldata name,\n        bytes calldata data\n    ) external view returns (bytes memory result) {\n        bytes4 selector = bytes4(data);\n\n        bool isNamespaceCall = keccak256(name) == _dnsEncodedReverseNameHash;\n        if (!isNamespaceCall) {\n            if (\n                name.length != _dnsEncodedReverseNameLength + ADDRESS_LENGTH + 1\n            ) revert Unreachable(name);\n            if (keccak256(name[41:]) != _dnsEncodedReverseNameHash)\n                revert Unreachable(name);\n        }\n\n        if (selector == INameResolver.name.selector) {\n            if (isNamespaceCall) return abi.encode(\"\");\n            (address addr, ) = HexUtils.hexToAddress(\n                name,\n                1,\n                ADDRESS_LENGTH + 1\n            );\n            // Always throws, does not need to return.\n            _fetchName(addr);\n        } else if (selector == IAddressResolver.addr.selector) {\n            if (isNamespaceCall) return abi.encode(abi.encodePacked(target));\n            return abi.encode(\"\");\n        }\n\n        revert UnknownResolverProfile(selector);\n    }\n\n    /// @notice Callback function, called by the verifier contract.\n    ///\n    /// @dev If the returned value is empty, data is returned from the default resolver.\n    ///\n    /// @param values The values returned from the verifier contract.\n    ///               Should be a single value.\n    /// @param carry The address to query the default resolver for, ABI encoded.\n    /// @return The name for the given address, ABI encoded.\n    function fetchNameCallback(\n        bytes[] memory values,\n        uint8 /* exitCode */,\n        bytes memory carry\n    ) external view returns (bytes memory) {\n        if (values[0].length == 0) {\n            address addr = abi.decode(carry, (address));\n            return abi.encode(_getDefaultNameFromAddr(addr));\n        } else {\n            return abi.encode(values[0]);\n        }\n    }\n\n    /// @dev Fetches the name for a given node using the verifier contract.\n    ///\n    /// @param addr The address used for the query.\n    function _fetchName(address addr) internal view {\n        fetch(\n            // Verifier target\n            verifier,\n            // Gateway request\n            // 1 request to L2 target registrar contract\n            // Gets data for `names[addr]`\n            GatewayFetcher\n                .newRequest(1)\n                .setTarget(target)\n                .setSlot(NAMES_SLOT)\n                .push(bytes32(uint256(uint160(addr))))\n                .follow()\n                .readBytes()\n                .setOutput(0),\n            // Callback function\n            this.fetchNameCallback.selector,\n            // Carry data, for default fallback\n            abi.encode(addr),\n            // Gateway URLs\n            _urls\n        );\n    }\n\n    /// @dev Resolves the default reverse registrar, and returns the name for the given address.\n    ///\n    /// @param addr The address to query the default resolver for.\n    /// @return The default name for the given address.\n    function _getDefaultNameFromAddr(\n        address addr\n    ) internal view returns (string memory) {\n        IStandaloneReverseRegistrar defaultReverseRegistrar = IStandaloneReverseRegistrar(\n                ens.resolver(DEFAULT_REVERSE_NODE)\n            );\n        return defaultReverseRegistrar.nameForAddr(addr);\n    }\n\n    /// @inheritdoc IERC165\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view override returns (bool) {\n        return\n            interfaceId == type(IExtendedResolver).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/utils/HexUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nlibrary HexUtils {\n    /// @dev Attempts to parse bytes32 from a hex string\n    /// @param str The string to parse\n    /// @param idx The offset to start parsing at\n    /// @param lastIdx The (exclusive) last index in `str` to consider. Use `str.length` to scan the whole string.\n    function hexStringToBytes32(\n        bytes memory str,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal pure returns (bytes32, bool) {\n        require(lastIdx - idx <= 64);\n        (bytes memory r, bool valid) = hexToBytes(str, idx, lastIdx);\n        if (!valid) {\n            return (bytes32(0), false);\n        }\n        bytes32 ret;\n        assembly {\n            ret := shr(mul(4, sub(64, sub(lastIdx, idx))), mload(add(r, 32)))\n        }\n        return (ret, true);\n    }\n\n    function hexToBytes(\n        bytes memory str,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal pure returns (bytes memory r, bool valid) {\n        uint256 hexLength = lastIdx - idx;\n        if (hexLength % 2 == 1) {\n            revert(\"Invalid string length\");\n        }\n        r = new bytes(hexLength / 2);\n        valid = true;\n        assembly {\n            // check that the index to read to is not past the end of the string\n            if gt(lastIdx, mload(str)) {\n                revert(0, 0)\n            }\n\n            function getHex(c) -> ascii {\n                // chars 48-57: 0-9\n                if and(gt(c, 47), lt(c, 58)) {\n                    ascii := sub(c, 48)\n                    leave\n                }\n                // chars 65-70: A-F\n                if and(gt(c, 64), lt(c, 71)) {\n                    ascii := add(sub(c, 65), 10)\n                    leave\n                }\n                // chars 97-102: a-f\n                if and(gt(c, 96), lt(c, 103)) {\n                    ascii := add(sub(c, 97), 10)\n                    leave\n                }\n                // invalid char\n                ascii := 0xff\n            }\n\n            let ptr := add(str, 32)\n            for {\n                let i := idx\n            } lt(i, lastIdx) {\n                i := add(i, 2)\n            } {\n                let byte1 := getHex(byte(0, mload(add(ptr, i))))\n                let byte2 := getHex(byte(0, mload(add(ptr, add(i, 1)))))\n                // if either byte is invalid, set invalid and break loop\n                if or(eq(byte1, 0xff), eq(byte2, 0xff)) {\n                    valid := false\n                    break\n                }\n                let combined := or(shl(4, byte1), byte2)\n                mstore8(add(add(r, 32), div(sub(i, idx), 2)), combined)\n            }\n        }\n    }\n\n    /// @dev Attempts to parse an address from a hex string\n    /// @param str The string to parse\n    /// @param idx The offset to start parsing at\n    /// @param lastIdx The (exclusive) last index in `str` to consider. Use `str.length` to scan the whole string.\n    function hexToAddress(\n        bytes memory str,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal pure returns (address, bool) {\n        if (lastIdx - idx < 40) return (address(0x0), false);\n        (bytes32 r, bool valid) = hexStringToBytes32(str, idx, lastIdx);\n        return (address(uint160(uint256(r))), valid);\n    }\n\n    /// @dev Format an address as a hex string.\n    /// @param addr The address to format.\n    /// @return hexString The corresponding hex string w/o a 0x-prefix.\n    function addressToHex(\n        address addr\n    ) internal pure returns (string memory hexString) {\n        // return bytesToHex(abi.encodePacked(addr));\n        hexString = new string(40);\n        uint256 dst;\n        assembly {\n            mstore(0, addr)\n            dst := add(hexString, 32)\n        }\n        unsafeHex(12, dst, 40);\n    }\n\n    /// @dev Format an integer as a variable-length hex string without zero padding.\n    /// * unpaddedUintToHex(0, true)  = \"0\"\n    /// * unpaddedUintToHex(1, true)  = \"1\"\n    /// * unpaddedUintToHex(0, false) = \"00\"\n    /// * unpaddedUintToHex(1, false) = \"01\"\n    /// @param value The number to format.\n    /// @param dropZeroNibble If true, the leading byte will use one nibble if less than 16.\n    /// @return hexString The corresponding hex string w/o a 0x-prefix.\n    function unpaddedUintToHex(\n        uint256 value,\n        bool dropZeroNibble\n    ) internal pure returns (string memory hexString) {\n        uint256 temp = value;\n        uint256 shift;\n        for (uint256 b = 128; b >= 8; b >>= 1) {\n            if (temp < (1 << b)) {\n                shift += b; // number of zero upper bits\n            } else {\n                temp >>= b; // shift away lower half\n            }\n        }\n        if (dropZeroNibble && temp < 16) shift += 4;\n        uint256 nibbles = 64 - (shift >> 2);\n        hexString = new string(nibbles);\n        uint256 dst;\n        assembly {\n            mstore(0, shl(shift, value)) // left-align\n            dst := add(hexString, 32)\n        }\n        unsafeHex(0, dst, nibbles);\n    }\n\n    /// @dev Format bytes as a hex string.\n    /// @param v The bytes to format.\n    /// @return hexString The corresponding hex string w/o a 0x-prefix.\n    function bytesToHex(\n        bytes memory v\n    ) internal pure returns (string memory hexString) {\n        uint256 nibbles = v.length << 1;\n        hexString = new string(nibbles);\n        uint256 src;\n        uint256 dst;\n        assembly {\n            src := add(v, 32)\n            dst := add(hexString, 32)\n        }\n        unsafeHex(src, dst, nibbles);\n    }\n\n    /// @dev Converts arbitrary memory to a hex string.\n    /// @param src The memory offset of first nibble of input.\n    /// @param dst The memory offset of first hex-char of output.\n    /// @param nibbles The number of nibbles to convert and the byte-length of the output.\n    function unsafeHex(\n        uint256 src,\n        uint256 dst,\n        uint256 nibbles\n    ) internal pure {\n        unchecked {\n            for (uint256 end = dst + nibbles; dst < end; src += 32) {\n                uint256 word;\n                assembly {\n                    word := mload(src)\n                }\n                for (uint256 shift = 256; dst < end && shift > 0; dst++) {\n                    uint256 b = (word >> (shift -= 4)) & 15; // each nibble\n                    b = b < 10 ? b + 0x30 : b + 0x57; // (\"a\" - 10) => 0x57\n                    assembly {\n                        mstore8(dst, b)\n                    }\n                }\n            }\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "metadata": {
      "useLiteralContent": true
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}