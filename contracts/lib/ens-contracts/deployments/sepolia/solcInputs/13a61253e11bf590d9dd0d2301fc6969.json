{
  "language": "Solidity",
  "sources": {
    "@ensdomains/buffer/contracts/Buffer.sol": {
      "content": "// SPDX-License-Identifier: BSD-2-Clause\npragma solidity ^0.8.4;\n\n/**\n* @dev A library for working with mutable byte buffers in Solidity.\n*\n* Byte buffers are mutable and expandable, and provide a variety of primitives\n* for appending to them. At any time you can fetch a bytes object containing the\n* current contents of the buffer. The bytes object should not be stored between\n* operations, as it may change due to resizing of the buffer.\n*/\nlibrary Buffer {\n    /**\n    * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n    *      a capacity. The capacity may be longer than the current value, in\n    *      which case it can be extended without the need to allocate more memory.\n    */\n    struct buffer {\n        bytes buf;\n        uint capacity;\n    }\n\n    /**\n    * @dev Initializes a buffer with an initial capacity.\n    * @param buf The buffer to initialize.\n    * @param capacity The number of bytes of space to allocate the buffer.\n    * @return The buffer, for chaining.\n    */\n    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\n        if (capacity % 32 != 0) {\n            capacity += 32 - (capacity % 32);\n        }\n        // Allocate space for the buffer data\n        buf.capacity = capacity;\n        assembly {\n            let ptr := mload(0x40)\n            mstore(buf, ptr)\n            mstore(ptr, 0)\n            let fpm := add(32, add(ptr, capacity))\n            if lt(fpm, ptr) {\n                revert(0, 0)\n            }\n            mstore(0x40, fpm)\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Initializes a new buffer from an existing bytes object.\n    *      Changes to the buffer may mutate the original value.\n    * @param b The bytes object to initialize the buffer with.\n    * @return A new buffer.\n    */\n    function fromBytes(bytes memory b) internal pure returns(buffer memory) {\n        buffer memory buf;\n        buf.buf = b;\n        buf.capacity = b.length;\n        return buf;\n    }\n\n    function resize(buffer memory buf, uint capacity) private pure {\n        bytes memory oldbuf = buf.buf;\n        init(buf, capacity);\n        append(buf, oldbuf);\n    }\n\n    /**\n    * @dev Sets buffer length to 0.\n    * @param buf The buffer to truncate.\n    * @return The original buffer, for chaining..\n    */\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\n        assembly {\n            let bufptr := mload(buf)\n            mstore(bufptr, 0)\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Appends len bytes of a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @param len The number of bytes to copy.\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes memory data, uint len) internal pure returns(buffer memory) {\n        require(len <= data.length);\n\n        uint off = buf.buf.length;\n        uint newCapacity = off + len;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        uint dest;\n        uint src;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Start address = buffer address + offset + sizeof(buffer length)\n            dest := add(add(bufptr, 32), off)\n            // Update buffer length if we're extending it\n            if gt(newCapacity, buflen) {\n                mstore(bufptr, newCapacity)\n            }\n            src := add(data, 32)\n        }\n\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        unchecked {\n            uint mask = (256 ** (32 - len)) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask))\n                let destpart := and(mload(dest), mask)\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n\n        return buf;\n    }\n\n    /**\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n        return append(buf, data, data.length);\n    }\n\n    /**\n    * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\n    *      capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint offPlusOne = off + 1;\n        if (off >= buf.capacity) {\n            resize(buf, offPlusOne * 2);\n        }\n\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Address = buffer address + sizeof(buffer length) + off\n            let dest := add(add(bufptr, off), 32)\n            mstore8(dest, data)\n            // Update buffer length if we extended it\n            if gt(offPlusOne, mload(bufptr)) {\n                mstore(bufptr, offPlusOne)\n            }\n        }\n\n        return buf;\n    }\n\n    /**\n    * @dev Appends len bytes of bytes32 to a buffer. Resizes if doing so would\n    *      exceed the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @param len The number of bytes to write (left-aligned).\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes32 data, uint len) private pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint newCapacity = len + off;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        unchecked {\n            uint mask = (256 ** len) - 1;\n            // Right-align data\n            data = data >> (8 * (32 - len));\n            assembly {\n                // Memory address of the buffer data\n                let bufptr := mload(buf)\n                // Address = buffer address + sizeof(buffer length) + newCapacity\n                let dest := add(bufptr, newCapacity)\n                mstore(dest, or(and(mload(dest), not(mask)), data))\n                // Update buffer length if we extended it\n                if gt(newCapacity, mload(bufptr)) {\n                    mstore(bufptr, newCapacity)\n                }\n            }\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chhaining.\n    */\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\n        return append(buf, bytes32(data), 20);\n    }\n\n    /**\n    * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\n        return append(buf, data, 32);\n    }\n\n    /**\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n     *      exceed the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @param len The number of bytes to write (right-aligned).\n     * @return The original buffer.\n     */\n    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint newCapacity = len + off;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        uint mask = (256 ** len) - 1;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Address = buffer address + sizeof(buffer length) + newCapacity\n            let dest := add(bufptr, newCapacity)\n            mstore(dest, or(and(mload(dest), not(mask)), data))\n            // Update buffer length if we extended it\n            if gt(newCapacity, mload(bufptr)) {\n                mstore(bufptr, newCapacity)\n            }\n        }\n        return buf;\n    }\n}\n"
    },
    "@ensdomains/solsha1/contracts/SHA1.sol": {
      "content": "pragma solidity ^0.8.4;\n\nlibrary SHA1 {\n    event Debug(bytes32 x);\n\n    function sha1(bytes memory data) internal pure returns(bytes20 ret) {\n        assembly {\n            // Get a safe scratch location\n            let scratch := mload(0x40)\n\n            // Get the data length, and point data at the first byte\n            let len := mload(data)\n            data := add(data, 32)\n\n            // Find the length after padding\n            let totallen := add(and(add(len, 1), 0xFFFFFFFFFFFFFFC0), 64)\n            switch lt(sub(totallen, len), 9)\n            case 1 { totallen := add(totallen, 64) }\n\n            let h := 0x6745230100EFCDAB890098BADCFE001032547600C3D2E1F0\n\n            function readword(ptr, off, count) -> result {\n                result := 0\n                if lt(off, count) {\n                    result := mload(add(ptr, off))\n                    count := sub(count, off)\n                    if lt(count, 32) {\n                        let mask := not(sub(exp(256, sub(32, count)), 1))\n                        result := and(result, mask)\n                    }\n                }\n            }\n\n            for { let i := 0 } lt(i, totallen) { i := add(i, 64) } {\n                mstore(scratch, readword(data, i, len))\n                mstore(add(scratch, 32), readword(data, add(i, 32), len))\n\n                // If we loaded the last byte, store the terminator byte\n                switch lt(sub(len, i), 64)\n                case 1 { mstore8(add(scratch, sub(len, i)), 0x80) }\n\n                // If this is the last block, store the length\n                switch eq(i, sub(totallen, 64))\n                case 1 { mstore(add(scratch, 32), or(mload(add(scratch, 32)), mul(len, 8))) }\n\n                // Expand the 16 32-bit words into 80\n                for { let j := 64 } lt(j, 128) { j := add(j, 12) } {\n                    let temp := xor(xor(mload(add(scratch, sub(j, 12))), mload(add(scratch, sub(j, 32)))), xor(mload(add(scratch, sub(j, 56))), mload(add(scratch, sub(j, 64)))))\n                    temp := or(and(mul(temp, 2), 0xFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFE), and(div(temp, 0x80000000), 0x0000000100000001000000010000000100000001000000010000000100000001))\n                    mstore(add(scratch, j), temp)\n                }\n                for { let j := 128 } lt(j, 320) { j := add(j, 24) } {\n                    let temp := xor(xor(mload(add(scratch, sub(j, 24))), mload(add(scratch, sub(j, 64)))), xor(mload(add(scratch, sub(j, 112))), mload(add(scratch, sub(j, 128)))))\n                    temp := or(and(mul(temp, 4), 0xFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFC), and(div(temp, 0x40000000), 0x0000000300000003000000030000000300000003000000030000000300000003))\n                    mstore(add(scratch, j), temp)\n                }\n\n                let x := h\n                let f := 0\n                let k := 0\n                for { let j := 0 } lt(j, 80) { j := add(j, 1) } {\n                    switch div(j, 20)\n                    case 0 {\n                        // f = d xor (b and (c xor d))\n                        f := xor(div(x, 0x100000000000000000000), div(x, 0x10000000000))\n                        f := and(div(x, 0x1000000000000000000000000000000), f)\n                        f := xor(div(x, 0x10000000000), f)\n                        k := 0x5A827999\n                    }\n                    case 1{\n                        // f = b xor c xor d\n                        f := xor(div(x, 0x1000000000000000000000000000000), div(x, 0x100000000000000000000))\n                        f := xor(div(x, 0x10000000000), f)\n                        k := 0x6ED9EBA1\n                    }\n                    case 2 {\n                        // f = (b and c) or (d and (b or c))\n                        f := or(div(x, 0x1000000000000000000000000000000), div(x, 0x100000000000000000000))\n                        f := and(div(x, 0x10000000000), f)\n                        f := or(and(div(x, 0x1000000000000000000000000000000), div(x, 0x100000000000000000000)), f)\n                        k := 0x8F1BBCDC\n                    }\n                    case 3 {\n                        // f = b xor c xor d\n                        f := xor(div(x, 0x1000000000000000000000000000000), div(x, 0x100000000000000000000))\n                        f := xor(div(x, 0x10000000000), f)\n                        k := 0xCA62C1D6\n                    }\n                    // temp = (a leftrotate 5) + f + e + k + w[i]\n                    let temp := and(div(x, 0x80000000000000000000000000000000000000000000000), 0x1F)\n                    temp := or(and(div(x, 0x800000000000000000000000000000000000000), 0xFFFFFFE0), temp)\n                    temp := add(f, temp)\n                    temp := add(and(x, 0xFFFFFFFF), temp)\n                    temp := add(k, temp)\n                    temp := add(div(mload(add(scratch, mul(j, 4))), 0x100000000000000000000000000000000000000000000000000000000), temp)\n                    x := or(div(x, 0x10000000000), mul(temp, 0x10000000000000000000000000000000000000000))\n                    x := or(and(x, 0xFFFFFFFF00FFFFFFFF000000000000FFFFFFFF00FFFFFFFF), mul(or(and(div(x, 0x4000000000000), 0xC0000000), and(div(x, 0x400000000000000000000), 0x3FFFFFFF)), 0x100000000000000000000))\n                }\n\n                h := and(add(h, x), 0xFFFFFFFF00FFFFFFFF00FFFFFFFF00FFFFFFFF00FFFFFFFF)\n            }\n            ret := mul(or(or(or(or(and(div(h, 0x100000000), 0xFFFFFFFF00000000000000000000000000000000), and(div(h, 0x1000000), 0xFFFFFFFF000000000000000000000000)), and(div(h, 0x10000), 0xFFFFFFFF0000000000000000)), and(div(h, 0x100), 0xFFFFFFFF00000000)), and(h, 0xFFFFFFFF)), 0x1000000000000000000000000)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-v5/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts-v5/interfaces/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/IERC1271.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n */\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param hash      Hash of the data to be signed\n     * @param signature Signature byte array associated with _data\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "@openzeppelin/contracts-v5/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-v5/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes memory signature\n    ) internal pure returns (address recovered, RecoverError err, bytes32 errArg) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly (\"memory-safe\") {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[ERC-2098 short signatures]\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address recovered, RecoverError err, bytes32 errArg) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address recovered, RecoverError err, bytes32 errArg) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-v5/utils/cryptography/MessageHashUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/cryptography/MessageHashUtils.sol)\n\npragma solidity ^0.8.20;\n\nimport {Strings} from \"../Strings.sol\";\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[ERC-191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an ERC-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an ERC-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an ERC-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (ERC-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-v5/utils/cryptography/SignatureChecker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/cryptography/SignatureChecker.sol)\n\npragma solidity ^0.8.20;\n\nimport {ECDSA} from \"./ECDSA.sol\";\nimport {IERC1271} from \"../../interfaces/IERC1271.sol\";\n\n/**\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\n * signatures from externally owned accounts (EOAs) as well as ERC-1271 signatures from smart contract wallets like\n * Argent and Safe Wallet (previously Gnosis Safe).\n */\nlibrary SignatureChecker {\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\n     * signature is validated against that smart contract using ERC-1271, otherwise it's validated using `ECDSA.recover`.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature) internal view returns (bool) {\n        if (signer.code.length == 0) {\n            (address recovered, ECDSA.RecoverError err, ) = ECDSA.tryRecover(hash, signature);\n            return err == ECDSA.RecoverError.NoError && recovered == signer;\n        } else {\n            return isValidERC1271SignatureNow(signer, hash, signature);\n        }\n    }\n\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. The signature is validated\n     * against the signer smart contract using ERC-1271.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidERC1271SignatureNow(\n        address signer,\n        bytes32 hash,\n        bytes memory signature\n    ) internal view returns (bool) {\n        (bool success, bytes memory result) = signer.staticcall(\n            abi.encodeCall(IERC1271.isValidSignature, (hash, signature))\n        );\n        return (success &&\n            result.length >= 32 &&\n            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));\n    }\n}\n"
    },
    "@openzeppelin/contracts-v5/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts-v5/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-v5/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\nimport {Panic} from \"../Panic.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an success flag (no overflow).\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an success flag (no overflow).\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an success flag (no overflow).\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * SafeCast.toUint(condition));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        // The following calculation ensures accurate ceiling division without overflow.\n        // Since a is non-zero, (a - 1) / b will not overflow.\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\n        // when a = type(uint256).max and b = 1.\n        unchecked {\n            return SafeCast.toUint(a > 0) * ((a - 1) / b + 1);\n        }\n    }\n\n    /**\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     *\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2²⁵⁶ and mod 2²⁵⁶ - 1, then use\n            // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2²⁵⁶ + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2²⁵⁶. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2²⁵⁶ / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2²⁵⁶. Now that denominator is an odd number, it has an inverse modulo 2²⁵⁶ such\n            // that denominator * inv ≡ 1 mod 2²⁵⁶. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv ≡ 1 mod 2⁴.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹⁶\n            inverse *= 2 - denominator * inverse; // inverse mod 2³²\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁶⁴\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹²⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2²⁵⁶\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2²⁵⁶. Since the preconditions guarantee that the outcome is\n            // less than 2²⁵⁶, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\n    }\n\n    /**\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\n     *\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\n     *\n     * If the input value is not inversible, 0 is returned.\n     *\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the\n     * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.\n     */\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\n        unchecked {\n            if (n == 0) return 0;\n\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\n            // ax + ny = 1\n            // ax = 1 + (-y)n\n            // ax ≡ 1 (mod n) # x is the inverse of a modulo n\n\n            // If the remainder is 0 the gcd is n right away.\n            uint256 remainder = a % n;\n            uint256 gcd = n;\n\n            // Therefore the initial coefficients are:\n            // ax + ny = gcd(a, n) = n\n            // 0a + 1n = n\n            int256 x = 0;\n            int256 y = 1;\n\n            while (remainder != 0) {\n                uint256 quotient = gcd / remainder;\n\n                (gcd, remainder) = (\n                    // The old remainder is the next gcd to try.\n                    remainder,\n                    // Compute the next remainder.\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\n                    // where gcd is at most n (capped to type(uint256).max)\n                    gcd - remainder * quotient\n                );\n\n                (x, y) = (\n                    // Increment the coefficient of a.\n                    y,\n                    // Decrement the coefficient of n.\n                    // Can overflow, but the result is casted to uint256 so that the\n                    // next value of y is \"wrapped around\" to a value between 0 and n - 1.\n                    x - y * int256(quotient)\n                );\n            }\n\n            if (gcd != 1) return 0; // No inverse exists.\n            return ternary(x < 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.\n        }\n    }\n\n    /**\n     * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.\n     *\n     * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is\n     * prime, then `a**(p-1) ≡ 1 mod p`. As a consequence, we have `a * a**(p-2) ≡ 1 mod p`, which means that\n     * `a**(p-2)` is the modular multiplicative inverse of a in Fp.\n     *\n     * NOTE: this function does NOT check that `p` is a prime greater than `2`.\n     */\n    function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {\n        unchecked {\n            return Math.modExp(a, p - 2, p);\n        }\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\n     *\n     * Requirements:\n     * - modulus can't be zero\n     * - underlying staticcall to precompile must succeed\n     *\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\n     * interpreted as 0.\n     */\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        (bool success, uint256 result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying\n     * to operate modulo 0 or if the underlying precompile reverted.\n     *\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\n     * of a revert, but the result may be incorrectly interpreted as 0.\n     */\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\n        if (m == 0) return (false, 0);\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            // | Offset    | Content    | Content (Hex)                                                      |\n            // |-----------|------------|--------------------------------------------------------------------|\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\n            mstore(ptr, 0x20)\n            mstore(add(ptr, 0x20), 0x20)\n            mstore(add(ptr, 0x40), 0x20)\n            mstore(add(ptr, 0x60), b)\n            mstore(add(ptr, 0x80), e)\n            mstore(add(ptr, 0xa0), m)\n\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\n            // so we can use the memory scratch space located at offset 0.\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /**\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\n     */\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\n        (bool success, bytes memory result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\n     */\n    function tryModExp(\n        bytes memory b,\n        bytes memory e,\n        bytes memory m\n    ) internal view returns (bool success, bytes memory result) {\n        if (_zeroBytes(m)) return (false, new bytes(0));\n\n        uint256 mLen = m.length;\n\n        // Encode call args in result and move the free memory pointer\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\n\n        assembly (\"memory-safe\") {\n            let dataPtr := add(result, 0x20)\n            // Write result on top of args to avoid allocating extra memory.\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\n            // Overwrite the length.\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\n            mstore(result, mLen)\n            // Set the memory pointer after the returned data.\n            mstore(0x40, add(dataPtr, mLen))\n        }\n    }\n\n    /**\n     * @dev Returns whether the provided byte array is zero.\n     */\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\n        for (uint256 i = 0; i < byteArray.length; ++i) {\n            if (byteArray[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\n     * using integer operations.\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        unchecked {\n            // Take care of easy edge cases when a == 0 or a == 1\n            if (a <= 1) {\n                return a;\n            }\n\n            // In this function, we use Newton's method to get a root of `f(x) := x² - a`. It involves building a\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\n            // the current value as `ε_n = | x_n - sqrt(a) |`.\n            //\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\n            // of the target. (i.e. `2**(e-1) ≤ sqrt(a) < 2**e`). We know that `e ≤ 128` because `(2¹²⁸)² = 2²⁵⁶` is\n            // bigger than any uint256.\n            //\n            // By noticing that\n            // `2**(e-1) ≤ sqrt(a) < 2**e → (2**(e-1))² ≤ a < (2**e)² → 2**(2*e-2) ≤ a < 2**(2*e)`\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\n            // to the msb function.\n            uint256 aa = a;\n            uint256 xn = 1;\n\n            if (aa >= (1 << 128)) {\n                aa >>= 128;\n                xn <<= 64;\n            }\n            if (aa >= (1 << 64)) {\n                aa >>= 64;\n                xn <<= 32;\n            }\n            if (aa >= (1 << 32)) {\n                aa >>= 32;\n                xn <<= 16;\n            }\n            if (aa >= (1 << 16)) {\n                aa >>= 16;\n                xn <<= 8;\n            }\n            if (aa >= (1 << 8)) {\n                aa >>= 8;\n                xn <<= 4;\n            }\n            if (aa >= (1 << 4)) {\n                aa >>= 4;\n                xn <<= 2;\n            }\n            if (aa >= (1 << 2)) {\n                xn <<= 1;\n            }\n\n            // We now have x_n such that `x_n = 2**(e-1) ≤ sqrt(a) < 2**e = 2 * x_n`. This implies ε_n ≤ 2**(e-1).\n            //\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to ε_n ≤ 2**(e-2).\n            // This is going to be our x_0 (and ε_0)\n            xn = (3 * xn) >> 1; // ε_0 := | x_0 - sqrt(a) | ≤ 2**(e-2)\n\n            // From here, Newton's method give us:\n            // x_{n+1} = (x_n + a / x_n) / 2\n            //\n            // One should note that:\n            // x_{n+1}² - a = ((x_n + a / x_n) / 2)² - a\n            //              = ((x_n² + a) / (2 * x_n))² - a\n            //              = (x_n⁴ + 2 * a * x_n² + a²) / (4 * x_n²) - a\n            //              = (x_n⁴ + 2 * a * x_n² + a² - 4 * a * x_n²) / (4 * x_n²)\n            //              = (x_n⁴ - 2 * a * x_n² + a²) / (4 * x_n²)\n            //              = (x_n² - a)² / (2 * x_n)²\n            //              = ((x_n² - a) / (2 * x_n))²\n            //              ≥ 0\n            // Which proves that for all n ≥ 1, sqrt(a) ≤ x_n\n            //\n            // This gives us the proof of quadratic convergence of the sequence:\n            // ε_{n+1} = | x_{n+1} - sqrt(a) |\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\n            //         = | (x_n² + a - 2*x_n*sqrt(a)) / (2 * x_n) |\n            //         = | (x_n - sqrt(a))² / (2 * x_n) |\n            //         = | ε_n² / (2 * x_n) |\n            //         = ε_n² / | (2 * x_n) |\n            //\n            // For the first iteration, we have a special case where x_0 is known:\n            // ε_1 = ε_0² / | (2 * x_0) |\n            //     ≤ (2**(e-2))² / (2 * (2**(e-1) + 2**(e-2)))\n            //     ≤ 2**(2*e-4) / (3 * 2**(e-1))\n            //     ≤ 2**(e-3) / 3\n            //     ≤ 2**(e-3-log2(3))\n            //     ≤ 2**(e-4.5)\n            //\n            // For the following iterations, we use the fact that, 2**(e-1) ≤ sqrt(a) ≤ x_n:\n            // ε_{n+1} = ε_n² / | (2 * x_n) |\n            //         ≤ (2**(e-k))² / (2 * 2**(e-1))\n            //         ≤ 2**(2*e-2*k) / 2**e\n            //         ≤ 2**(e-2*k)\n            xn = (xn + a / xn) >> 1; // ε_1 := | x_1 - sqrt(a) | ≤ 2**(e-4.5)  -- special case, see above\n            xn = (xn + a / xn) >> 1; // ε_2 := | x_2 - sqrt(a) | ≤ 2**(e-9)    -- general case with k = 4.5\n            xn = (xn + a / xn) >> 1; // ε_3 := | x_3 - sqrt(a) | ≤ 2**(e-18)   -- general case with k = 9\n            xn = (xn + a / xn) >> 1; // ε_4 := | x_4 - sqrt(a) | ≤ 2**(e-36)   -- general case with k = 18\n            xn = (xn + a / xn) >> 1; // ε_5 := | x_5 - sqrt(a) | ≤ 2**(e-72)   -- general case with k = 36\n            xn = (xn + a / xn) >> 1; // ε_6 := | x_6 - sqrt(a) | ≤ 2**(e-144)  -- general case with k = 72\n\n            // Because e ≤ 128 (as discussed during the first estimation phase), we know have reached a precision\n            // ε_6 ≤ 2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\n            // sqrt(a) or sqrt(a) + 1.\n            return xn - SafeCast.toUint(xn > a / xn);\n        }\n    }\n\n    /**\n     * @dev Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        uint256 exp;\n        unchecked {\n            exp = 128 * SafeCast.toUint(value > (1 << 128) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 64 * SafeCast.toUint(value > (1 << 64) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 32 * SafeCast.toUint(value > (1 << 32) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 16 * SafeCast.toUint(value > (1 << 16) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 8 * SafeCast.toUint(value > (1 << 8) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 4 * SafeCast.toUint(value > (1 << 4) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 2 * SafeCast.toUint(value > (1 << 2) - 1);\n            value >>= exp;\n            result += exp;\n\n            result += SafeCast.toUint(value > 1);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        uint256 isGt;\n        unchecked {\n            isGt = SafeCast.toUint(value > (1 << 128) - 1);\n            value >>= isGt * 128;\n            result += isGt * 16;\n\n            isGt = SafeCast.toUint(value > (1 << 64) - 1);\n            value >>= isGt * 64;\n            result += isGt * 8;\n\n            isGt = SafeCast.toUint(value > (1 << 32) - 1);\n            value >>= isGt * 32;\n            result += isGt * 4;\n\n            isGt = SafeCast.toUint(value > (1 << 16) - 1);\n            value >>= isGt * 16;\n            result += isGt * 2;\n\n            result += SafeCast.toUint(value > (1 << 8) - 1);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts-v5/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        assembly (\"memory-safe\") {\n            u := iszero(iszero(b))\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-v5/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, int256 a, int256 b) internal pure returns (int256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * int256(SafeCast.toUint(condition)));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // Formula from the \"Bit Twiddling Hacks\" by Sean Eron Anderson.\n            // Since `n` is a signed integer, the generated bytecode will use the SAR opcode to perform the right shift,\n            // taking advantage of the most significant (or \"sign\" bit) in two's complement representation.\n            // This opcode adds new most significant bits set to the value of the previous most significant bit. As a result,\n            // the mask will either be `bytes32(0)` (if n is positive) or `~bytes32(0)` (if n is negative).\n            int256 mask = n >> 255;\n\n            // A `bytes32(0)` mask leaves the input unchanged, while a `~bytes32(0)` mask complements it.\n            return uint256((n + mask) ^ mask);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-v5/utils/Panic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library for emitting standardized panic codes.\n *\n * ```solidity\n * contract Example {\n *      using Panic for uint256;\n *\n *      // Use any of the declared internal constants\n *      function foo() { Panic.GENERIC.panic(); }\n *\n *      // Alternatively\n *      function foo() { Panic.panic(Panic.GENERIC); }\n * }\n * ```\n *\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\n *\n * _Available since v5.1._\n */\n// slither-disable-next-line unused-state\nlibrary Panic {\n    /// @dev generic / unspecified error\n    uint256 internal constant GENERIC = 0x00;\n    /// @dev used by the assert() builtin\n    uint256 internal constant ASSERT = 0x01;\n    /// @dev arithmetic underflow or overflow\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\n    /// @dev division or modulo by zero\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\n    /// @dev enum conversion error\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\n    /// @dev invalid encoding in storage\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\n    /// @dev empty array pop\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\n    /// @dev array out of bounds access\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    /// @dev resource error (too large allocation or too large array)\n    uint256 internal constant RESOURCE_ERROR = 0x41;\n    /// @dev calling invalid internal function\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\n\n    /// @dev Reverts with a panic code. Recommended to use with\n    /// the internal constants with predefined codes.\n    function panic(uint256 code) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0x4e487b71)\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-v5/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly (\"memory-safe\") {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly (\"memory-safe\") {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its checksummed ASCII `string` hexadecimal\n     * representation, according to EIP-55.\n     */\n    function toChecksumHexString(address addr) internal pure returns (string memory) {\n        bytes memory buffer = bytes(toHexString(addr));\n\n        // hash the hex part of buffer (skip length + 2 bytes, length 40)\n        uint256 hashValue;\n        assembly (\"memory-safe\") {\n            hashValue := shr(96, keccak256(add(buffer, 0x22), 40))\n        }\n\n        for (uint256 i = 41; i > 1; --i) {\n            // possible values for buffer[i] are 48 (0) to 57 (9) and 97 (a) to 102 (f)\n            if (hashValue & 0xf > 7 && uint8(buffer[i]) > 96) {\n                // case shift by xoring with 0x20\n                buffer[i] ^= 0x20;\n            }\n            hashValue >>= 4;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n *\n * _Available since v4.1._\n */\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param hash      Hash of the data to be signed\n     * @param signature Signature byte array associated with _data\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner or approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant\n     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such\n     * that `ownerOf(tokenId)` is `a`.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/SignatureChecker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\nimport \"../../interfaces/IERC1271.sol\";\n\n/**\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\n * Argent and Gnosis Safe.\n *\n * _Available since v4.1._\n */\nlibrary SignatureChecker {\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\n     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature) internal view returns (bool) {\n        (address recovered, ECDSA.RecoverError error) = ECDSA.tryRecover(hash, signature);\n        return\n            (error == ECDSA.RecoverError.NoError && recovered == signer) ||\n            isValidERC1271SignatureNow(signer, hash, signature);\n    }\n\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. The signature is validated\n     * against the signer smart contract using ERC1271.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidERC1271SignatureNow(\n        address signer,\n        bytes32 hash,\n        bytes memory signature\n    ) internal view returns (bool) {\n        (bool success, bytes memory result) = signer.staticcall(\n            abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)\n        );\n        return (success &&\n            result.length >= 32 &&\n            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165Checker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface.\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) &&\n            !supportsERC165InterfaceUnchecked(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * _Available since v3.4._\n     */\n    function getSupportedInterfaces(\n        address account,\n        bytes4[] memory interfaceIds\n    ) internal view returns (bool[] memory) {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     *\n     * Some precompiled contracts will falsely indicate support for a given interface, so caution\n     * should be exercised when using this function.\n     *\n     * Interface identification is specified in ERC-165.\n     */\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\n        // prepare call\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\n\n        // perform static call\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly {\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0x00)\n        }\n\n        return success && returnSize >= 0x20 && returnValue > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "@unruggable/gateways/contracts/GatewayFetcher.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {GatewayRequest, GatewayOP} from './GatewayRequest.sol';\n\n// only happens during request construction\nerror RequestOverflow();\n\nlibrary GatewayFetcher {\n    // verifier execution is only constrainted by stack and gas\n    // max outputs = 255\n    // NOTE: this is developer configurable\n    uint256 constant MAX_OPS = 8192;\n\n    using GatewayFetcher for GatewayRequest;\n\n    function newRequest(\n        uint8 outputs\n    ) internal pure returns (GatewayRequest memory) {\n        return newCommand().addByte(outputs);\n    }\n\n    function newCommand() internal pure returns (GatewayRequest memory) {\n        bytes memory v = new bytes(MAX_OPS);\n        assembly {\n            mstore(v, 0) // length = 0\n        }\n        return GatewayRequest(v);\n    }\n\n    function encode(\n        GatewayRequest memory r\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(r.ops);\n    }\n\n    function addByte(\n        GatewayRequest memory r,\n        uint8 i\n    ) internal pure returns (GatewayRequest memory) {\n        bytes memory v = r.ops;\n        uint256 n = v.length;\n        if (n >= MAX_OPS) revert RequestOverflow();\n        assembly {\n            mstore(v, add(n, 1)) // length += 1\n            mstore8(add(add(v, 32), n), i) // append(i)\n        }\n        return r;\n    }\n    function addBytes(\n        GatewayRequest memory r,\n        bytes memory v\n    ) internal pure returns (GatewayRequest memory) {\n        bytes memory buf = r.ops;\n        if (r.ops.length + v.length > MAX_OPS) revert RequestOverflow();\n        assembly {\n            let dst := add(add(buf, 32), mload(buf)) // ptr to write\n            let src := add(v, 32) // ptr to start read\n            for {\n                let src_end := add(src, mload(v)) // ptr to stop read\n            } lt(src, src_end) {\n                src := add(src, 32)\n                dst := add(dst, 32)\n            } {\n                mstore(dst, mload(src)) // copy word\n            }\n            mstore(buf, add(mload(buf), mload(v))) // length += v.length\n        }\n        return r;\n    }\n\n    function debug(\n        GatewayRequest memory r,\n        string memory label\n    ) internal pure returns (GatewayRequest memory) {\n        bytes memory v = bytes(label);\n        if (v.length >= 256) revert RequestOverflow();\n        return r.addByte(GatewayOP.DEBUG).addByte(uint8(v.length)).addBytes(v);\n    }\n\n    function push(\n        GatewayRequest memory r,\n        bool x\n    ) internal pure returns (GatewayRequest memory) {\n        return r.push(x ? 1 : 0);\n    }\n    function push(\n        GatewayRequest memory r,\n        bytes32 x\n    ) internal pure returns (GatewayRequest memory) {\n        return r.push(uint256(x));\n    }\n    function push(\n        GatewayRequest memory r,\n        address x\n    ) internal pure returns (GatewayRequest memory) {\n        return r.push(uint160(x));\n    }\n    function push(\n        GatewayRequest memory r,\n        uint256 x\n    ) internal pure returns (GatewayRequest memory) {\n        // NOTE: compact request building is not necessary\n        // this could just be: return r.addByte(GatewayOP.PUSH_32).addBytes(abi.encode(x));\n        if (x == 0) return r.addByte(GatewayOP.PUSH_0);\n        uint8 n = clz(x); // number of leading zeros\n        x <<= (n << 3); // right pad\n        n = 32 - n; // width w/o pad\n        r.addByte(GatewayOP.PUSH_0 + n);\n        bytes memory v = r.ops;\n        if (v.length + n > MAX_OPS) revert RequestOverflow();\n        assembly {\n            let len := mload(v)\n            mstore(add(add(v, 32), len), x) // append(x)\n            mstore(v, add(len, n)) // length += n\n        }\n        return r;\n    }\n    function clz(uint256 x) private pure returns (uint8 n) {\n        if (x < (1 << 128)) {\n            x <<= 128;\n            n |= 16;\n        }\n        if (x < (1 << 192)) {\n            x <<= 64;\n            n |= 8;\n        }\n        if (x < (1 << 224)) {\n            x <<= 32;\n            n |= 4;\n        }\n        if (x < (1 << 240)) {\n            x <<= 16;\n            n |= 2;\n        }\n        if (x < (1 << 248)) {\n            n |= 1;\n        }\n    }\n\n    function push(\n        GatewayRequest memory r,\n        string memory s\n    ) internal pure returns (GatewayRequest memory) {\n        return r.push(bytes(s));\n    }\n    function push(\n        GatewayRequest memory r,\n        GatewayRequest memory p\n    ) internal pure returns (GatewayRequest memory) {\n        return r.push(p.encode());\n    }\n    function push(\n        GatewayRequest memory r,\n        bytes memory v\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.PUSH_BYTES).push(v.length).addBytes(v);\n    }\n\n    function getSlot(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.GET_SLOT);\n    }\n    function getTarget(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.GET_TARGET);\n    }\n    function stackCount(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.STACK_SIZE);\n    }\n    function isContract(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.IS_CONTRACT);\n    }\n\n    function pushStack(\n        GatewayRequest memory r,\n        uint256 i\n    ) internal pure returns (GatewayRequest memory) {\n        return r.push(i).addByte(GatewayOP.PUSH_STACK);\n        // r.stackCount().push(1).subtract().push(i).subtract().addByte(GatewayOP.DUP);\n    }\n    function pushOutput(\n        GatewayRequest memory r,\n        uint256 i\n    ) internal pure returns (GatewayRequest memory) {\n        return r.push(i).addByte(GatewayOP.PUSH_OUTPUT);\n    }\n\n    function target(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.SET_TARGET);\n    }\n    function setTarget(\n        GatewayRequest memory r,\n        address a\n    ) internal pure returns (GatewayRequest memory) {\n        return r.push(a).target();\n    }\n\n    function output(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.SET_OUTPUT);\n    }\n    function setOutput(\n        GatewayRequest memory r,\n        uint8 i\n    ) internal pure returns (GatewayRequest memory) {\n        return r.push(i).output();\n    }\n    function eval(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.push(true).evalIf();\n    }\n    function evalIf(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.EVAL);\n    }\n    function evalLoop(\n        GatewayRequest memory r,\n        uint8 flags\n    ) internal pure returns (GatewayRequest memory) {\n        return r.evalLoop(flags, 255);\n    }\n    function evalLoop(\n        GatewayRequest memory r,\n        uint8 flags,\n        uint256 count\n    ) internal pure returns (GatewayRequest memory) {\n        return r.push(count).addByte(GatewayOP.EVAL_LOOP).addByte(flags);\n    }\n    function exit(\n        GatewayRequest memory r,\n        uint8 exitCode\n    ) internal pure returns (GatewayRequest memory) {\n        return r.push(false).assertNonzero(exitCode);\n    }\n    function assertNonzero(\n        GatewayRequest memory r,\n        uint8 exitCode\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.ASSERT).addByte(exitCode);\n    }\n    function requireContract(\n        GatewayRequest memory r,\n        uint8 exitCode\n    ) internal pure returns (GatewayRequest memory) {\n        return r.isContract().assertNonzero(exitCode);\n    }\n    function requireNonzero(\n        GatewayRequest memory r,\n        uint8 exitCode\n    ) internal pure returns (GatewayRequest memory) {\n        return r.dup().assertNonzero(exitCode);\n    }\n\n    function setSlot(\n        GatewayRequest memory r,\n        uint256 x\n    ) internal pure returns (GatewayRequest memory) {\n        return r.push(x).slot();\n    }\n    function offset(\n        GatewayRequest memory r,\n        uint256 dx\n    ) internal pure returns (GatewayRequest memory) {\n        return r.push(dx).addSlot();\n    }\n    function addSlot(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.ADD_SLOT);\n        // return r.getSlot().add().slot();\n    }\n    function slot(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.SET_SLOT);\n    }\n    function follow(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.FOLLOW);\n        // return r.getSlot().concat().keccak().slot();\n    }\n    function followIndex(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.getSlot().keccak().slot().addSlot();\n    }\n\n    function read(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.READ_SLOT);\n    }\n    function read(\n        GatewayRequest memory r,\n        uint256 n\n    ) internal pure returns (GatewayRequest memory) {\n        return r.push(n).addByte(GatewayOP.READ_SLOTS);\n    }\n    function readBytes(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.READ_BYTES);\n    }\n    function readHashedBytes(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.READ_HASHED_BYTES);\n    }\n    function readArray(\n        GatewayRequest memory r,\n        uint256 step\n    ) internal pure returns (GatewayRequest memory) {\n        return r.push(step).addByte(GatewayOP.READ_ARRAY);\n    }\n\n    function pop(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.POP);\n    }\n    function dup(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.dup(0);\n    }\n    function dup(\n        GatewayRequest memory r,\n        uint256 back\n    ) internal pure returns (GatewayRequest memory) {\n        return r.push(back).addByte(GatewayOP.DUP);\n    }\n    function swap(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.swap(1);\n    }\n    function swap(\n        GatewayRequest memory r,\n        uint256 back\n    ) internal pure returns (GatewayRequest memory) {\n        return r.push(back).addByte(GatewayOP.SWAP);\n    }\n\n    function concat(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.CONCAT);\n    }\n    function keccak(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.KECCAK);\n    }\n    function slice(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.SLICE);\n    }\n    function slice(\n        GatewayRequest memory r,\n        uint256 pos,\n        uint256 len\n    ) internal pure returns (GatewayRequest memory) {\n        return r.push(pos).push(len).slice();\n    }\n    function length(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.LENGTH);\n    }\n\n    function plus(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.PLUS);\n    }\n    function twosComplement(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.not().push(1).plus();\n    }\n    function subtract(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.twosComplement().plus();\n    }\n    function times(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.TIMES);\n    }\n    function divide(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.DIVIDE);\n    }\n    function mod(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.MOD);\n    }\n    function pow(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.POW);\n    }\n    function and(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.AND);\n    }\n    function or(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.OR);\n    }\n    function xor(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.XOR);\n    }\n    function isZero(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.IS_ZERO);\n    }\n    function not(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.NOT);\n    }\n    function shl(\n        GatewayRequest memory r,\n        uint8 shift\n    ) internal pure returns (GatewayRequest memory) {\n        return r.push(shift).addByte(GatewayOP.SHIFT_LEFT);\n    }\n    function shr(\n        GatewayRequest memory r,\n        uint8 shift\n    ) internal pure returns (GatewayRequest memory) {\n        return r.push(shift).addByte(GatewayOP.SHIFT_RIGHT);\n    }\n    function eq(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.EQ);\n    }\n    function lt(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.LT);\n    }\n    function gt(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.addByte(GatewayOP.GT);\n    }\n    function neq(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.eq().isZero();\n    }\n    function lte(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.gt().isZero();\n    }\n    function gte(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.lt().isZero();\n    }\n    function dup2(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.dup(1).dup(1);\n    }\n    function min(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.dup2().gt().addByte(GatewayOP.SWAP).pop();\n    }\n    function max(\n        GatewayRequest memory r\n    ) internal pure returns (GatewayRequest memory) {\n        return r.dup2().lt().addByte(GatewayOP.SWAP).pop();\n    }\n}\n"
    },
    "@unruggable/gateways/contracts/GatewayFetchTarget.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {GatewayRequest} from './GatewayRequest.sol';\nimport {IGatewayVerifier} from './IGatewayVerifier.sol';\nimport {IGatewayProtocol} from './IGatewayProtocol.sol';\n\nerror OffchainLookup(\n    address from,\n    string[] urls,\n    bytes request,\n    bytes4 callback,\n    bytes carry\n);\n\nabstract contract GatewayFetchTarget {\n    struct Session {\n        IGatewayVerifier verifier;\n        bytes context;\n        GatewayRequest req;\n        bytes4 callback;\n        bytes carry;\n    }\n\n    function fetch(\n        IGatewayVerifier verifier,\n        GatewayRequest memory req,\n        bytes4 callback\n    ) internal view {\n        fetch(verifier, req, callback, '', new string[](0));\n    }\n\n    function fetch(\n        IGatewayVerifier verifier,\n        GatewayRequest memory req,\n        bytes4 callback,\n        bytes memory carry,\n        string[] memory urls\n    ) internal view {\n        bytes memory context = verifier.getLatestContext();\n        if (urls.length == 0) urls = verifier.gatewayURLs();\n        revert OffchainLookup(\n            address(this),\n            urls,\n            abi.encodeCall(IGatewayProtocol.proveRequest, (context, req)),\n            this.fetchCallback.selector,\n            abi.encode(Session(verifier, context, req, callback, carry))\n        );\n    }\n\n    function fetchCallback(\n        bytes calldata response,\n        bytes calldata carry\n    ) external view {\n        Session memory ses = abi.decode(carry, (Session));\n        (bytes[] memory values, uint8 exitCode) = ses.verifier.getStorageValues(\n            ses.context,\n            ses.req,\n            response\n        );\n        (bool ok, bytes memory ret) = address(this).staticcall(\n            abi.encodeWithSelector(ses.callback, values, exitCode, ses.carry)\n        );\n        if (ok) {\n            assembly {\n                return(add(ret, 32), mload(ret))\n            }\n        } else {\n            assembly {\n                revert(add(ret, 32), mload(ret))\n            }\n        }\n    }\n}\n"
    },
    "@unruggable/gateways/contracts/GatewayRequest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nstruct GatewayRequest {\n    bytes ops;\n}\n\nlibrary EvalFlag {\n    uint8 constant STOP_ON_SUCCESS = 1 << 0;\n    uint8 constant STOP_ON_FAILURE = 1 << 1;\n    uint8 constant ACQUIRE_STATE = 1 << 2;\n    uint8 constant KEEP_ARGS = 1 << 3;\n}\n\nlibrary GatewayOP {\n    uint8 constant PUSH_0 = 0;\n    uint8 constant PUSH_1 = 1;\n    uint8 constant PUSH_2 = 2;\n    uint8 constant PUSH_3 = 3;\n    uint8 constant PUSH_4 = 4;\n    uint8 constant PUSH_5 = 5;\n    uint8 constant PUSH_6 = 6;\n    uint8 constant PUSH_7 = 7;\n    uint8 constant PUSH_8 = 8;\n    uint8 constant PUSH_9 = 9;\n    uint8 constant PUSH_10 = 10;\n    uint8 constant PUSH_11 = 11;\n    uint8 constant PUSH_12 = 12;\n    uint8 constant PUSH_13 = 13;\n    uint8 constant PUSH_14 = 14;\n    uint8 constant PUSH_15 = 15;\n    uint8 constant PUSH_16 = 16;\n    uint8 constant PUSH_17 = 17;\n    uint8 constant PUSH_18 = 18;\n    uint8 constant PUSH_19 = 19;\n    uint8 constant PUSH_20 = 20;\n    uint8 constant PUSH_21 = 21;\n    uint8 constant PUSH_22 = 22;\n    uint8 constant PUSH_23 = 23;\n    uint8 constant PUSH_24 = 24;\n    uint8 constant PUSH_25 = 25;\n    uint8 constant PUSH_26 = 26;\n    uint8 constant PUSH_27 = 27;\n    uint8 constant PUSH_28 = 28;\n    uint8 constant PUSH_29 = 29;\n    uint8 constant PUSH_30 = 30;\n    uint8 constant PUSH_31 = 31;\n    uint8 constant PUSH_32 = 32;\n\n    uint8 constant GET_SLOT = 33;\n    uint8 constant GET_TARGET = 34;\n    uint8 constant STACK_SIZE = 35;\n\tuint8 constant IS_CONTRACT = 36;\n\n    uint8 constant PUSH_BYTES = 40;\n    uint8 constant PUSH_STACK = 41;\n    uint8 constant PUSH_OUTPUT = 42;\n\n    uint8 constant SET_TARGET = 50;\n    uint8 constant SET_OUTPUT = 51;\n    uint8 constant EVAL_LOOP = 52;\n    uint8 constant EVAL = 53;\n    uint8 constant ASSERT = 54;\n\n    uint8 constant READ_SLOT = 60;\n    uint8 constant READ_BYTES = 61;\n    uint8 constant READ_ARRAY = 62;\n    uint8 constant READ_HASHED_BYTES = 63;\n    uint8 constant READ_SLOTS = 64;\n\n    uint8 constant SET_SLOT = 70;\n    uint8 constant ADD_SLOT = 71;\n    uint8 constant FOLLOW = 72;\n\n    uint8 constant DUP = 80;\n    uint8 constant POP = 81;\n    uint8 constant SWAP = 82;\n\n    uint8 constant KECCAK = 90;\n    uint8 constant CONCAT = 91;\n    uint8 constant SLICE = 92;\n    uint8 constant LENGTH = 93;\n\n    uint8 constant PLUS = 100;\n    uint8 constant TIMES = 101;\n    uint8 constant DIVIDE = 102;\n    uint8 constant MOD = 103;\n\tuint8 constant POW = 104;\n\n    uint8 constant AND = 110;\n    uint8 constant OR = 111;\n    uint8 constant XOR = 112;\n    uint8 constant SHIFT_LEFT = 113;\n    uint8 constant SHIFT_RIGHT = 114;\n    uint8 constant NOT = 115;\n\n    uint8 constant IS_ZERO = 120;\n    uint8 constant EQ = 121;\n    uint8 constant LT = 122;\n    uint8 constant GT = 123;\n\n    uint8 constant DEBUG = 255;\n}\n"
    },
    "@unruggable/gateways/contracts/IGatewayProtocol.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {GatewayRequest} from './GatewayRequest.sol';\n\ninterface IGatewayProtocol {\n    function proveRequest(\n        bytes memory context,\n        GatewayRequest memory req\n    ) external pure returns (bytes memory);\n}\n"
    },
    "@unruggable/gateways/contracts/IGatewayVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {GatewayRequest} from './GatewayRequest.sol';\n\nerror CommitTooOld(uint256 latest, uint256 got, uint256 window);\nerror CommitTooNew(uint256 latest, uint256 got);\n\ninterface IGatewayVerifier {\n    function getLatestContext() external view returns (bytes memory);\n    function gatewayURLs() external view returns (string[] memory);\n\n    function getStorageValues(\n        bytes memory context,\n        GatewayRequest memory req,\n        bytes memory proof\n    ) external view returns (bytes[] memory values, uint8 exitCode);\n}\n"
    },
    "contracts/ccipRead/CCIPBatcher.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {IBatchGateway} from \"./IBatchGateway.sol\";\nimport {CCIPReader, EIP3668, OffchainLookup} from \"./CCIPReader.sol\";\n\nabstract contract CCIPBatcher is CCIPReader {\n    /// @notice The batch gateway supplied an incorrect number of responses.\n    /// @dev Error selector: `0x4a5c31ea`\n    error InvalidBatchGatewayResponse();\n\n    uint256 constant FLAG_OFFCHAIN = 1 << 0; // the lookup reverted `OffchainLookup`\n    uint256 constant FLAG_CALL_ERROR = 1 << 1; // the initial call or callback reverted\n    uint256 constant FLAG_BATCH_ERROR = 1 << 2; // `OffchainLookup` failed on the batch gateway\n    uint256 constant FLAG_EMPTY_RESPONSE = 1 << 3; // the initial call or callback returned `0x`\n    uint256 constant FLAG_EIP140_BEFORE = 1 << 4; // does not have revert op code\n    uint256 constant FLAG_EIP140_AFTER = 1 << 5; // has revert op code\n    uint256 constant FLAG_DONE = 1 << 6; // the lookup has finished processing (private)\n\n    uint256 constant FLAGS_ANY_ERROR =\n        FLAG_CALL_ERROR | FLAG_BATCH_ERROR | FLAG_EMPTY_RESPONSE;\n    uint256 constant FLAGS_ANY_EIP140 = FLAG_EIP140_BEFORE | FLAG_EIP140_AFTER;\n\n    /// @dev An independent `OffchainLookup` session.\n    struct Lookup {\n        address target; // contract to call\n        bytes call; // initial calldata\n        bytes data; // response or error\n        uint256 flags; // see: FLAG_*\n    }\n\n    /// @dev A batch gateway session.\n    struct Batch {\n        Lookup[] lookups;\n        string[] gateways;\n    }\n\n    /// @dev Create a batch for a single target with multiple calls.\n    /// @param target The target contract.\n    /// @param calls The list of calldata.\n    /// @param gateways The batch gateway URLs.\n    function createBatch(\n        address target,\n        bytes[] memory calls,\n        string[] memory gateways\n    ) internal pure returns (Batch memory) {\n        Lookup[] memory lookups = new Lookup[](calls.length);\n        for (uint256 i; i < calls.length; ++i) {\n            Lookup memory lu = lookups[i];\n            lu.target = target;\n            lu.call = calls[i];\n        }\n        return Batch(lookups, gateways);\n    }\n\n    /// @dev Use `ccipRead()` to call this function with a batch.\n    ///      The callback response will be `abi.encode(batch)`.\n    function ccipBatch(\n        Batch memory batch\n    ) external view returns (Batch memory) {\n        for (uint256 i; i < batch.lookups.length; ++i) {\n            Lookup memory lu = batch.lookups[i];\n            if ((lu.flags & FLAGS_ANY_EIP140) == 0) {\n                uint256 flags = detectEIP140(lu.target)\n                    ? FLAG_EIP140_AFTER\n                    : FLAG_EIP140_BEFORE;\n                for (uint256 j = i; j < batch.lookups.length; ++j) {\n                    if (batch.lookups[j].target == lu.target) {\n                        batch.lookups[j].flags |= flags;\n                    }\n                }\n            }\n            bool unsafe = (lu.flags & FLAG_EIP140_AFTER) == 0;\n            (bool ok, bytes memory v) = safeCall(!unsafe, lu.target, lu.call);\n            if (!ok && bytes4(v) == OffchainLookup.selector) {\n                lu.flags |= FLAG_OFFCHAIN;\n            } else {\n                lu.flags |= FLAG_DONE;\n                if (unsafe && v.length == 0) {\n                    // unsafe contracts appear the same for throw and unimplemented fallback\n                    // decision: interpret like an unimplemented function selector response\n                } else if (!ok) {\n                    lu.flags |= FLAG_CALL_ERROR;\n                }\n                if (v.length == 0) {\n                    lu.flags |= FLAG_EMPTY_RESPONSE;\n                }\n            }\n            lu.data = v;\n        }\n        _revertBatchGateway(batch); // reverts if any offchain\n        return batch;\n    }\n\n    /// @dev Check if the batch is \"done\".  If not, revert `OffchainLookup` for batch gateway.\n    function _revertBatchGateway(Batch memory batch) internal view {\n        IBatchGateway.Request[] memory requests = new IBatchGateway.Request[](\n            batch.lookups.length\n        );\n        uint256 count;\n        for (uint256 i; i < batch.lookups.length; ++i) {\n            Lookup memory lu = batch.lookups[i];\n            if ((lu.flags & FLAG_DONE) == 0) {\n                EIP3668.Params memory p = decodeOffchainLookup(lu.data);\n                requests[count++] = IBatchGateway.Request(\n                    p.sender,\n                    p.urls,\n                    p.callData\n                );\n            }\n        }\n        if (count > 0) {\n            assembly {\n                mstore(requests, count) // truncate to number of offchain requests\n            }\n            revert OffchainLookup(\n                address(this),\n                batch.gateways,\n                abi.encodeCall(IBatchGateway.query, (requests)),\n                this.ccipBatchCallback.selector,\n                abi.encode(batch)\n            );\n        }\n    }\n\n    /// @dev CCIP-Read callback for `ccipBatch()`.\n    ///      Updates `batch` using the batch gateway response. Reverts again if not \"done\".\n    /// @param response The response from the batch gateway.\n    /// @param extraData The contextual data passed from `ccipBatch()`.\n    /// @return batch The batch where every lookup is \"done\".\n    function ccipBatchCallback(\n        bytes calldata response,\n        bytes calldata extraData\n    ) external view returns (Batch memory batch) {\n        (bool[] memory failures, bytes[] memory responses) = abi.decode(\n            response,\n            (bool[], bytes[])\n        );\n        if (failures.length != responses.length) {\n            revert InvalidBatchGatewayResponse();\n        }\n        batch = abi.decode(extraData, (Batch));\n        uint256 expected;\n        for (uint256 i; i < batch.lookups.length; ++i) {\n            Lookup memory lu = batch.lookups[i];\n            if ((lu.flags & FLAG_DONE) == 0) {\n                if (expected < responses.length) {\n                    bytes memory v = responses[expected];\n                    if (failures[expected]) {\n                        lu.flags |= FLAG_DONE | FLAG_BATCH_ERROR;\n                    } else {\n                        EIP3668.Params memory p = decodeOffchainLookup(lu.data);\n                        bool ok;\n                        // assumption: unsafe contracts don't revert OffchainLookup()\n                        (ok, v) = p.sender.staticcall(\n                            abi.encodeWithSelector(\n                                p.callbackFunction,\n                                v,\n                                p.extraData\n                            )\n                        );\n                        if (ok || bytes4(v) != OffchainLookup.selector) {\n                            lu.flags |= FLAG_DONE;\n                            // decision: promote empty response from the callback => call error\n                            // ie. the initial function was implemented but the callback was not\n                            // this can be detected via FLAG_OFFCHAIN\n                            if (!ok || v.length == 0) {\n                                lu.flags |= FLAG_CALL_ERROR;\n                            }\n                            if (v.length == 0) {\n                                lu.flags |= FLAG_EMPTY_RESPONSE;\n                            }\n                        }\n                    }\n                    lu.data = v;\n                }\n                ++expected;\n            }\n        }\n        if (expected != responses.length) {\n            revert InvalidBatchGatewayResponse();\n        }\n        _revertBatchGateway(batch);\n    }\n}\n"
    },
    "contracts/ccipRead/CCIPReader.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n/// @author Modified from https://github.com/unruggable-labs/CCIPReader.sol/blob/341576fe7ff2b6e0c93fc08f37740cf6439f5873/contracts/CCIPReader.sol\n\n/// MIT License\n/// Portions Copyright (c) 2025 Unruggable\n/// Portions Copyright (c) 2025 ENS Labs Ltd\n\n/// @dev Instructions:\n/// 1. inherit this contract\n/// 2. call `ccipRead()` similar to `staticcall()`\n/// 3. do not put logic after this invocation\n/// 4. implement all response logic in callback\n/// 5. ensure that return type of calling function == callback function\n\nimport {EIP3668, OffchainLookup} from \"./EIP3668.sol\";\nimport {BytesUtils} from \"../utils/BytesUtils.sol\";\n\ncontract CCIPReader {\n    /// @dev Default unsafe call gas (sufficient for legacy ENS resolver profiles).\n    uint256 constant DEFAULT_UNSAFE_CALL_GAS = 50000;\n\n    /// @dev Special-purpose value for identity callback: `f(x) = x`.\n    bytes4 constant IDENTITY_FUNCTION = bytes4(0);\n\n    /// @dev The gas limit for calling functions on unsafe contracts.\n    uint256 immutable unsafeCallGas;\n\n    constructor(uint256 _unsafeCallGas) {\n        unsafeCallGas = _unsafeCallGas;\n    }\n\n    /// @dev A recursive CCIP-Read session.\n    struct Context {\n        address target;\n        bytes4 callbackFunction;\n        bytes extraData;\n        bytes4 successCallbackFunction;\n        bytes4 failureCallbackFunction;\n        bytes myExtraData;\n    }\n\n    /// @dev Same as `ccipRead()` but the callback function is the identity.\n    function ccipRead(address target, bytes memory call) internal view {\n        ccipRead(target, call, IDENTITY_FUNCTION, IDENTITY_FUNCTION, \"\");\n    }\n\n    /// @dev Performs a CCIP-Read and handles internal recursion.\n    ///      Reverts `OffchainLookup` if necessary.\n    ///      Use `IDENTITY_FUNCTION` as the callback function selector for return/revert behavior.\n    /// @param target The contract address.\n    /// @param call The calldata to `staticcall()` on `target`.\n    /// @param successCallbackFunction The function selector of callback on success.\n    /// @param failureCallbackFunction The function selector of callback on failure.\n    /// @param extraData The contextual data relayed to callback function.\n    function ccipRead(\n        address target,\n        bytes memory call,\n        bytes4 successCallbackFunction,\n        bytes4 failureCallbackFunction,\n        bytes memory extraData\n    ) internal view {\n        // We call the intended function that **could** revert with an `OffchainLookup`\n        // We destructure the response into an execution status bool and our return bytes\n        (bool ok, bytes memory v) = safeCall(\n            detectEIP140(target),\n            target,\n            call\n        );\n        // IF the function reverted with an `OffchainLookup`\n        if (!ok && bytes4(v) == OffchainLookup.selector) {\n            // We decode the response error into a tuple\n            // tuples allow flexibility noting stack too deep constraints\n            EIP3668.Params memory p = decodeOffchainLookup(v);\n            if (p.sender == target) {\n                // We then wrap the error data in an `OffchainLookup` sent/'owned' by this contract\n                revert OffchainLookup(\n                    address(this),\n                    p.urls,\n                    p.callData,\n                    this.ccipReadCallback.selector,\n                    abi.encode(\n                        Context(\n                            target,\n                            p.callbackFunction,\n                            p.extraData,\n                            successCallbackFunction,\n                            failureCallbackFunction,\n                            extraData\n                        )\n                    )\n                );\n            }\n        }\n        // IF we have gotten here, the 'real' target does not revert with an `OffchainLookup` error\n        // figure out what callback to call\n        bytes4 callbackFunction = ok\n            ? successCallbackFunction\n            : failureCallbackFunction;\n        if (callbackFunction != IDENTITY_FUNCTION) {\n            // The exit point of this architecture is OUR callback in the 'real'\n            // We pass through the response to that callback\n            (ok, v) = address(this).staticcall(\n                abi.encodeWithSelector(callbackFunction, v, extraData)\n            );\n        }\n        // OR the call to the 'real' target reverts with a different error selector\n        // OR the call to OUR callback reverts with ANY error selector\n        if (ok) {\n            assembly {\n                return(add(v, 32), mload(v))\n            }\n        } else {\n            assembly {\n                revert(add(v, 32), mload(v))\n            }\n        }\n    }\n\n    /// @dev CCIP-Read callback for `ccipRead()`.\n    /// @param response The response from offchain.\n    /// @param extraData The contextual data passed from `ccipRead()`.\n    /// @dev The return type of this function is polymorphic depending on the caller.\n    function ccipReadCallback(\n        bytes memory response,\n        bytes memory extraData\n    ) external view {\n        Context memory ctx = abi.decode(extraData, (Context));\n        // Since the callback can revert too (but has the same return structure)\n        // We can reuse the calling infrastructure to call the callback\n        ccipRead(\n            ctx.target,\n            abi.encodeWithSelector(\n                ctx.callbackFunction,\n                response,\n                ctx.extraData\n            ),\n            ctx.successCallbackFunction,\n            ctx.failureCallbackFunction,\n            ctx.myExtraData\n        );\n    }\n\n    /// @dev Decode `OffchainLookup` error data into a struct.\n    /// @param v The error data of the revert.\n    /// @return p The decoded `OffchainLookup` params.\n    function decodeOffchainLookup(\n        bytes memory v\n    ) internal pure returns (EIP3668.Params memory p) {\n        p = EIP3668.decode(BytesUtils.substring(v, 4, v.length - 4));\n    }\n\n    /// @dev Determine if `target` uses `revert()` instead of `invalid()`.\n    //       Assumption: only newer contracts revert `OffchainLookup`.\n    /// @param target The contract to test.\n    /// @return safe True if safe to call.\n    function detectEIP140(address target) internal view returns (bool safe) {\n        if (target == address(this)) return true;\n        // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-140.md\n        assembly {\n            let G := 5000\n            let g := gas()\n            pop(staticcall(G, target, 0, 0, 0, 0))\n            safe := lt(sub(g, gas()), G)\n        }\n    }\n\n    /// @dev Same as `staticcall()` but prevents OOG when not `safe`.\n    function safeCall(\n        bool safe,\n        address target,\n        bytes memory call\n    ) internal view returns (bool ok, bytes memory v) {\n        (ok, v) = target.staticcall{gas: safe ? gasleft() : unsafeCallGas}(\n            call\n        );\n    }\n}\n"
    },
    "contracts/ccipRead/EIP3668.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @dev https://eips.ethereum.org/EIPS/eip-3668\n/// Error selector: `0x556f1830`\nerror OffchainLookup(\n    address sender,\n    string[] urls,\n    bytes callData,\n    bytes4 callbackFunction,\n    bytes extraData\n);\n\n/// @dev Simple library for decoding `OffchainLookup` error data.\n/// Avoids \"stack too deep\" issues as the natural decoding consumes 5 variables.\nlibrary EIP3668 {\n    /// @dev Struct with members matching `OffchainLookup`.\n    struct Params {\n        address sender;\n        string[] urls;\n        bytes callData;\n        bytes4 callbackFunction;\n        bytes extraData;\n    }\n\n    /// @dev Decode an `OffchainLookup` into a struct from the data after the error selector.\n    function decode(bytes memory v) internal pure returns (Params memory p) {\n        (p.sender, p.urls, p.callData, p.callbackFunction, p.extraData) = abi\n            .decode(v, (address, string[], bytes, bytes4, bytes));\n    }\n}\n"
    },
    "contracts/ccipRead/GatewayProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {IGatewayProvider} from \"./IGatewayProvider.sol\";\n\ncontract GatewayProvider is Ownable, IGatewayProvider {\n    string[] _urls;\n\n    constructor(string[] memory urls) {\n        _urls = urls;\n    }\n\n    /// @inheritdoc IGatewayProvider\n    function gateways() external view returns (string[] memory) {\n        return _urls;\n    }\n\n    /// @notice Set the gateways.\n    /// @param urls The gateway URLs.\n    function setGateways(string[] memory urls) external onlyOwner {\n        _urls = urls;\n    }\n}\n"
    },
    "contracts/ccipRead/IBatchGateway.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Interface for Batch Gateway Offchain Lookup Protocol.\n///         https://docs.ens.domains/ensip/21/\n/// @dev Interface selector: `0xa780bab6`\ninterface IBatchGateway {\n    /// @notice An HTTP error occurred.\n    /// @dev Error selector: `0x01800152`\n    error HttpError(uint16 status, string message);\n\n    /// @dev Information extracted from an `OffchainLookup` revert.\n    struct Request {\n        address sender;\n        string[] urls;\n        bytes data;\n    }\n\n    /// @notice Perform multiple `OffchainLookup` in parallel.\n    ///         Callers should enable EIP-3668.\n    /// @param requests The array of requests to lookup in parallel.\n    /// @return failures The failure status of the corresponding request.\n    /// @return responses The response or error data of the corresponding request.\n    function query(\n        Request[] memory requests\n    ) external view returns (bool[] memory failures, bytes[] memory responses);\n}\n"
    },
    "contracts/ccipRead/IGatewayProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Interface for shared gateway URLs.\n/// @dev Interface selector: `0x093a86d3`\ninterface IGatewayProvider {\n    /// @notice Get the gateways.\n    /// @return The gateway URLs.\n    function gateways() external view returns (string[] memory);\n}\n"
    },
    "contracts/dnsregistrar/DNSClaimChecker.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../dnssec-oracle/DNSSEC.sol\";\nimport \"../dnssec-oracle/RRUtils.sol\";\nimport \"../utils/BytesUtils.sol\";\nimport \"../utils/HexUtils.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\nlibrary DNSClaimChecker {\n    using BytesUtils for bytes;\n    using HexUtils for bytes;\n    using RRUtils for *;\n    using Buffer for Buffer.buffer;\n\n    uint16 constant CLASS_INET = 1;\n    uint16 constant TYPE_TXT = 16;\n\n    function getOwnerAddress(\n        bytes memory name,\n        bytes memory data\n    ) internal pure returns (address, bool) {\n        // Add \"_ens.\" to the front of the name.\n        Buffer.buffer memory buf;\n        buf.init(name.length + 5);\n        buf.append(\"\\x04_ens\");\n        buf.append(name);\n\n        for (\n            RRUtils.RRIterator memory iter = data.iterateRRs(0);\n            !iter.done();\n            iter.next()\n        ) {\n            if (iter.name().compareNames(buf.buf) != 0) continue;\n            bool found;\n            address addr;\n            (addr, found) = parseRR(data, iter.rdataOffset, iter.nextOffset);\n            if (found) {\n                return (addr, true);\n            }\n        }\n\n        return (address(0x0), false);\n    }\n\n    function parseRR(\n        bytes memory rdata,\n        uint256 idx,\n        uint256 endIdx\n    ) internal pure returns (address, bool) {\n        while (idx < endIdx) {\n            uint256 len = rdata.readUint8(idx);\n            idx += 1;\n\n            bool found;\n            address addr;\n            (addr, found) = parseString(rdata, idx, len);\n\n            if (found) return (addr, true);\n            idx += len;\n        }\n\n        return (address(0x0), false);\n    }\n\n    function parseString(\n        bytes memory str,\n        uint256 idx,\n        uint256 len\n    ) internal pure returns (address, bool) {\n        // TODO: More robust parsing that handles whitespace and multiple key/value pairs\n        if (str.readUint32(idx) != 0x613d3078) return (address(0x0), false); // 0x613d3078 == 'a=0x'\n        return str.hexToAddress(idx + 4, idx + len);\n    }\n}\n"
    },
    "contracts/dnsregistrar/DNSRegistrar.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\nimport \"../dnssec-oracle/DNSSEC.sol\";\nimport \"../dnssec-oracle/RRUtils.sol\";\nimport \"../registry/ENSRegistry.sol\";\nimport \"../root/Root.sol\";\nimport \"../resolvers/profiles/AddrResolver.sol\";\nimport \"../utils/BytesUtils.sol\";\nimport \"./DNSClaimChecker.sol\";\nimport \"./PublicSuffixList.sol\";\nimport \"./IDNSRegistrar.sol\";\n\n/// @dev An ENS registrar that allows the owner of a DNS name to claim the\n///      corresponding name in ENS.\ncontract DNSRegistrar is IDNSRegistrar, IERC165 {\n    using BytesUtils for bytes;\n    using Buffer for Buffer.buffer;\n    using RRUtils for *;\n\n    ENS public immutable ens;\n    DNSSEC public immutable oracle;\n    PublicSuffixList public suffixes;\n    address public immutable previousRegistrar;\n    address public immutable resolver;\n    // A mapping of the most recent signatures seen for each claimed domain.\n    mapping(bytes32 => uint32) public inceptions;\n\n    error NoOwnerRecordFound();\n    error PermissionDenied(address caller, address owner);\n    error PreconditionNotMet();\n    error StaleProof();\n    error InvalidPublicSuffix(bytes name);\n\n    struct OwnerRecord {\n        bytes name;\n        address owner;\n        address resolver;\n        uint64 ttl;\n    }\n\n    event Claim(\n        bytes32 indexed node,\n        address indexed owner,\n        bytes dnsname,\n        uint32 inception\n    );\n    event NewPublicSuffixList(address suffixes);\n\n    constructor(\n        address _previousRegistrar,\n        address _resolver,\n        DNSSEC _dnssec,\n        PublicSuffixList _suffixes,\n        ENS _ens\n    ) {\n        previousRegistrar = _previousRegistrar;\n        resolver = _resolver;\n        oracle = _dnssec;\n        suffixes = _suffixes;\n        emit NewPublicSuffixList(address(suffixes));\n        ens = _ens;\n    }\n\n    /// @dev This contract's owner-only functions can be invoked by the owner of the ENS root.\n    modifier onlyOwner() {\n        Root root = Root(ens.owner(bytes32(0)));\n        address owner = root.owner();\n        require(msg.sender == owner);\n        _;\n    }\n\n    function setPublicSuffixList(PublicSuffixList _suffixes) public onlyOwner {\n        suffixes = _suffixes;\n        emit NewPublicSuffixList(address(suffixes));\n    }\n\n    /// @dev Submits proofs to the DNSSEC oracle, then claims a name using those proofs.\n    /// @param name The name to claim, in DNS wire format.\n    /// @param input A chain of signed DNS RRSETs ending with a text record.\n    function proveAndClaim(\n        bytes memory name,\n        DNSSEC.RRSetWithSignature[] memory input\n    ) public override {\n        (bytes32 rootNode, bytes32 labelHash, address addr) = _claim(\n            name,\n            input\n        );\n        ens.setSubnodeOwner(rootNode, labelHash, addr);\n    }\n\n    function proveAndClaimWithResolver(\n        bytes memory name,\n        DNSSEC.RRSetWithSignature[] memory input,\n        address resolver,\n        address addr\n    ) public override {\n        (bytes32 rootNode, bytes32 labelHash, address owner) = _claim(\n            name,\n            input\n        );\n        if (msg.sender != owner) {\n            revert PermissionDenied(msg.sender, owner);\n        }\n        ens.setSubnodeRecord(rootNode, labelHash, owner, resolver, 0);\n        if (addr != address(0)) {\n            if (resolver == address(0)) {\n                revert PreconditionNotMet();\n            }\n            bytes32 node = keccak256(abi.encodePacked(rootNode, labelHash));\n            // Set the resolver record\n            AddrResolver(resolver).setAddr(node, addr);\n        }\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) external pure override returns (bool) {\n        return\n            interfaceID == type(IERC165).interfaceId ||\n            interfaceID == type(IDNSRegistrar).interfaceId;\n    }\n\n    function _claim(\n        bytes memory name,\n        DNSSEC.RRSetWithSignature[] memory input\n    ) internal returns (bytes32 parentNode, bytes32 labelHash, address addr) {\n        (bytes memory data, uint32 inception) = oracle.verifyRRSet(input);\n\n        // Get the first label\n        uint256 labelLen = name.readUint8(0);\n        labelHash = name.keccak(1, labelLen);\n\n        bytes memory parentName = name.substring(\n            labelLen + 1,\n            name.length - labelLen - 1\n        );\n\n        // Make sure the parent name is enabled\n        parentNode = enableNode(parentName);\n\n        bytes32 node = keccak256(abi.encodePacked(parentNode, labelHash));\n        if (!RRUtils.serialNumberGte(inception, inceptions[node])) {\n            revert StaleProof();\n        }\n        inceptions[node] = inception;\n\n        bool found;\n        (addr, found) = DNSClaimChecker.getOwnerAddress(name, data);\n        if (!found) {\n            revert NoOwnerRecordFound();\n        }\n\n        emit Claim(node, addr, name, inception);\n    }\n\n    function enableNode(bytes memory domain) public returns (bytes32 node) {\n        // Name must be in the public suffix list.\n        if (!suffixes.isPublicSuffix(domain)) {\n            revert InvalidPublicSuffix(domain);\n        }\n        return _enableNode(domain, 0);\n    }\n\n    function _enableNode(\n        bytes memory domain,\n        uint256 offset\n    ) internal returns (bytes32 node) {\n        uint256 len = domain.readUint8(offset);\n        if (len == 0) {\n            return bytes32(0);\n        }\n\n        bytes32 parentNode = _enableNode(domain, offset + len + 1);\n        bytes32 label = domain.keccak(offset + 1, len);\n        node = keccak256(abi.encodePacked(parentNode, label));\n        address owner = ens.owner(node);\n        if (owner == address(0) || owner == previousRegistrar) {\n            if (parentNode == bytes32(0)) {\n                Root root = Root(ens.owner(bytes32(0)));\n                root.setSubnodeOwner(label, address(this));\n                ens.setResolver(node, resolver);\n            } else {\n                ens.setSubnodeRecord(\n                    parentNode,\n                    label,\n                    address(this),\n                    resolver,\n                    0\n                );\n            }\n        } else if (owner != address(this)) {\n            revert PreconditionNotMet();\n        }\n        return node;\n    }\n}\n"
    },
    "contracts/dnsregistrar/IDNSRegistrar.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../dnssec-oracle/DNSSEC.sol\";\n\ninterface IDNSRegistrar {\n    function proveAndClaim(\n        bytes memory name,\n        DNSSEC.RRSetWithSignature[] memory input\n    ) external;\n\n    function proveAndClaimWithResolver(\n        bytes memory name,\n        DNSSEC.RRSetWithSignature[] memory input,\n        address resolver,\n        address addr\n    ) external;\n}\n"
    },
    "contracts/dnsregistrar/mocks/DummyDnsRegistrarDNSSEC.sol": {
      "content": "pragma solidity ^0.8.4;\n\ncontract DummyDNSSEC {\n    uint16 expectedType;\n    bytes expectedName;\n    uint32 inception;\n    uint64 inserted;\n    bytes20 hash;\n\n    function setData(\n        uint16 _expectedType,\n        bytes memory _expectedName,\n        uint32 _inception,\n        uint64 _inserted,\n        bytes memory _proof\n    ) public {\n        expectedType = _expectedType;\n        expectedName = _expectedName;\n        inception = _inception;\n        inserted = _inserted;\n        if (_proof.length != 0) {\n            hash = bytes20(keccak256(_proof));\n        }\n    }\n\n    function rrdata(\n        uint16 dnstype,\n        bytes memory name\n    ) public view returns (uint32, uint64, bytes20) {\n        require(dnstype == expectedType);\n        require(keccak256(name) == keccak256(expectedName));\n        return (inception, inserted, hash);\n    }\n}\n"
    },
    "contracts/dnsregistrar/mocks/DummyExtendedDNSSECResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../../resolvers/profiles/IExtendedDNSResolver.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\ncontract DummyExtendedDNSSECResolver is IExtendedDNSResolver, IERC165 {\n    function supportsInterface(\n        bytes4 interfaceId\n    ) external pure override returns (bool) {\n        return interfaceId == type(IExtendedDNSResolver).interfaceId;\n    }\n\n    function resolve(\n        bytes memory /* name */,\n        bytes memory /* data */,\n        bytes memory context\n    ) external view override returns (bytes memory) {\n        return abi.encode(context);\n    }\n}\n"
    },
    "contracts/dnsregistrar/mocks/DummyLegacyTextResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../../resolvers/profiles/ITextResolver.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\ncontract DummyLegacyTextResolver is ITextResolver, IERC165 {\n    function supportsInterface(\n        bytes4 interfaceId\n    ) external pure override returns (bool) {\n        return interfaceId == type(ITextResolver).interfaceId;\n    }\n\n    function text(\n        bytes32 /* node */,\n        string calldata key\n    ) external view override returns (string memory) {\n        return key;\n    }\n}\n"
    },
    "contracts/dnsregistrar/mocks/DummyNonCCIPAwareResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"../OffchainDNSResolver.sol\";\nimport \"../../resolvers/profiles/IExtendedResolver.sol\";\n\ncontract DummyNonCCIPAwareResolver is IExtendedResolver, ERC165 {\n    OffchainDNSResolver dnsResolver;\n\n    constructor(OffchainDNSResolver _dnsResolver) {\n        dnsResolver = _dnsResolver;\n    }\n\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override returns (bool) {\n        return\n            interfaceId == type(IExtendedResolver).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    function resolve(\n        bytes calldata /* name */,\n        bytes calldata data\n    ) external view returns (bytes memory) {\n        string[] memory urls = new string[](1);\n        urls[0] = \"https://example.com/\";\n        revert OffchainLookup(\n            address(dnsResolver),\n            urls,\n            data,\n            OffchainDNSResolver.resolveCallback.selector,\n            data\n        );\n    }\n}\n"
    },
    "contracts/dnsregistrar/OffchainDNSResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {ERC165, IERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nimport \"../../contracts/resolvers/profiles/IAddrResolver.sol\";\nimport \"../../contracts/resolvers/profiles/IExtendedResolver.sol\";\nimport \"../../contracts/resolvers/profiles/IExtendedDNSResolver.sol\";\nimport \"../dnssec-oracle/DNSSEC.sol\";\nimport \"../dnssec-oracle/RRUtils.sol\";\nimport \"../registry/ENSRegistry.sol\";\nimport \"../utils/HexUtils.sol\";\nimport \"../utils/BytesUtils.sol\";\nimport {IDNSGateway} from \"../dnssec-oracle/IDNSGateway.sol\";\nimport {OffchainLookup} from \"../ccipRead/EIP3668.sol\";\nimport {LowLevelCallUtils} from \"../utils/LowLevelCallUtils.sol\";\n\nerror InvalidOperation();\n\nuint16 constant CLASS_INET = 1;\nuint16 constant TYPE_TXT = 16;\n\ncontract OffchainDNSResolver is IExtendedResolver, IERC165 {\n    using RRUtils for *;\n    using Address for address;\n    using BytesUtils for bytes;\n    using HexUtils for bytes;\n\n    ENS public immutable ens;\n    DNSSEC public immutable oracle;\n    string public gatewayURL;\n\n    error CouldNotResolve(bytes name);\n\n    constructor(ENS _ens, DNSSEC _oracle, string memory _gatewayURL) {\n        ens = _ens;\n        oracle = _oracle;\n        gatewayURL = _gatewayURL;\n    }\n\n    function supportsInterface(\n        bytes4 interfaceId\n    ) external pure override returns (bool) {\n        return interfaceId == type(IExtendedResolver).interfaceId;\n    }\n\n    function resolve(\n        bytes calldata name,\n        bytes calldata data\n    ) external view returns (bytes memory) {\n        revertWithDefaultOffchainLookup(name, data);\n    }\n\n    function resolveCallback(\n        bytes calldata response,\n        bytes calldata extraData\n    ) external view returns (bytes memory) {\n        (bytes memory name, bytes memory query, bytes4 selector) = abi.decode(\n            extraData,\n            (bytes, bytes, bytes4)\n        );\n\n        if (selector != bytes4(0)) {\n            (bytes memory targetData, address targetResolver) = abi.decode(\n                query,\n                (bytes, address)\n            );\n            return\n                callWithOffchainLookupPropagation(\n                    targetResolver,\n                    name,\n                    query,\n                    abi.encodeWithSelector(\n                        selector,\n                        response,\n                        abi.encode(targetData, address(this))\n                    )\n                );\n        }\n\n        DNSSEC.RRSetWithSignature[] memory rrsets = abi.decode(\n            response,\n            (DNSSEC.RRSetWithSignature[])\n        );\n\n        (bytes memory data, ) = oracle.verifyRRSet(rrsets);\n        for (\n            RRUtils.RRIterator memory iter = data.iterateRRs(0);\n            !iter.done();\n            iter.next()\n        ) {\n            // Ignore records with wrong name, type, or class\n            bytes memory rrname = RRUtils.readName(iter.data, iter.offset);\n            if (\n                !rrname.equals(name) ||\n                iter.class != CLASS_INET ||\n                iter.dnstype != TYPE_TXT\n            ) {\n                continue;\n            }\n\n            // Look for a valid ENS-DNS TXT record\n            (address dnsresolver, bytes memory context) = parseRR(\n                iter.data,\n                iter.rdataOffset,\n                iter.nextOffset\n            );\n\n            // If we found a valid record, try to resolve it\n            if (dnsresolver != address(0)) {\n                if (\n                    IERC165(dnsresolver).supportsInterface(\n                        IExtendedDNSResolver.resolve.selector\n                    )\n                ) {\n                    return\n                        callWithOffchainLookupPropagation(\n                            dnsresolver,\n                            name,\n                            query,\n                            abi.encodeCall(\n                                IExtendedDNSResolver.resolve,\n                                (name, query, context)\n                            )\n                        );\n                } else if (\n                    IERC165(dnsresolver).supportsInterface(\n                        IExtendedResolver.resolve.selector\n                    )\n                ) {\n                    return\n                        callWithOffchainLookupPropagation(\n                            dnsresolver,\n                            name,\n                            query,\n                            abi.encodeCall(\n                                IExtendedResolver.resolve,\n                                (name, query)\n                            )\n                        );\n                } else {\n                    (bool ok, bytes memory ret) = address(dnsresolver)\n                        .staticcall(query);\n                    if (ok) {\n                        return ret;\n                    } else {\n                        revert CouldNotResolve(name);\n                    }\n                }\n            }\n        }\n\n        // No valid records; revert.\n        revert CouldNotResolve(name);\n    }\n\n    function parseRR(\n        bytes memory data,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal view returns (address, bytes memory) {\n        bytes memory txt = readTXT(data, idx, lastIdx);\n\n        // Must start with the magic word\n        if (txt.length < 5 || !txt.equals(0, \"ENS1 \", 0, 5)) {\n            return (address(0), \"\");\n        }\n\n        // Parse the name or address\n        uint256 lastTxtIdx = txt.find(5, txt.length - 5, \" \");\n        if (lastTxtIdx > txt.length) {\n            address dnsResolver = parseAndResolve(txt, 5, txt.length);\n            return (dnsResolver, \"\");\n        } else {\n            address dnsResolver = parseAndResolve(txt, 5, lastTxtIdx);\n            return (\n                dnsResolver,\n                txt.substring(lastTxtIdx + 1, txt.length - lastTxtIdx - 1)\n            );\n        }\n    }\n\n    function readTXT(\n        bytes memory data,\n        uint256 startIdx,\n        uint256 lastIdx\n    ) internal pure returns (bytes memory) {\n        // TODO: Concatenate multiple text fields\n        uint256 fieldLength = data.readUint8(startIdx);\n        assert(startIdx + fieldLength < lastIdx);\n        return data.substring(startIdx + 1, fieldLength);\n    }\n\n    function parseAndResolve(\n        bytes memory nameOrAddress,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal view returns (address) {\n        if (nameOrAddress[idx] == \"0\" && nameOrAddress[idx + 1] == \"x\") {\n            (address ret, bool valid) = nameOrAddress.hexToAddress(\n                idx + 2,\n                lastIdx\n            );\n            if (valid) {\n                return ret;\n            }\n        }\n        return resolveName(nameOrAddress, idx, lastIdx);\n    }\n\n    function resolveName(\n        bytes memory name,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal view returns (address) {\n        bytes32 node = textNamehash(name, idx, lastIdx);\n        address resolver = ens.resolver(node);\n        if (resolver == address(0)) {\n            return address(0);\n        }\n        return IAddrResolver(resolver).addr(node);\n    }\n\n    /// @dev Namehash function that operates on dot-separated names (not dns-encoded names)\n    /// @param name Name to hash\n    /// @param idx Index to start at\n    /// @param lastIdx Index to end at\n    function textNamehash(\n        bytes memory name,\n        uint256 idx,\n        uint256 lastIdx\n    ) internal view returns (bytes32) {\n        uint256 separator = name.find(idx, name.length - idx, bytes1(\".\"));\n        bytes32 parentNode = bytes32(0);\n        if (separator < lastIdx) {\n            parentNode = textNamehash(name, separator + 1, lastIdx);\n        } else {\n            separator = lastIdx;\n        }\n        return\n            keccak256(\n                abi.encodePacked(parentNode, name.keccak(idx, separator - idx))\n            );\n    }\n\n    function callWithOffchainLookupPropagation(\n        address target,\n        bytes memory name,\n        bytes memory innerdata,\n        bytes memory data\n    ) internal view returns (bytes memory) {\n        if (!target.isContract()) {\n            revertWithDefaultOffchainLookup(name, innerdata);\n        }\n\n        bool result = LowLevelCallUtils.functionStaticCall(\n            address(target),\n            data\n        );\n        uint256 size = LowLevelCallUtils.returnDataSize();\n        if (result) {\n            bytes memory returnData = LowLevelCallUtils.readReturnData(0, size);\n            return abi.decode(returnData, (bytes));\n        }\n        // Failure\n        if (size >= 4) {\n            bytes memory errorId = LowLevelCallUtils.readReturnData(0, 4);\n            if (bytes4(errorId) == OffchainLookup.selector) {\n                // Offchain lookup. Decode the revert message and create our own that nests it.\n                bytes memory revertData = LowLevelCallUtils.readReturnData(\n                    4,\n                    size - 4\n                );\n                handleOffchainLookupError(revertData, target, name);\n            }\n        }\n        LowLevelCallUtils.propagateRevert();\n    }\n\n    function revertWithDefaultOffchainLookup(\n        bytes memory name,\n        bytes memory data\n    ) internal view {\n        string[] memory urls = new string[](1);\n        urls[0] = gatewayURL;\n\n        revert OffchainLookup(\n            address(this),\n            urls,\n            abi.encodeCall(IDNSGateway.resolve, (name, TYPE_TXT)),\n            OffchainDNSResolver.resolveCallback.selector,\n            abi.encode(name, data, bytes4(0))\n        );\n    }\n\n    function handleOffchainLookupError(\n        bytes memory returnData,\n        address target,\n        bytes memory name\n    ) internal view {\n        (\n            address sender,\n            string[] memory urls,\n            bytes memory callData,\n            bytes4 innerCallbackFunction,\n            bytes memory extraData\n        ) = abi.decode(returnData, (address, string[], bytes, bytes4, bytes));\n\n        if (sender != target) {\n            revert InvalidOperation();\n        }\n\n        revert OffchainLookup(\n            address(this),\n            urls,\n            callData,\n            OffchainDNSResolver.resolveCallback.selector,\n            abi.encode(name, extraData, innerCallbackFunction)\n        );\n    }\n}\n"
    },
    "contracts/dnsregistrar/PublicSuffixList.sol": {
      "content": "pragma solidity ^0.8.4;\n\ninterface PublicSuffixList {\n    function isPublicSuffix(bytes calldata name) external view returns (bool);\n}\n"
    },
    "contracts/dnsregistrar/SimplePublicSuffixList.sol": {
      "content": "pragma solidity ^0.8.4;\npragma experimental ABIEncoderV2;\n\nimport \"../root/Ownable.sol\";\nimport \"./PublicSuffixList.sol\";\n\ncontract SimplePublicSuffixList is PublicSuffixList, Ownable {\n    mapping(bytes => bool) suffixes;\n\n    event SuffixAdded(bytes suffix);\n\n    function addPublicSuffixes(bytes[] memory names) public onlyOwner {\n        for (uint256 i = 0; i < names.length; i++) {\n            suffixes[names[i]] = true;\n            emit SuffixAdded(names[i]);\n        }\n    }\n\n    function isPublicSuffix(\n        bytes calldata name\n    ) external view override returns (bool) {\n        return suffixes[name];\n    }\n}\n"
    },
    "contracts/dnsregistrar/TLDPublicSuffixList.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport \"../utils/BytesUtils.sol\";\nimport \"./PublicSuffixList.sol\";\n\n/// @dev A public suffix list that treats all TLDs as public suffixes.\ncontract TLDPublicSuffixList is PublicSuffixList {\n    using BytesUtils for bytes;\n\n    function isPublicSuffix(\n        bytes calldata name\n    ) external view override returns (bool) {\n        uint256 labellen = name.readUint8(0);\n        return labellen > 0 && name.readUint8(labellen + 1) == 0;\n    }\n}\n"
    },
    "contracts/dnssec-oracle/algorithms/Algorithm.sol": {
      "content": "pragma solidity ^0.8.4;\n\n/// @dev An interface for contracts implementing a DNSSEC (signing) algorithm.\ninterface Algorithm {\n    /// @dev Verifies a signature.\n    /// @param key The public key to verify with.\n    /// @param data The signed data to verify.\n    /// @param signature The signature to verify.\n    /// @return True iff the signature is valid.\n    function verify(\n        bytes calldata key,\n        bytes calldata data,\n        bytes calldata signature\n    ) external view virtual returns (bool);\n}\n"
    },
    "contracts/dnssec-oracle/algorithms/DummyAlgorithm.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport \"./Algorithm.sol\";\n\n/// @dev Implements a dummy DNSSEC (signing) algorithm that approves all\n///      signatures, for testing.\ncontract DummyAlgorithm is Algorithm {\n    function verify(\n        bytes calldata,\n        bytes calldata,\n        bytes calldata\n    ) external view override returns (bool) {\n        return true;\n    }\n}\n"
    },
    "contracts/dnssec-oracle/algorithms/EllipticCurve.sol": {
      "content": "pragma solidity ^0.8.4;\n\n/// @title   EllipticCurve\n/// @author  Tilman Drerup;\n/// @notice  Implements elliptic curve math; Parametrized for SECP256R1.\n///          Includes components of code by Andreas Olofsson, Alexander Vlasov\n///          (https://github.com/BANKEX/CurveArithmetics), and Avi Asayag\n///          (https://github.com/orbs-network/elliptic-curve-solidity)\n///          Source: https://github.com/tdrerup/elliptic-curve-solidity\n/// @dev     NOTE: To disambiguate public keys when verifying signatures, activate\n///          condition 'rs[1] > lowSmax' in validateSignature().\ncontract EllipticCurve {\n    // Set parameters for curve.\n    uint256 constant a =\n        0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC;\n    uint256 constant b =\n        0x5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B;\n    uint256 constant gx =\n        0x6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296;\n    uint256 constant gy =\n        0x4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5;\n    uint256 constant p =\n        0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF;\n    uint256 constant n =\n        0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551;\n\n    uint256 constant lowSmax =\n        0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0;\n\n    /// @dev Inverse of u in the field of modulo m.\n    function inverseMod(uint256 u, uint256 m) internal pure returns (uint256) {\n        unchecked {\n            if (u == 0 || u == m || m == 0) return 0;\n            if (u > m) u = u % m;\n\n            int256 t1;\n            int256 t2 = 1;\n            uint256 r1 = m;\n            uint256 r2 = u;\n            uint256 q;\n\n            while (r2 != 0) {\n                q = r1 / r2;\n                (t1, t2, r1, r2) = (t2, t1 - int256(q) * t2, r2, r1 - q * r2);\n            }\n\n            if (t1 < 0) return (m - uint256(-t1));\n\n            return uint256(t1);\n        }\n    }\n\n    /// @dev Transform affine coordinates into projective coordinates.\n    function toProjectivePoint(\n        uint256 x0,\n        uint256 y0\n    ) internal pure returns (uint256[3] memory P) {\n        P[2] = addmod(0, 1, p);\n        P[0] = mulmod(x0, P[2], p);\n        P[1] = mulmod(y0, P[2], p);\n    }\n\n    /// @dev Add two points in affine coordinates and return projective point.\n    function addAndReturnProjectivePoint(\n        uint256 x1,\n        uint256 y1,\n        uint256 x2,\n        uint256 y2\n    ) internal pure returns (uint256[3] memory P) {\n        uint256 x;\n        uint256 y;\n        (x, y) = add(x1, y1, x2, y2);\n        P = toProjectivePoint(x, y);\n    }\n\n    /// @dev Transform from projective to affine coordinates.\n    function toAffinePoint(\n        uint256 x0,\n        uint256 y0,\n        uint256 z0\n    ) internal pure returns (uint256 x1, uint256 y1) {\n        uint256 z0Inv;\n        z0Inv = inverseMod(z0, p);\n        x1 = mulmod(x0, z0Inv, p);\n        y1 = mulmod(y0, z0Inv, p);\n    }\n\n    /// @dev Return the zero curve in projective coordinates.\n    function zeroProj()\n        internal\n        pure\n        returns (uint256 x, uint256 y, uint256 z)\n    {\n        return (0, 1, 0);\n    }\n\n    /// @dev Return the zero curve in affine coordinates.\n    function zeroAffine() internal pure returns (uint256 x, uint256 y) {\n        return (0, 0);\n    }\n\n    /// @dev Check if the curve is the zero curve.\n    function isZeroCurve(\n        uint256 x0,\n        uint256 y0\n    ) internal pure returns (bool isZero) {\n        if (x0 == 0 && y0 == 0) {\n            return true;\n        }\n        return false;\n    }\n\n    /// @dev Check if a point in affine coordinates is on the curve.\n    function isOnCurve(uint256 x, uint256 y) internal pure returns (bool) {\n        if (0 == x || x == p || 0 == y || y == p) {\n            return false;\n        }\n\n        uint256 LHS = mulmod(y, y, p); // y^2\n        uint256 RHS = mulmod(mulmod(x, x, p), x, p); // x^3\n\n        if (a != 0) {\n            RHS = addmod(RHS, mulmod(x, a, p), p); // x^3 + a*x\n        }\n        if (b != 0) {\n            RHS = addmod(RHS, b, p); // x^3 + a*x + b\n        }\n\n        return LHS == RHS;\n    }\n\n    /// @dev Double an elliptic curve point in projective coordinates. See\n    /// https://www.nayuki.io/page/elliptic-curve-point-addition-in-projective-coordinates\n    function twiceProj(\n        uint256 x0,\n        uint256 y0,\n        uint256 z0\n    ) internal pure returns (uint256 x1, uint256 y1, uint256 z1) {\n        uint256 t;\n        uint256 u;\n        uint256 v;\n        uint256 w;\n\n        if (isZeroCurve(x0, y0)) {\n            return zeroProj();\n        }\n\n        u = mulmod(y0, z0, p);\n        u = mulmod(u, 2, p);\n\n        v = mulmod(u, x0, p);\n        v = mulmod(v, y0, p);\n        v = mulmod(v, 2, p);\n\n        x0 = mulmod(x0, x0, p);\n        t = mulmod(x0, 3, p);\n\n        z0 = mulmod(z0, z0, p);\n        z0 = mulmod(z0, a, p);\n        t = addmod(t, z0, p);\n\n        w = mulmod(t, t, p);\n        x0 = mulmod(2, v, p);\n        w = addmod(w, p - x0, p);\n\n        x0 = addmod(v, p - w, p);\n        x0 = mulmod(t, x0, p);\n        y0 = mulmod(y0, u, p);\n        y0 = mulmod(y0, y0, p);\n        y0 = mulmod(2, y0, p);\n        y1 = addmod(x0, p - y0, p);\n\n        x1 = mulmod(u, w, p);\n\n        z1 = mulmod(u, u, p);\n        z1 = mulmod(z1, u, p);\n    }\n\n    /// @dev Add two elliptic curve points in projective coordinates. See\n    /// https://www.nayuki.io/page/elliptic-curve-point-addition-in-projective-coordinates\n    function addProj(\n        uint256 x0,\n        uint256 y0,\n        uint256 z0,\n        uint256 x1,\n        uint256 y1,\n        uint256 z1\n    ) internal pure returns (uint256 x2, uint256 y2, uint256 z2) {\n        uint256 t0;\n        uint256 t1;\n        uint256 u0;\n        uint256 u1;\n\n        if (isZeroCurve(x0, y0)) {\n            return (x1, y1, z1);\n        } else if (isZeroCurve(x1, y1)) {\n            return (x0, y0, z0);\n        }\n\n        t0 = mulmod(y0, z1, p);\n        t1 = mulmod(y1, z0, p);\n\n        u0 = mulmod(x0, z1, p);\n        u1 = mulmod(x1, z0, p);\n\n        if (u0 == u1) {\n            if (t0 == t1) {\n                return twiceProj(x0, y0, z0);\n            } else {\n                return zeroProj();\n            }\n        }\n\n        (x2, y2, z2) = addProj2(mulmod(z0, z1, p), u0, u1, t1, t0);\n    }\n\n    /// @dev Helper function that splits addProj to avoid too many local variables.\n    function addProj2(\n        uint256 v,\n        uint256 u0,\n        uint256 u1,\n        uint256 t1,\n        uint256 t0\n    ) private pure returns (uint256 x2, uint256 y2, uint256 z2) {\n        uint256 u;\n        uint256 u2;\n        uint256 u3;\n        uint256 w;\n        uint256 t;\n\n        t = addmod(t0, p - t1, p);\n        u = addmod(u0, p - u1, p);\n        u2 = mulmod(u, u, p);\n\n        w = mulmod(t, t, p);\n        w = mulmod(w, v, p);\n        u1 = addmod(u1, u0, p);\n        u1 = mulmod(u1, u2, p);\n        w = addmod(w, p - u1, p);\n\n        x2 = mulmod(u, w, p);\n\n        u3 = mulmod(u2, u, p);\n        u0 = mulmod(u0, u2, p);\n        u0 = addmod(u0, p - w, p);\n        t = mulmod(t, u0, p);\n        t0 = mulmod(t0, u3, p);\n\n        y2 = addmod(t, p - t0, p);\n\n        z2 = mulmod(u3, v, p);\n    }\n\n    /// @dev Add two elliptic curve points in affine coordinates.\n    function add(\n        uint256 x0,\n        uint256 y0,\n        uint256 x1,\n        uint256 y1\n    ) internal pure returns (uint256, uint256) {\n        uint256 z0;\n\n        (x0, y0, z0) = addProj(x0, y0, 1, x1, y1, 1);\n\n        return toAffinePoint(x0, y0, z0);\n    }\n\n    /// @dev Double an elliptic curve point in affine coordinates.\n    function twice(\n        uint256 x0,\n        uint256 y0\n    ) internal pure returns (uint256, uint256) {\n        uint256 z0;\n\n        (x0, y0, z0) = twiceProj(x0, y0, 1);\n\n        return toAffinePoint(x0, y0, z0);\n    }\n\n    /// @dev Multiply an elliptic curve point by a 2 power base (i.e., (2^exp)*P)).\n    function multiplyPowerBase2(\n        uint256 x0,\n        uint256 y0,\n        uint256 exp\n    ) internal pure returns (uint256, uint256) {\n        uint256 base2X = x0;\n        uint256 base2Y = y0;\n        uint256 base2Z = 1;\n\n        for (uint256 i = 0; i < exp; i++) {\n            (base2X, base2Y, base2Z) = twiceProj(base2X, base2Y, base2Z);\n        }\n\n        return toAffinePoint(base2X, base2Y, base2Z);\n    }\n\n    /// @dev Multiply an elliptic curve point by a scalar.\n    function multiplyScalar(\n        uint256 x0,\n        uint256 y0,\n        uint256 scalar\n    ) internal pure returns (uint256 x1, uint256 y1) {\n        if (scalar == 0) {\n            return zeroAffine();\n        } else if (scalar == 1) {\n            return (x0, y0);\n        } else if (scalar == 2) {\n            return twice(x0, y0);\n        }\n\n        uint256 base2X = x0;\n        uint256 base2Y = y0;\n        uint256 base2Z = 1;\n        uint256 z1 = 1;\n        x1 = x0;\n        y1 = y0;\n\n        if (scalar % 2 == 0) {\n            x1 = y1 = 0;\n        }\n\n        scalar = scalar >> 1;\n\n        while (scalar > 0) {\n            (base2X, base2Y, base2Z) = twiceProj(base2X, base2Y, base2Z);\n\n            if (scalar % 2 == 1) {\n                (x1, y1, z1) = addProj(base2X, base2Y, base2Z, x1, y1, z1);\n            }\n\n            scalar = scalar >> 1;\n        }\n\n        return toAffinePoint(x1, y1, z1);\n    }\n\n    /// @dev Multiply the curve's generator point by a scalar.\n    function multipleGeneratorByScalar(\n        uint256 scalar\n    ) internal pure returns (uint256, uint256) {\n        return multiplyScalar(gx, gy, scalar);\n    }\n\n    /// @dev Validate combination of message, signature, and public key.\n    function validateSignature(\n        bytes32 message,\n        uint256[2] memory rs,\n        uint256[2] memory Q\n    ) internal pure returns (bool) {\n        // To disambiguate between public key solutions, include comment below.\n        if (rs[0] == 0 || rs[0] >= n || rs[1] == 0) {\n            // || rs[1] > lowSmax)\n            return false;\n        }\n        if (!isOnCurve(Q[0], Q[1])) {\n            return false;\n        }\n\n        uint256 x1;\n        uint256 x2;\n        uint256 y1;\n        uint256 y2;\n\n        uint256 sInv = inverseMod(rs[1], n);\n        (x1, y1) = multiplyScalar(gx, gy, mulmod(uint256(message), sInv, n));\n        (x2, y2) = multiplyScalar(Q[0], Q[1], mulmod(rs[0], sInv, n));\n        uint256[3] memory P = addAndReturnProjectivePoint(x1, y1, x2, y2);\n\n        if (P[2] == 0) {\n            return false;\n        }\n\n        uint256 Px = inverseMod(P[2], p);\n        Px = mulmod(P[0], mulmod(Px, Px, p), p);\n\n        return Px % n == rs[0];\n    }\n}\n"
    },
    "contracts/dnssec-oracle/algorithms/ModexpPrecompile.sol": {
      "content": "pragma solidity ^0.8.4;\n\nlibrary ModexpPrecompile {\n    /// @dev Computes (base ^ exponent) % modulus over big numbers.\n    function modexp(\n        bytes memory base,\n        bytes memory exponent,\n        bytes memory modulus\n    ) internal view returns (bool success, bytes memory output) {\n        bytes memory input = abi.encodePacked(\n            uint256(base.length),\n            uint256(exponent.length),\n            uint256(modulus.length),\n            base,\n            exponent,\n            modulus\n        );\n\n        output = new bytes(modulus.length);\n\n        assembly {\n            success := staticcall(\n                gas(),\n                5,\n                add(input, 32),\n                mload(input),\n                add(output, 32),\n                mload(modulus)\n            )\n        }\n    }\n}\n"
    },
    "contracts/dnssec-oracle/algorithms/P256SHA256Algorithm.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport \"./Algorithm.sol\";\nimport \"./EllipticCurve.sol\";\nimport \"../../utils/BytesUtils.sol\";\n\ncontract P256SHA256Algorithm is Algorithm, EllipticCurve {\n    using BytesUtils for *;\n\n    /// @dev Verifies a signature.\n    /// @param key The public key to verify with.\n    /// @param data The signed data to verify.\n    /// @param signature The signature to verify.\n    /// @return True iff the signature is valid.\n    function verify(\n        bytes calldata key,\n        bytes calldata data,\n        bytes calldata signature\n    ) external view override returns (bool) {\n        return\n            validateSignature(\n                sha256(data),\n                parseSignature(signature),\n                parseKey(key)\n            );\n    }\n\n    function parseSignature(\n        bytes memory data\n    ) internal pure returns (uint256[2] memory) {\n        require(data.length == 64, \"Invalid p256 signature length\");\n        return [uint256(data.readBytes32(0)), uint256(data.readBytes32(32))];\n    }\n\n    function parseKey(\n        bytes memory data\n    ) internal pure returns (uint256[2] memory) {\n        require(data.length == 68, \"Invalid p256 key length\");\n        return [uint256(data.readBytes32(4)), uint256(data.readBytes32(36))];\n    }\n}\n"
    },
    "contracts/dnssec-oracle/algorithms/RSASHA1Algorithm.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport \"./Algorithm.sol\";\nimport \"./RSAVerify.sol\";\nimport \"../../utils/BytesUtils.sol\";\nimport \"@ensdomains/solsha1/contracts/SHA1.sol\";\n\n/// @dev Implements the DNSSEC RSASHA1 algorithm.\ncontract RSASHA1Algorithm is Algorithm {\n    using BytesUtils for *;\n\n    function verify(\n        bytes calldata key,\n        bytes calldata data,\n        bytes calldata sig\n    ) external view override returns (bool) {\n        bytes memory exponent;\n        bytes memory modulus;\n\n        uint16 exponentLen = uint16(key.readUint8(4));\n        if (exponentLen != 0) {\n            exponent = key.substring(5, exponentLen);\n            modulus = key.substring(\n                exponentLen + 5,\n                key.length - exponentLen - 5\n            );\n        } else {\n            exponentLen = key.readUint16(5);\n            exponent = key.substring(7, exponentLen);\n            modulus = key.substring(\n                exponentLen + 7,\n                key.length - exponentLen - 7\n            );\n        }\n\n        // Recover the message from the signature\n        bool ok;\n        bytes memory result;\n        (ok, result) = RSAVerify.rsarecover(modulus, exponent, sig);\n\n        // Verify it ends with the hash of our data\n        return ok && SHA1.sha1(data) == result.readBytes20(result.length - 20);\n    }\n}\n"
    },
    "contracts/dnssec-oracle/algorithms/RSASHA256Algorithm.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport \"./Algorithm.sol\";\nimport \"./RSAVerify.sol\";\nimport \"../../utils/BytesUtils.sol\";\n\n/// @dev Implements the DNSSEC RSASHA256 algorithm.\ncontract RSASHA256Algorithm is Algorithm {\n    using BytesUtils for *;\n\n    function verify(\n        bytes calldata key,\n        bytes calldata data,\n        bytes calldata sig\n    ) external view override returns (bool) {\n        bytes memory exponent;\n        bytes memory modulus;\n\n        uint16 exponentLen = uint16(key.readUint8(4));\n        if (exponentLen != 0) {\n            exponent = key.substring(5, exponentLen);\n            modulus = key.substring(\n                exponentLen + 5,\n                key.length - exponentLen - 5\n            );\n        } else {\n            exponentLen = key.readUint16(5);\n            exponent = key.substring(7, exponentLen);\n            modulus = key.substring(\n                exponentLen + 7,\n                key.length - exponentLen - 7\n            );\n        }\n\n        // Recover the message from the signature\n        bool ok;\n        bytes memory result;\n        (ok, result) = RSAVerify.rsarecover(modulus, exponent, sig);\n\n        // Verify it ends with the hash of our data\n        return ok && sha256(data) == result.readBytes32(result.length - 32);\n    }\n}\n"
    },
    "contracts/dnssec-oracle/algorithms/RSAVerify.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport \"./ModexpPrecompile.sol\";\nimport \"../../utils/BytesUtils.sol\";\n\nlibrary RSAVerify {\n    /// @dev Recovers the input data from an RSA signature, returning the result in S.\n    /// @param N The RSA public modulus.\n    /// @param E The RSA public exponent.\n    /// @param S The signature to recover.\n    /// @return True if the recovery succeeded.\n    function rsarecover(\n        bytes memory N,\n        bytes memory E,\n        bytes memory S\n    ) internal view returns (bool, bytes memory) {\n        return ModexpPrecompile.modexp(S, E, N);\n    }\n}\n"
    },
    "contracts/dnssec-oracle/digests/Digest.sol": {
      "content": "pragma solidity ^0.8.4;\n\n/// @dev An interface for contracts implementing a DNSSEC digest.\ninterface Digest {\n    /// @dev Verifies a cryptographic hash.\n    /// @param data The data to hash.\n    /// @param hash The hash to compare to.\n    /// @return True iff the hashed data matches the provided hash value.\n    function verify(\n        bytes calldata data,\n        bytes calldata hash\n    ) external pure virtual returns (bool);\n}\n"
    },
    "contracts/dnssec-oracle/digests/DummyDigest.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport \"./Digest.sol\";\n\n/// @dev Implements a dummy DNSSEC digest that approves all hashes, for testing.\ncontract DummyDigest is Digest {\n    function verify(\n        bytes calldata,\n        bytes calldata\n    ) external pure override returns (bool) {\n        return true;\n    }\n}\n"
    },
    "contracts/dnssec-oracle/digests/SHA1Digest.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport \"./Digest.sol\";\nimport \"../../utils/BytesUtils.sol\";\nimport \"@ensdomains/solsha1/contracts/SHA1.sol\";\n\n/// @dev Implements the DNSSEC SHA1 digest.\ncontract SHA1Digest is Digest {\n    using BytesUtils for *;\n\n    function verify(\n        bytes calldata data,\n        bytes calldata hash\n    ) external pure override returns (bool) {\n        require(hash.length == 20, \"Invalid sha1 hash length\");\n        bytes32 expected = hash.readBytes20(0);\n        bytes20 computed = SHA1.sha1(data);\n        return expected == computed;\n    }\n}\n"
    },
    "contracts/dnssec-oracle/digests/SHA256Digest.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport \"./Digest.sol\";\nimport \"../../utils/BytesUtils.sol\";\n\n/// @dev Implements the DNSSEC SHA256 digest.\ncontract SHA256Digest is Digest {\n    using BytesUtils for *;\n\n    function verify(\n        bytes calldata data,\n        bytes calldata hash\n    ) external pure override returns (bool) {\n        require(hash.length == 32, \"Invalid sha256 hash length\");\n        return sha256(data) == hash.readBytes32(0);\n    }\n}\n"
    },
    "contracts/dnssec-oracle/DNSSEC.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\npragma experimental ABIEncoderV2;\n\nabstract contract DNSSEC {\n    bytes public anchors;\n\n    struct RRSetWithSignature {\n        bytes rrset;\n        bytes sig;\n    }\n\n    event AlgorithmUpdated(uint8 id, address addr);\n    event DigestUpdated(uint8 id, address addr);\n\n    function verifyRRSet(\n        RRSetWithSignature[] memory input\n    ) external view virtual returns (bytes memory rrs, uint32 inception);\n\n    function verifyRRSet(\n        RRSetWithSignature[] memory input,\n        uint256 now\n    ) public view virtual returns (bytes memory rrs, uint32 inception);\n}\n"
    },
    "contracts/dnssec-oracle/DNSSECImpl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\npragma experimental ABIEncoderV2;\n\nimport \"./Owned.sol\";\nimport \"./RRUtils.sol\";\nimport \"./DNSSEC.sol\";\nimport \"./algorithms/Algorithm.sol\";\nimport \"./digests/Digest.sol\";\nimport \"../utils/BytesUtils.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\n/*\n * @dev An oracle contract that verifies and stores DNSSEC-validated DNS records.\n * @note This differs from the DNSSEC spec defined in RFC4034 and RFC4035 in some key regards:\n *       - NSEC & NSEC3 are not supported; only positive proofs are allowed.\n *       - Proofs involving wildcard names will not validate.\n *       - TTLs on records are ignored, as data is not stored persistently.\n *       - Canonical form of names is not checked; in ENS this is done on the frontend, so submitting\n *         proofs with non-canonical names will only result in registering unresolvable ENS names.\n */\ncontract DNSSECImpl is DNSSEC, Owned {\n    using Buffer for Buffer.buffer;\n    using BytesUtils for bytes;\n    using RRUtils for *;\n\n    uint16 constant DNSCLASS_IN = 1;\n\n    uint16 constant DNSTYPE_DS = 43;\n    uint16 constant DNSTYPE_DNSKEY = 48;\n\n    uint256 constant DNSKEY_FLAG_ZONEKEY = 0x100;\n\n    error InvalidLabelCount(bytes name, uint256 labelsExpected);\n    error SignatureNotValidYet(uint32 inception, uint32 now);\n    error SignatureExpired(uint32 expiration, uint32 now);\n    error InvalidClass(uint16 class);\n    error InvalidRRSet();\n    error SignatureTypeMismatch(uint16 rrsetType, uint16 sigType);\n    error InvalidSignerName(bytes rrsetName, bytes signerName);\n    error InvalidProofType(uint16 proofType);\n    error ProofNameMismatch(bytes signerName, bytes proofName);\n    error NoMatchingProof(bytes signerName);\n\n    mapping(uint8 => Algorithm) public algorithms;\n    mapping(uint8 => Digest) public digests;\n\n    /// @dev Constructor.\n    /// @param _anchors The binary format RR entries for the root DS records.\n    constructor(bytes memory _anchors) {\n        // Insert the 'trust anchors' - the key hashes that start the chain\n        // of trust for all other records.\n        anchors = _anchors;\n    }\n\n    /// @dev Sets the contract address for a signature verification algorithm.\n    ///      Callable only by the owner.\n    /// @param id The algorithm ID\n    /// @param algo The address of the algorithm contract.\n    function setAlgorithm(uint8 id, Algorithm algo) public owner_only {\n        algorithms[id] = algo;\n        emit AlgorithmUpdated(id, address(algo));\n    }\n\n    /// @dev Sets the contract address for a digest verification algorithm.\n    ///      Callable only by the owner.\n    /// @param id The digest ID\n    /// @param digest The address of the digest contract.\n    function setDigest(uint8 id, Digest digest) public owner_only {\n        digests[id] = digest;\n        emit DigestUpdated(id, address(digest));\n    }\n\n    /// @dev Takes a chain of signed DNS records, verifies them, and returns the data from the last record set in the chain.\n    ///      Reverts if the records do not form an unbroken chain of trust to the DNSSEC anchor records.\n    /// @param input A list of signed RRSets.\n    /// @return rrs The RRData from the last RRSet in the chain.\n    /// @return inception The inception time of the signed record set.\n    function verifyRRSet(\n        RRSetWithSignature[] memory input\n    )\n        external\n        view\n        virtual\n        override\n        returns (bytes memory rrs, uint32 inception)\n    {\n        return verifyRRSet(input, block.timestamp);\n    }\n\n    /// @dev Takes a chain of signed DNS records, verifies them, and returns the data from the last record set in the chain.\n    ///      Reverts if the records do not form an unbroken chain of trust to the DNSSEC anchor records.\n    /// @param input A list of signed RRSets.\n    /// @param now The Unix timestamp to validate the records at.\n    /// @return rrs The RRData from the last RRSet in the chain.\n    /// @return inception The inception time of the signed record set.\n    function verifyRRSet(\n        RRSetWithSignature[] memory input,\n        uint256 now\n    )\n        public\n        view\n        virtual\n        override\n        returns (bytes memory rrs, uint32 inception)\n    {\n        bytes memory proof = anchors;\n        for (uint256 i = 0; i < input.length; i++) {\n            RRUtils.SignedSet memory rrset = validateSignedSet(\n                input[i],\n                proof,\n                now\n            );\n            proof = rrset.data;\n            inception = rrset.inception;\n        }\n        return (proof, inception);\n    }\n\n    /// @dev Validates an RRSet against the already trusted RR provided in `proof`.\n    ///\n    /// @param input The signed RR set. This is in the format described in section\n    ///        5.3.2 of RFC4035: The RRDATA section from the RRSIG without the signature\n    ///        data, followed by a series of canonicalised RR records that the signature\n    ///        applies to.\n    /// @param proof The DNSKEY or DS to validate the signature against.\n    /// @param now The current timestamp.\n    function validateSignedSet(\n        RRSetWithSignature memory input,\n        bytes memory proof,\n        uint256 now\n    ) internal view returns (RRUtils.SignedSet memory rrset) {\n        rrset = input.rrset.readSignedSet();\n\n        // Do some basic checks on the RRs and extract the name\n        bytes memory name = validateRRs(rrset, rrset.typeCovered);\n        if (name.labelCount(0) != rrset.labels) {\n            revert InvalidLabelCount(name, rrset.labels);\n        }\n        rrset.name = name;\n\n        // All comparisons involving the Signature Expiration and\n        // Inception fields MUST use \"serial number arithmetic\", as\n        // defined in RFC 1982\n\n        // o  The validator's notion of the current time MUST be less than or\n        //    equal to the time listed in the RRSIG RR's Expiration field.\n        if (!RRUtils.serialNumberGte(rrset.expiration, uint32(now))) {\n            revert SignatureExpired(rrset.expiration, uint32(now));\n        }\n\n        // o  The validator's notion of the current time MUST be greater than or\n        //    equal to the time listed in the RRSIG RR's Inception field.\n        if (!RRUtils.serialNumberGte(uint32(now), rrset.inception)) {\n            revert SignatureNotValidYet(rrset.inception, uint32(now));\n        }\n\n        // Validate the signature\n        verifySignature(name, rrset, input, proof);\n\n        return rrset;\n    }\n\n    /// @dev Validates a set of RRs.\n    /// @param rrset The RR set.\n    /// @param typecovered The type covered by the RRSIG record.\n    function validateRRs(\n        RRUtils.SignedSet memory rrset,\n        uint16 typecovered\n    ) internal pure returns (bytes memory name) {\n        // Iterate over all the RRs\n        for (\n            RRUtils.RRIterator memory iter = rrset.rrs();\n            !iter.done();\n            iter.next()\n        ) {\n            // We only support class IN (Internet)\n            if (iter.class != DNSCLASS_IN) {\n                revert InvalidClass(iter.class);\n            }\n\n            if (name.length == 0) {\n                name = iter.name();\n            } else {\n                // Name must be the same on all RRs. We do things this way to avoid copying the name\n                // repeatedly.\n                if (\n                    name.length != iter.data.nameLength(iter.offset) ||\n                    !name.equals(0, iter.data, iter.offset, name.length)\n                ) {\n                    revert InvalidRRSet();\n                }\n            }\n\n            // o  The RRSIG RR's Type Covered field MUST equal the RRset's type.\n            if (iter.dnstype != typecovered) {\n                revert SignatureTypeMismatch(iter.dnstype, typecovered);\n            }\n        }\n    }\n\n    /// @dev Performs signature verification.\n    ///\n    /// Throws or reverts if unable to verify the record.\n    ///\n    /// @param name The name of the RRSIG record, in DNS label-sequence format.\n    /// @param data The original data to verify.\n    /// @param proof A DS or DNSKEY record that's already verified by the oracle.\n    function verifySignature(\n        bytes memory name,\n        RRUtils.SignedSet memory rrset,\n        RRSetWithSignature memory data,\n        bytes memory proof\n    ) internal view {\n        // o  The RRSIG RR's Signer's Name field MUST be the name of the zone\n        //    that contains the RRset.\n        if (!name.isSubdomainOf(rrset.signerName)) {\n            revert InvalidSignerName(name, rrset.signerName);\n        }\n\n        RRUtils.RRIterator memory proofRR = proof.iterateRRs(0);\n        // Check the proof\n        if (proofRR.dnstype == DNSTYPE_DS) {\n            verifyWithDS(rrset, data, proofRR);\n        } else if (proofRR.dnstype == DNSTYPE_DNSKEY) {\n            verifyWithKnownKey(rrset, data, proofRR);\n        } else {\n            revert InvalidProofType(proofRR.dnstype);\n        }\n    }\n\n    /// @dev Attempts to verify a signed RRSET against an already known public key.\n    /// @param rrset The signed set to verify.\n    /// @param data The original data the signed set was read from.\n    /// @param proof The serialized DS or DNSKEY record to use as proof.\n    function verifyWithKnownKey(\n        RRUtils.SignedSet memory rrset,\n        RRSetWithSignature memory data,\n        RRUtils.RRIterator memory proof\n    ) internal view {\n        // Check the DNSKEY's owner name matches the signer name on the RRSIG\n        for (; !proof.done(); proof.next()) {\n            bytes memory proofName = proof.name();\n            if (!proofName.equals(rrset.signerName)) {\n                revert ProofNameMismatch(rrset.signerName, proofName);\n            }\n\n            bytes memory keyrdata = proof.rdata();\n            RRUtils.DNSKEY memory dnskey = keyrdata.readDNSKEY(\n                0,\n                keyrdata.length\n            );\n            if (verifySignatureWithKey(dnskey, keyrdata, rrset, data)) {\n                return;\n            }\n        }\n        revert NoMatchingProof(rrset.signerName);\n    }\n\n    /// @dev Attempts to verify some data using a provided key and a signature.\n    /// @param dnskey The dns key record to verify the signature with.\n    /// @param rrset The signed RRSET being verified.\n    /// @param data The original data `rrset` was decoded from.\n    /// @return True iff the key verifies the signature.\n    function verifySignatureWithKey(\n        RRUtils.DNSKEY memory dnskey,\n        bytes memory keyrdata,\n        RRUtils.SignedSet memory rrset,\n        RRSetWithSignature memory data\n    ) internal view returns (bool) {\n        // TODO: Check key isn't expired, unless updating key itself\n\n        // The Protocol Field MUST have value 3 (RFC4034 2.1.2)\n        if (dnskey.protocol != 3) {\n            return false;\n        }\n\n        // o The RRSIG RR's Signer's Name, Algorithm, and Key Tag fields MUST\n        //   match the owner name, algorithm, and key tag for some DNSKEY RR in\n        //   the zone's apex DNSKEY RRset.\n        if (dnskey.algorithm != rrset.algorithm) {\n            return false;\n        }\n        uint16 computedkeytag = keyrdata.computeKeytag();\n        if (computedkeytag != rrset.keytag) {\n            return false;\n        }\n\n        // o The matching DNSKEY RR MUST be present in the zone's apex DNSKEY\n        //   RRset, and MUST have the Zone Flag bit (DNSKEY RDATA Flag bit 7)\n        //   set.\n        if (dnskey.flags & DNSKEY_FLAG_ZONEKEY == 0) {\n            return false;\n        }\n\n        Algorithm algorithm = algorithms[dnskey.algorithm];\n        if (address(algorithm) == address(0)) {\n            return false;\n        }\n        return algorithm.verify(keyrdata, data.rrset, data.sig);\n    }\n\n    /// @dev Attempts to verify a signed RRSET against an already known hash. This function assumes\n    ///      that the record\n    /// @param rrset The signed set to verify.\n    /// @param data The original data the signed set was read from.\n    /// @param proof The serialized DS or DNSKEY record to use as proof.\n    function verifyWithDS(\n        RRUtils.SignedSet memory rrset,\n        RRSetWithSignature memory data,\n        RRUtils.RRIterator memory proof\n    ) internal view {\n        uint256 proofOffset = proof.offset;\n        for (\n            RRUtils.RRIterator memory iter = rrset.rrs();\n            !iter.done();\n            iter.next()\n        ) {\n            if (iter.dnstype != DNSTYPE_DNSKEY) {\n                revert InvalidProofType(iter.dnstype);\n            }\n\n            bytes memory keyrdata = iter.rdata();\n            RRUtils.DNSKEY memory dnskey = keyrdata.readDNSKEY(\n                0,\n                keyrdata.length\n            );\n            if (verifySignatureWithKey(dnskey, keyrdata, rrset, data)) {\n                // It's self-signed - look for a DS record to verify it.\n                if (\n                    verifyKeyWithDS(rrset.signerName, proof, dnskey, keyrdata)\n                ) {\n                    return;\n                }\n                // Rewind proof iterator to the start for the next loop iteration.\n                proof.nextOffset = proofOffset;\n                proof.next();\n            }\n        }\n        revert NoMatchingProof(rrset.signerName);\n    }\n\n    /// @dev Attempts to verify a key using DS records.\n    /// @param keyname The DNS name of the key, in DNS label-sequence format.\n    /// @param dsrrs The DS records to use in verification.\n    /// @param dnskey The dnskey to verify.\n    /// @param keyrdata The RDATA section of the key.\n    /// @return True if a DS record verifies this key.\n    function verifyKeyWithDS(\n        bytes memory keyname,\n        RRUtils.RRIterator memory dsrrs,\n        RRUtils.DNSKEY memory dnskey,\n        bytes memory keyrdata\n    ) internal view returns (bool) {\n        uint16 keytag = keyrdata.computeKeytag();\n        for (; !dsrrs.done(); dsrrs.next()) {\n            bytes memory proofName = dsrrs.name();\n            if (!proofName.equals(keyname)) {\n                revert ProofNameMismatch(keyname, proofName);\n            }\n\n            RRUtils.DS memory ds = dsrrs.data.readDS(\n                dsrrs.rdataOffset,\n                dsrrs.nextOffset - dsrrs.rdataOffset\n            );\n            if (ds.keytag != keytag) {\n                continue;\n            }\n            if (ds.algorithm != dnskey.algorithm) {\n                continue;\n            }\n\n            Buffer.buffer memory buf;\n            buf.init(keyname.length + keyrdata.length);\n            buf.append(keyname);\n            buf.append(keyrdata);\n            if (verifyDSHash(ds.digestType, buf.buf, ds.digest)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /// @dev Attempts to verify a DS record's hash value against some data.\n    /// @param digesttype The digest ID from the DS record.\n    /// @param data The data to digest.\n    /// @param digest The digest data to check against.\n    /// @return True if the digest matches.\n    function verifyDSHash(\n        uint8 digesttype,\n        bytes memory data,\n        bytes memory digest\n    ) internal view returns (bool) {\n        if (address(digests[digesttype]) == address(0)) {\n            return false;\n        }\n        return digests[digesttype].verify(data, digest);\n    }\n}\n"
    },
    "contracts/dnssec-oracle/IDNSGateway.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {DNSSEC} from \"./DNSSEC.sol\";\n\n/// @notice Interface for the offchain DNSSEC oracle gateway.\n///         https://docs.ens.domains/ensip/17#dnssec-gateway-api\n/// @dev Interface selector: `0x31b137b9`\ninterface IDNSGateway {\n    /// @dev Fetch verifiable DNSSEC resource records of a specific type for a name.\n    /// @param name The DNS-encoded name.\n    /// @param qtype The DNS record query type according to RFC-1034.\n    /// @return The list of verifiable DNS resource records according to RFC-4035.\n    function resolve(\n        bytes memory name,\n        uint16 qtype\n    ) external returns (DNSSEC.RRSetWithSignature[] memory);\n}\n"
    },
    "contracts/dnssec-oracle/Owned.sol": {
      "content": "pragma solidity ^0.8.4;\n\n/// @dev Contract mixin for 'owned' contracts.\ncontract Owned {\n    address public owner;\n\n    modifier owner_only() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function setOwner(address newOwner) public owner_only {\n        owner = newOwner;\n    }\n}\n"
    },
    "contracts/dnssec-oracle/RRUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../utils/BytesUtils.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\n/// @dev RRUtils is a library that provides utilities for parsing DNS resource records.\nlibrary RRUtils {\n    using BytesUtils for *;\n    using Buffer for *;\n\n    /// @dev Returns the number of bytes in the DNS name at 'offset' in 'self'.\n    /// @param self The byte array to read a name from.\n    /// @param offset The offset to start reading at.\n    /// @return The length of the DNS name at 'offset', in bytes.\n    function nameLength(\n        bytes memory self,\n        uint256 offset\n    ) internal pure returns (uint256) {\n        uint256 idx = offset;\n        while (true) {\n            assert(idx < self.length);\n            uint256 labelLen = self.readUint8(idx);\n            idx += labelLen + 1;\n            if (labelLen == 0) {\n                break;\n            }\n        }\n        return idx - offset;\n    }\n\n    /// @dev Returns a DNS format name at the specified offset of self.\n    /// @param self The byte array to read a name from.\n    /// @param offset The offset to start reading at.\n    /// @return ret The name.\n    function readName(\n        bytes memory self,\n        uint256 offset\n    ) internal pure returns (bytes memory ret) {\n        uint256 len = nameLength(self, offset);\n        return self.substring(offset, len);\n    }\n\n    /// @dev Returns the number of labels in the DNS name at 'offset' in 'self'.\n    /// @param self The byte array to read a name from.\n    /// @param offset The offset to start reading at.\n    /// @return The number of labels in the DNS name at 'offset', in bytes.\n    function labelCount(\n        bytes memory self,\n        uint256 offset\n    ) internal pure returns (uint256) {\n        uint256 count = 0;\n        while (true) {\n            assert(offset < self.length);\n            uint256 labelLen = self.readUint8(offset);\n            offset += labelLen + 1;\n            if (labelLen == 0) {\n                break;\n            }\n            count += 1;\n        }\n        return count;\n    }\n\n    uint256 constant RRSIG_TYPE = 0;\n    uint256 constant RRSIG_ALGORITHM = 2;\n    uint256 constant RRSIG_LABELS = 3;\n    uint256 constant RRSIG_TTL = 4;\n    uint256 constant RRSIG_EXPIRATION = 8;\n    uint256 constant RRSIG_INCEPTION = 12;\n    uint256 constant RRSIG_KEY_TAG = 16;\n    uint256 constant RRSIG_SIGNER_NAME = 18;\n\n    struct SignedSet {\n        uint16 typeCovered;\n        uint8 algorithm;\n        uint8 labels;\n        uint32 ttl;\n        uint32 expiration;\n        uint32 inception;\n        uint16 keytag;\n        bytes signerName;\n        bytes data;\n        bytes name;\n    }\n\n    function readSignedSet(\n        bytes memory data\n    ) internal pure returns (SignedSet memory self) {\n        self.typeCovered = data.readUint16(RRSIG_TYPE);\n        self.algorithm = data.readUint8(RRSIG_ALGORITHM);\n        self.labels = data.readUint8(RRSIG_LABELS);\n        self.ttl = data.readUint32(RRSIG_TTL);\n        self.expiration = data.readUint32(RRSIG_EXPIRATION);\n        self.inception = data.readUint32(RRSIG_INCEPTION);\n        self.keytag = data.readUint16(RRSIG_KEY_TAG);\n        self.signerName = readName(data, RRSIG_SIGNER_NAME);\n        self.data = data.substring(\n            RRSIG_SIGNER_NAME + self.signerName.length,\n            data.length - RRSIG_SIGNER_NAME - self.signerName.length\n        );\n    }\n\n    function rrs(\n        SignedSet memory rrset\n    ) internal pure returns (RRIterator memory) {\n        return iterateRRs(rrset.data, 0);\n    }\n\n    /// @dev An iterator over resource records.\n    struct RRIterator {\n        bytes data;\n        uint256 offset;\n        uint16 dnstype;\n        uint16 class;\n        uint32 ttl;\n        uint256 rdataOffset;\n        uint256 nextOffset;\n    }\n\n    /// @dev Begins iterating over resource records.\n    /// @param self The byte string to read from.\n    /// @param offset The offset to start reading at.\n    /// @return ret An iterator object.\n    function iterateRRs(\n        bytes memory self,\n        uint256 offset\n    ) internal pure returns (RRIterator memory ret) {\n        ret.data = self;\n        ret.nextOffset = offset;\n        next(ret);\n    }\n\n    /// @dev Returns true iff there are more RRs to iterate.\n    /// @param iter The iterator to check.\n    /// @return True iff the iterator has finished.\n    function done(RRIterator memory iter) internal pure returns (bool) {\n        return iter.offset >= iter.data.length;\n    }\n\n    /// @dev Moves the iterator to the next resource record.\n    /// @param iter The iterator to advance.\n    function next(RRIterator memory iter) internal pure {\n        iter.offset = iter.nextOffset;\n        if (iter.offset >= iter.data.length) {\n            return;\n        }\n\n        // Skip the name\n        uint256 off = iter.offset + nameLength(iter.data, iter.offset);\n\n        // Read type, class, and ttl\n        iter.dnstype = iter.data.readUint16(off);\n        off += 2;\n        iter.class = iter.data.readUint16(off);\n        off += 2;\n        iter.ttl = iter.data.readUint32(off);\n        off += 4;\n\n        // Read the rdata\n        uint256 rdataLength = iter.data.readUint16(off);\n        off += 2;\n        iter.rdataOffset = off;\n        iter.nextOffset = off + rdataLength;\n    }\n\n    /// @dev Returns the name of the current record.\n    /// @param iter The iterator.\n    /// @return A new bytes object containing the owner name from the RR.\n    function name(RRIterator memory iter) internal pure returns (bytes memory) {\n        return\n            iter.data.substring(\n                iter.offset,\n                nameLength(iter.data, iter.offset)\n            );\n    }\n\n    /// @dev Returns the rdata portion of the current record.\n    /// @param iter The iterator.\n    /// @return A new bytes object containing the RR's RDATA.\n    function rdata(\n        RRIterator memory iter\n    ) internal pure returns (bytes memory) {\n        return\n            iter.data.substring(\n                iter.rdataOffset,\n                iter.nextOffset - iter.rdataOffset\n            );\n    }\n\n    uint256 constant DNSKEY_FLAGS = 0;\n    uint256 constant DNSKEY_PROTOCOL = 2;\n    uint256 constant DNSKEY_ALGORITHM = 3;\n    uint256 constant DNSKEY_PUBKEY = 4;\n\n    struct DNSKEY {\n        uint16 flags;\n        uint8 protocol;\n        uint8 algorithm;\n        bytes publicKey;\n    }\n\n    function readDNSKEY(\n        bytes memory data,\n        uint256 offset,\n        uint256 length\n    ) internal pure returns (DNSKEY memory self) {\n        self.flags = data.readUint16(offset + DNSKEY_FLAGS);\n        self.protocol = data.readUint8(offset + DNSKEY_PROTOCOL);\n        self.algorithm = data.readUint8(offset + DNSKEY_ALGORITHM);\n        self.publicKey = data.substring(\n            offset + DNSKEY_PUBKEY,\n            length - DNSKEY_PUBKEY\n        );\n    }\n\n    uint256 constant DS_KEY_TAG = 0;\n    uint256 constant DS_ALGORITHM = 2;\n    uint256 constant DS_DIGEST_TYPE = 3;\n    uint256 constant DS_DIGEST = 4;\n\n    struct DS {\n        uint16 keytag;\n        uint8 algorithm;\n        uint8 digestType;\n        bytes digest;\n    }\n\n    function readDS(\n        bytes memory data,\n        uint256 offset,\n        uint256 length\n    ) internal pure returns (DS memory self) {\n        self.keytag = data.readUint16(offset + DS_KEY_TAG);\n        self.algorithm = data.readUint8(offset + DS_ALGORITHM);\n        self.digestType = data.readUint8(offset + DS_DIGEST_TYPE);\n        self.digest = data.substring(offset + DS_DIGEST, length - DS_DIGEST);\n    }\n\n    function isSubdomainOf(\n        bytes memory self,\n        bytes memory other\n    ) internal pure returns (bool) {\n        uint256 off = 0;\n        uint256 counts = labelCount(self, 0);\n        uint256 othercounts = labelCount(other, 0);\n\n        while (counts > othercounts) {\n            off = progress(self, off);\n            counts--;\n        }\n\n        return self.equals(off, other, 0);\n    }\n\n    function compareNames(\n        bytes memory self,\n        bytes memory other\n    ) internal pure returns (int256) {\n        if (self.equals(other)) {\n            return 0;\n        }\n\n        uint256 off;\n        uint256 otheroff;\n        uint256 prevoff;\n        uint256 otherprevoff;\n        uint256 counts = labelCount(self, 0);\n        uint256 othercounts = labelCount(other, 0);\n\n        // Keep removing labels from the front of the name until both names are equal length\n        while (counts > othercounts) {\n            prevoff = off;\n            off = progress(self, off);\n            counts--;\n        }\n\n        while (othercounts > counts) {\n            otherprevoff = otheroff;\n            otheroff = progress(other, otheroff);\n            othercounts--;\n        }\n\n        // Compare the last nonequal labels to each other\n        while (counts > 0 && !self.equals(off, other, otheroff)) {\n            prevoff = off;\n            off = progress(self, off);\n            otherprevoff = otheroff;\n            otheroff = progress(other, otheroff);\n            counts -= 1;\n        }\n\n        if (off == 0) {\n            return -1;\n        }\n        if (otheroff == 0) {\n            return 1;\n        }\n\n        return\n            self.compare(\n                prevoff + 1,\n                self.readUint8(prevoff),\n                other,\n                otherprevoff + 1,\n                other.readUint8(otherprevoff)\n            );\n    }\n\n    /// @dev Compares two serial numbers using RFC1982 serial number math.\n    function serialNumberGte(\n        uint32 i1,\n        uint32 i2\n    ) internal pure returns (bool) {\n        unchecked {\n            return int32(i1) - int32(i2) >= 0;\n        }\n    }\n\n    function progress(\n        bytes memory body,\n        uint256 off\n    ) internal pure returns (uint256) {\n        return off + 1 + body.readUint8(off);\n    }\n\n    /// @dev Computes the keytag for a chunk of data.\n    /// @param data The data to compute a keytag for.\n    /// @return The computed key tag.\n    function computeKeytag(bytes memory data) internal pure returns (uint16) {\n        /* This function probably deserves some explanation.\n         * The DNSSEC keytag function is a checksum that relies on summing up individual bytes\n         * from the input string, with some mild bitshifting. Here's a Naive solidity implementation:\n         *\n         *     function computeKeytag(bytes memory data) internal pure returns (uint16) {\n         *         uint ac;\n         *         for (uint i = 0; i < data.length; i++) {\n         *             ac += i & 1 == 0 ? uint16(data.readUint8(i)) << 8 : data.readUint8(i);\n         *         }\n         *         return uint16(ac + (ac >> 16));\n         *     }\n         *\n         * The EVM, with its 256 bit words, is exceedingly inefficient at doing byte-by-byte operations;\n         * the code above, on reasonable length inputs, consumes over 100k gas. But we can make the EVM's\n         * large words work in our favour.\n         *\n         * The code below works by treating the input as a series of 256 bit words. It first masks out\n         * even and odd bytes from each input word, adding them to two separate accumulators `ac1` and `ac2`.\n         * The bytes are separated by empty bytes, so as long as no individual sum exceeds 2^16-1, we're\n         * effectively summing 16 different numbers with each EVM ADD opcode.\n         *\n         * Once it's added up all the inputs, it has to add all the 16 bit values in `ac1` and `ac2` together.\n         * It does this using the same trick - mask out every other value, shift to align them, add them together.\n         * After the first addition on both accumulators, there's enough room to add the two accumulators together,\n         * and the remaining sums can be done just on ac1.\n         */\n        unchecked {\n            require(data.length <= 8192, \"Long keys not permitted\");\n            uint256 ac1;\n            uint256 ac2;\n            for (uint256 i = 0; i < data.length + 31; i += 32) {\n                uint256 word;\n                assembly {\n                    word := mload(add(add(data, 32), i))\n                }\n                if (i + 32 > data.length) {\n                    uint256 unused = 256 - (data.length - i) * 8;\n                    word = (word >> unused) << unused;\n                }\n                ac1 +=\n                    (word &\n                        0xFF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00) >>\n                    8;\n                ac2 += (word &\n                    0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF);\n            }\n            ac1 =\n                (ac1 &\n                    0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) +\n                ((ac1 &\n                    0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >>\n                    16);\n            ac2 =\n                (ac2 &\n                    0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) +\n                ((ac2 &\n                    0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >>\n                    16);\n            ac1 = (ac1 << 8) + ac2;\n            ac1 =\n                (ac1 &\n                    0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) +\n                ((ac1 &\n                    0xFFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000) >>\n                    32);\n            ac1 =\n                (ac1 &\n                    0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) +\n                ((ac1 &\n                    0xFFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >>\n                    64);\n            ac1 =\n                (ac1 &\n                    0x00000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) +\n                (ac1 >> 128);\n            ac1 += (ac1 >> 16) & 0xFFFF;\n            return uint16(ac1);\n        }\n    }\n}\n"
    },
    "contracts/dnssec-oracle/SHA1.sol": {
      "content": "pragma solidity >=0.8.4;\n\nlibrary SHA1 {\n    event Debug(bytes32 x);\n\n    function sha1(bytes memory data) internal pure returns (bytes20 ret) {\n        assembly {\n            // Get a safe scratch location\n            let scratch := mload(0x40)\n\n            // Get the data length, and point data at the first byte\n            let len := mload(data)\n            data := add(data, 32)\n\n            // Find the length after padding\n            let totallen := add(and(add(len, 1), 0xFFFFFFFFFFFFFFC0), 64)\n            switch lt(sub(totallen, len), 9)\n            case 1 {\n                totallen := add(totallen, 64)\n            }\n\n            let h := 0x6745230100EFCDAB890098BADCFE001032547600C3D2E1F0\n\n            function readword(ptr, off, count) -> result {\n                result := 0\n                if lt(off, count) {\n                    result := mload(add(ptr, off))\n                    count := sub(count, off)\n                    if lt(count, 32) {\n                        let mask := not(sub(exp(256, sub(32, count)), 1))\n                        result := and(result, mask)\n                    }\n                }\n            }\n\n            for {\n                let i := 0\n            } lt(i, totallen) {\n                i := add(i, 64)\n            } {\n                mstore(scratch, readword(data, i, len))\n                mstore(add(scratch, 32), readword(data, add(i, 32), len))\n\n                // If we loaded the last byte, store the terminator byte\n                switch lt(sub(len, i), 64)\n                case 1 {\n                    mstore8(add(scratch, sub(len, i)), 0x80)\n                }\n\n                // If this is the last block, store the length\n                switch eq(i, sub(totallen, 64))\n                case 1 {\n                    mstore(\n                        add(scratch, 32),\n                        or(mload(add(scratch, 32)), mul(len, 8))\n                    )\n                }\n\n                // Expand the 16 32-bit words into 80\n                for {\n                    let j := 64\n                } lt(j, 128) {\n                    j := add(j, 12)\n                } {\n                    let temp := xor(\n                        xor(\n                            mload(add(scratch, sub(j, 12))),\n                            mload(add(scratch, sub(j, 32)))\n                        ),\n                        xor(\n                            mload(add(scratch, sub(j, 56))),\n                            mload(add(scratch, sub(j, 64)))\n                        )\n                    )\n                    temp := or(\n                        and(\n                            mul(temp, 2),\n                            0xFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFE\n                        ),\n                        and(\n                            div(temp, 0x80000000),\n                            0x0000000100000001000000010000000100000001000000010000000100000001\n                        )\n                    )\n                    mstore(add(scratch, j), temp)\n                }\n                for {\n                    let j := 128\n                } lt(j, 320) {\n                    j := add(j, 24)\n                } {\n                    let temp := xor(\n                        xor(\n                            mload(add(scratch, sub(j, 24))),\n                            mload(add(scratch, sub(j, 64)))\n                        ),\n                        xor(\n                            mload(add(scratch, sub(j, 112))),\n                            mload(add(scratch, sub(j, 128)))\n                        )\n                    )\n                    temp := or(\n                        and(\n                            mul(temp, 4),\n                            0xFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFC\n                        ),\n                        and(\n                            div(temp, 0x40000000),\n                            0x0000000300000003000000030000000300000003000000030000000300000003\n                        )\n                    )\n                    mstore(add(scratch, j), temp)\n                }\n\n                let x := h\n                let f := 0\n                let k := 0\n                for {\n                    let j := 0\n                } lt(j, 80) {\n                    j := add(j, 1)\n                } {\n                    switch div(j, 20)\n                    case 0 {\n                        // f = d xor (b and (c xor d))\n                        f := xor(\n                            div(x, 0x100000000000000000000),\n                            div(x, 0x10000000000)\n                        )\n                        f := and(div(x, 0x1000000000000000000000000000000), f)\n                        f := xor(div(x, 0x10000000000), f)\n                        k := 0x5A827999\n                    }\n                    case 1 {\n                        // f = b xor c xor d\n                        f := xor(\n                            div(x, 0x1000000000000000000000000000000),\n                            div(x, 0x100000000000000000000)\n                        )\n                        f := xor(div(x, 0x10000000000), f)\n                        k := 0x6ED9EBA1\n                    }\n                    case 2 {\n                        // f = (b and c) or (d and (b or c))\n                        f := or(\n                            div(x, 0x1000000000000000000000000000000),\n                            div(x, 0x100000000000000000000)\n                        )\n                        f := and(div(x, 0x10000000000), f)\n                        f := or(\n                            and(\n                                div(x, 0x1000000000000000000000000000000),\n                                div(x, 0x100000000000000000000)\n                            ),\n                            f\n                        )\n                        k := 0x8F1BBCDC\n                    }\n                    case 3 {\n                        // f = b xor c xor d\n                        f := xor(\n                            div(x, 0x1000000000000000000000000000000),\n                            div(x, 0x100000000000000000000)\n                        )\n                        f := xor(div(x, 0x10000000000), f)\n                        k := 0xCA62C1D6\n                    }\n                    // temp = (a leftrotate 5) + f + e + k + w[i]\n                    let temp := and(\n                        div(\n                            x,\n                            0x80000000000000000000000000000000000000000000000\n                        ),\n                        0x1F\n                    )\n                    temp := or(\n                        and(\n                            div(x, 0x800000000000000000000000000000000000000),\n                            0xFFFFFFE0\n                        ),\n                        temp\n                    )\n                    temp := add(f, temp)\n                    temp := add(and(x, 0xFFFFFFFF), temp)\n                    temp := add(k, temp)\n                    temp := add(\n                        div(\n                            mload(add(scratch, mul(j, 4))),\n                            0x100000000000000000000000000000000000000000000000000000000\n                        ),\n                        temp\n                    )\n                    x := or(\n                        div(x, 0x10000000000),\n                        mul(temp, 0x10000000000000000000000000000000000000000)\n                    )\n                    x := or(\n                        and(\n                            x,\n                            0xFFFFFFFF00FFFFFFFF000000000000FFFFFFFF00FFFFFFFF\n                        ),\n                        mul(\n                            or(\n                                and(div(x, 0x4000000000000), 0xC0000000),\n                                and(div(x, 0x400000000000000000000), 0x3FFFFFFF)\n                            ),\n                            0x100000000000000000000\n                        )\n                    )\n                }\n\n                h := and(\n                    add(h, x),\n                    0xFFFFFFFF00FFFFFFFF00FFFFFFFF00FFFFFFFF00FFFFFFFF\n                )\n            }\n            ret := mul(\n                or(\n                    or(\n                        or(\n                            or(\n                                and(\n                                    div(h, 0x100000000),\n                                    0xFFFFFFFF00000000000000000000000000000000\n                                ),\n                                and(\n                                    div(h, 0x1000000),\n                                    0xFFFFFFFF000000000000000000000000\n                                )\n                            ),\n                            and(div(h, 0x10000), 0xFFFFFFFF0000000000000000)\n                        ),\n                        and(div(h, 0x100), 0xFFFFFFFF00000000)\n                    ),\n                    and(h, 0xFFFFFFFF)\n                ),\n                0x1000000000000000000000000\n            )\n        }\n    }\n}\n"
    },
    "contracts/ethregistrar/BaseRegistrarImplementation.sol": {
      "content": "pragma solidity >=0.8.4;\n\nimport \"../registry/ENS.sol\";\nimport \"./IBaseRegistrar.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract BaseRegistrarImplementation is ERC721, IBaseRegistrar, Ownable {\n    // A map of expiry times\n    mapping(uint256 => uint256) expiries;\n    // The ENS registry\n    ENS public ens;\n    // The namehash of the TLD this registrar owns (eg, .eth)\n    bytes32 public baseNode;\n    // A map of addresses that are authorised to register and renew names.\n    mapping(address => bool) public controllers;\n    uint256 public constant GRACE_PERIOD = 90 days;\n    bytes4 private constant INTERFACE_META_ID =\n        bytes4(keccak256(\"supportsInterface(bytes4)\"));\n    bytes4 private constant ERC721_ID =\n        bytes4(\n            keccak256(\"balanceOf(address)\") ^\n                keccak256(\"ownerOf(uint256)\") ^\n                keccak256(\"approve(address,uint256)\") ^\n                keccak256(\"getApproved(uint256)\") ^\n                keccak256(\"setApprovalForAll(address,bool)\") ^\n                keccak256(\"isApprovedForAll(address,address)\") ^\n                keccak256(\"transferFrom(address,address,uint256)\") ^\n                keccak256(\"safeTransferFrom(address,address,uint256)\") ^\n                keccak256(\"safeTransferFrom(address,address,uint256,bytes)\")\n        );\n    bytes4 private constant RECLAIM_ID =\n        bytes4(keccak256(\"reclaim(uint256,address)\"));\n\n    /// v2.1.3 version of _isApprovedOrOwner which calls ownerOf(tokenId) and takes grace period into consideration instead of ERC721.ownerOf(tokenId);\n    /// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.1.3/contracts/token/ERC721/ERC721.sol#L187\n    /// @dev Returns whether the given spender can transfer a given token ID\n    /// @param spender address of the spender to query\n    /// @param tokenId uint256 ID of the token to be transferred\n    /// @return bool whether the msg.sender is approved for the given token ID,\n    ///              is an operator of the owner, or is the owner of the token\n    function _isApprovedOrOwner(\n        address spender,\n        uint256 tokenId\n    ) internal view override returns (bool) {\n        address owner = ownerOf(tokenId);\n        return (spender == owner ||\n            getApproved(tokenId) == spender ||\n            isApprovedForAll(owner, spender));\n    }\n\n    constructor(ENS _ens, bytes32 _baseNode) ERC721(\"\", \"\") {\n        ens = _ens;\n        baseNode = _baseNode;\n    }\n\n    modifier live() {\n        require(ens.owner(baseNode) == address(this));\n        _;\n    }\n\n    modifier onlyController() {\n        require(controllers[msg.sender]);\n        _;\n    }\n\n    /// @dev Gets the owner of the specified token ID. Names become unowned\n    ///      when their registration expires.\n    /// @param tokenId uint256 ID of the token to query the owner of\n    /// @return address currently marked as the owner of the given token ID\n    function ownerOf(\n        uint256 tokenId\n    ) public view override(IERC721, ERC721) returns (address) {\n        require(expiries[tokenId] > block.timestamp);\n        return super.ownerOf(tokenId);\n    }\n\n    // Authorises a controller, who can register and renew domains.\n    function addController(address controller) external override onlyOwner {\n        controllers[controller] = true;\n        emit ControllerAdded(controller);\n    }\n\n    // Revoke controller permission for an address.\n    function removeController(address controller) external override onlyOwner {\n        controllers[controller] = false;\n        emit ControllerRemoved(controller);\n    }\n\n    // Set the resolver for the TLD this registrar manages.\n    function setResolver(address resolver) external override onlyOwner {\n        ens.setResolver(baseNode, resolver);\n    }\n\n    // Returns the expiration timestamp of the specified id.\n    function nameExpires(uint256 id) external view override returns (uint256) {\n        return expiries[id];\n    }\n\n    // Returns true iff the specified name is available for registration.\n    function available(uint256 id) public view override returns (bool) {\n        // Not available if it's registered here or in its grace period.\n        return expiries[id] + GRACE_PERIOD < block.timestamp;\n    }\n\n    /// @dev Register a name.\n    /// @param id The token ID (keccak256 of the label).\n    /// @param owner The address that should own the registration.\n    /// @param duration Duration in seconds for the registration.\n    function register(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external override returns (uint256) {\n        return _register(id, owner, duration, true);\n    }\n\n    /// @dev Register a name, without modifying the registry.\n    /// @param id The token ID (keccak256 of the label).\n    /// @param owner The address that should own the registration.\n    /// @param duration Duration in seconds for the registration.\n    function registerOnly(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external returns (uint256) {\n        return _register(id, owner, duration, false);\n    }\n\n    function _register(\n        uint256 id,\n        address owner,\n        uint256 duration,\n        bool updateRegistry\n    ) internal live onlyController returns (uint256) {\n        require(available(id));\n        require(\n            block.timestamp + duration + GRACE_PERIOD >\n                block.timestamp + GRACE_PERIOD\n        ); // Prevent future overflow\n\n        expiries[id] = block.timestamp + duration;\n        if (_exists(id)) {\n            // Name was previously owned, and expired\n            _burn(id);\n        }\n        _mint(owner, id);\n        if (updateRegistry) {\n            ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n        }\n\n        emit NameRegistered(id, owner, block.timestamp + duration);\n\n        return block.timestamp + duration;\n    }\n\n    function renew(\n        uint256 id,\n        uint256 duration\n    ) external override live onlyController returns (uint256) {\n        require(expiries[id] + GRACE_PERIOD >= block.timestamp); // Name must be registered here or in grace period\n        require(\n            expiries[id] + duration + GRACE_PERIOD > duration + GRACE_PERIOD\n        ); // Prevent future overflow\n\n        expiries[id] += duration;\n        emit NameRenewed(id, expiries[id]);\n        return expiries[id];\n    }\n\n    /// @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\n    function reclaim(uint256 id, address owner) external override live {\n        require(_isApprovedOrOwner(msg.sender, id));\n        ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view override(ERC721, IERC165) returns (bool) {\n        return\n            interfaceID == INTERFACE_META_ID ||\n            interfaceID == ERC721_ID ||\n            interfaceID == RECLAIM_ID;\n    }\n}\n"
    },
    "contracts/ethregistrar/BulkRenewal.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ~0.8.17;\n\nimport \"../registry/ENS.sol\";\nimport \"./ETHRegistrarController.sol\";\nimport \"./IETHRegistrarController.sol\";\nimport \"../resolvers/Resolver.sol\";\nimport \"./IBulkRenewal.sol\";\nimport \"./IPriceOracle.sol\";\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\ncontract BulkRenewal is IBulkRenewal {\n    bytes32 private constant ETH_NAMEHASH =\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n\n    ENS public immutable ens;\n\n    constructor(ENS _ens) {\n        ens = _ens;\n    }\n\n    function getController() internal view returns (ETHRegistrarController) {\n        Resolver r = Resolver(ens.resolver(ETH_NAMEHASH));\n        return\n            ETHRegistrarController(\n                r.interfaceImplementer(\n                    ETH_NAMEHASH,\n                    type(IETHRegistrarController).interfaceId\n                )\n            );\n    }\n\n    function rentPrice(\n        string[] calldata names,\n        uint256 duration\n    ) external view override returns (uint256 total) {\n        ETHRegistrarController controller = getController();\n        uint256 length = names.length;\n        for (uint256 i = 0; i < length; ) {\n            IPriceOracle.Price memory price = controller.rentPrice(\n                names[i],\n                duration\n            );\n            unchecked {\n                ++i;\n                total += (price.base + price.premium);\n            }\n        }\n    }\n\n    function renewAll(\n        string[] calldata names,\n        uint256 duration,\n        bytes32 referrer\n    ) external payable override {\n        ETHRegistrarController controller = getController();\n        uint256 length = names.length;\n        uint256 total;\n        for (uint256 i = 0; i < length; ) {\n            IPriceOracle.Price memory price = controller.rentPrice(\n                names[i],\n                duration\n            );\n            uint256 totalPrice = price.base + price.premium;\n            controller.renew{value: totalPrice}(names[i], duration, referrer);\n            unchecked {\n                ++i;\n                total += totalPrice;\n            }\n        }\n        // Send any excess funds back\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) external pure returns (bool) {\n        return\n            interfaceID == type(IERC165).interfaceId ||\n            interfaceID == type(IBulkRenewal).interfaceId;\n    }\n}\n"
    },
    "contracts/ethregistrar/DummyOracle.sol": {
      "content": "pragma solidity >=0.8.4;\n\ncontract DummyOracle {\n    int256 value;\n\n    constructor(int256 _value) public {\n        set(_value);\n    }\n\n    function set(int256 _value) public {\n        value = _value;\n    }\n\n    function latestAnswer() public view returns (int256) {\n        return value;\n    }\n}\n"
    },
    "contracts/ethregistrar/ETHRegistrarController.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ~0.8.17;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {BaseRegistrarImplementation} from \"./BaseRegistrarImplementation.sol\";\nimport {StringUtils} from \"../utils/StringUtils.sol\";\nimport {Resolver} from \"../resolvers/Resolver.sol\";\nimport {ENS} from \"../registry/ENS.sol\";\nimport {IReverseRegistrar} from \"../reverseRegistrar/IReverseRegistrar.sol\";\nimport {IDefaultReverseRegistrar} from \"../reverseRegistrar/IDefaultReverseRegistrar.sol\";\nimport {IETHRegistrarController, IPriceOracle} from \"./IETHRegistrarController.sol\";\nimport {ERC20Recoverable} from \"../utils/ERC20Recoverable.sol\";\n\n/// @dev A registrar controller for registering and renewing names at fixed cost.\ncontract ETHRegistrarController is\n    Ownable,\n    IETHRegistrarController,\n    ERC165,\n    ERC20Recoverable\n{\n    using StringUtils for *;\n\n    /// @notice The bitmask for the Ethereum reverse record.\n    uint8 constant REVERSE_RECORD_ETHEREUM_BIT = 1;\n\n    /// @notice The bitmask for the default reverse record.\n    uint8 constant REVERSE_RECORD_DEFAULT_BIT = 2;\n\n    /// @notice The minimum duration for a registration.\n    uint256 public constant MIN_REGISTRATION_DURATION = 28 days;\n\n    // @notice The node (i.e. namehash) for the eth TLD.\n    bytes32 private constant ETH_NODE =\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n\n    /// @notice The maximum expiry time for a registration.\n    uint64 private constant MAX_EXPIRY = type(uint64).max;\n\n    /// @notice The ENS registry.\n    ENS public immutable ens;\n\n    // @notice The base registrar implementation for the eth TLD.\n    BaseRegistrarImplementation immutable base;\n\n    /// @notice The minimum time a commitment must exist to be valid.\n    uint256 public immutable minCommitmentAge;\n\n    /// @notice The maximum time a commitment can exist to be valid.\n    uint256 public immutable maxCommitmentAge;\n\n    /// @notice The registrar for addr.reverse. (i.e. reverse for coinType 60)\n    IReverseRegistrar public immutable reverseRegistrar;\n\n    /// @notice The registrar for default.reverse. (i.e. fallback reverse for all EVM chains)\n    IDefaultReverseRegistrar public immutable defaultReverseRegistrar;\n\n    /// @notice The price oracle for the eth TLD.\n    IPriceOracle public immutable prices;\n\n    /// @notice A mapping of commitments to their timestamp.\n    mapping(bytes32 => uint256) public commitments;\n\n    /// @notice Thrown when a commitment is not found.\n    error CommitmentNotFound(bytes32 commitment);\n\n    /// @notice Thrown when a commitment is too new.\n    error CommitmentTooNew(\n        bytes32 commitment,\n        uint256 minimumCommitmentTimestamp,\n        uint256 currentTimestamp\n    );\n\n    /// @notice Thrown when a commitment is too old.\n    error CommitmentTooOld(\n        bytes32 commitment,\n        uint256 maximumCommitmentTimestamp,\n        uint256 currentTimestamp\n    );\n\n    /// @notice Thrown when a name is not available to register.\n    error NameNotAvailable(string name);\n\n    /// @notice Thrown when the duration supplied for a registration is too short.\n    error DurationTooShort(uint256 duration);\n\n    /// @notice Thrown when data is supplied for a registration without a resolver.\n    error ResolverRequiredWhenDataSupplied();\n\n    /// @notice Thrown when a reverse record is requested without a resolver.\n    error ResolverRequiredForReverseRecord();\n\n    /// @notice Thrown when a matching unexpired commitment exists.\n    error UnexpiredCommitmentExists(bytes32 commitment);\n\n    /// @notice Thrown when the value sent for a registration is insufficient.\n    error InsufficientValue();\n\n    /// @notice Thrown when the maximum commitment age is too low.\n    error MaxCommitmentAgeTooLow();\n\n    /// @notice Thrown when the maximum commitment age is too high.\n    error MaxCommitmentAgeTooHigh();\n\n    /// @notice Emitted when a name is registered.\n    ///\n    /// @param label The label of the name.\n    /// @param labelhash The keccak256 hash of the label.\n    /// @param owner The owner of the name.\n    /// @param baseCost The base cost of the name.\n    /// @param premium The premium cost of the name.\n    /// @param expires The expiry time of the name.\n    /// @param referrer The referrer of the registration.\n    event NameRegistered(\n        string label,\n        bytes32 indexed labelhash,\n        address indexed owner,\n        uint256 baseCost,\n        uint256 premium,\n        uint256 expires,\n        bytes32 referrer\n    );\n\n    /// @notice Emitted when a name is renewed.\n    ///\n    /// @param label The label of the name.\n    /// @param labelhash The keccak256 hash of the label.\n    /// @param cost The cost of the name.\n    /// @param expires The expiry time of the name.\n    /// @param referrer The referrer of the registration.\n    event NameRenewed(\n        string label,\n        bytes32 indexed labelhash,\n        uint256 cost,\n        uint256 expires,\n        bytes32 referrer\n    );\n\n    /// @notice Constructor for the ETHRegistrarController.\n    ///\n    /// @param _base The base registrar implementation for the eth TLD.\n    /// @param _prices The price oracle for the eth TLD.\n    /// @param _minCommitmentAge The minimum time a commitment must exist to be valid.\n    /// @param _maxCommitmentAge The maximum time a commitment can exist to be valid.\n    /// @param _reverseRegistrar The registrar for addr.reverse.\n    /// @param _defaultReverseRegistrar The registrar for default.reverse.\n    /// @param _ens The ENS registry.\n    constructor(\n        BaseRegistrarImplementation _base,\n        IPriceOracle _prices,\n        uint256 _minCommitmentAge,\n        uint256 _maxCommitmentAge,\n        IReverseRegistrar _reverseRegistrar,\n        IDefaultReverseRegistrar _defaultReverseRegistrar,\n        ENS _ens\n    ) {\n        if (_maxCommitmentAge <= _minCommitmentAge)\n            revert MaxCommitmentAgeTooLow();\n\n        if (_maxCommitmentAge > block.timestamp)\n            revert MaxCommitmentAgeTooHigh();\n\n        ens = _ens;\n        base = _base;\n        prices = _prices;\n        minCommitmentAge = _minCommitmentAge;\n        maxCommitmentAge = _maxCommitmentAge;\n        reverseRegistrar = _reverseRegistrar;\n        defaultReverseRegistrar = _defaultReverseRegistrar;\n    }\n\n    /// @notice Returns the price of a registration for the given label and duration.\n    ///\n    /// @param label The label of the name.\n    /// @param duration The duration of the registration.\n    /// @return price The price of the registration.\n    function rentPrice(\n        string calldata label,\n        uint256 duration\n    ) public view override returns (IPriceOracle.Price memory price) {\n        bytes32 labelhash = keccak256(bytes(label));\n        price = _rentPrice(label, labelhash, duration);\n    }\n\n    /// @notice Returns true if the label is valid for registration.\n    ///\n    /// @param label The label to check.\n    /// @return True if the label is valid, false otherwise.\n    function valid(string calldata label) public pure returns (bool) {\n        return label.strlen() >= 3;\n    }\n\n    /// @notice Returns true if the label is valid and available for registration.\n    ///\n    /// @param label The label to check.\n    /// @return True if the label is valid and available, false otherwise.\n    function available(\n        string calldata label\n    ) public view override returns (bool) {\n        bytes32 labelhash = keccak256(bytes(label));\n        return _available(label, labelhash);\n    }\n\n    /// @notice Returns the commitment for a registration.\n    ///\n    /// @param registration The registration to make a commitment for.\n    /// @return commitment The commitment for the registration.\n    function makeCommitment(\n        Registration calldata registration\n    ) public pure override returns (bytes32 commitment) {\n        if (registration.data.length > 0 && registration.resolver == address(0))\n            revert ResolverRequiredWhenDataSupplied();\n\n        if (\n            registration.reverseRecord != 0 &&\n            registration.resolver == address(0)\n        ) revert ResolverRequiredForReverseRecord();\n\n        if (registration.duration < MIN_REGISTRATION_DURATION)\n            revert DurationTooShort(registration.duration);\n\n        return keccak256(abi.encode(registration));\n    }\n\n    /// @notice Commits a registration.\n    ///\n    /// @param commitment The commitment to commit.\n    function commit(bytes32 commitment) public override {\n        if (commitments[commitment] + maxCommitmentAge >= block.timestamp) {\n            revert UnexpiredCommitmentExists(commitment);\n        }\n        commitments[commitment] = block.timestamp;\n    }\n\n    /// @notice Registers a name.\n    ///\n    /// @param registration The registration to register.\n    /// @param registration.label The label of the name.\n    /// @param registration.owner The owner of the name.\n    /// @param registration.duration The duration of the registration.\n    /// @param registration.resolver The resolver for the name.\n    /// @param registration.data The data for the name.\n    /// @param registration.reverseRecord Which reverse record(s) to set.\n    /// @param registration.referrer The referrer of the registration.\n    function register(\n        Registration calldata registration\n    ) public payable override {\n        bytes32 labelhash = keccak256(bytes(registration.label));\n        IPriceOracle.Price memory price = _rentPrice(\n            registration.label,\n            labelhash,\n            registration.duration\n        );\n        uint256 totalPrice = price.base + price.premium;\n        if (msg.value < totalPrice) revert InsufficientValue();\n\n        if (!_available(registration.label, labelhash))\n            revert NameNotAvailable(registration.label);\n\n        bytes32 commitment = makeCommitment(registration);\n        uint256 commitmentTimestamp = commitments[commitment];\n\n        // Require an old enough commitment.\n        if (commitmentTimestamp + minCommitmentAge > block.timestamp)\n            revert CommitmentTooNew(\n                commitment,\n                commitmentTimestamp + minCommitmentAge,\n                block.timestamp\n            );\n\n        // If the commitment is too old, or the name is registered, stop\n        if (commitmentTimestamp + maxCommitmentAge <= block.timestamp) {\n            if (commitmentTimestamp == 0) revert CommitmentNotFound(commitment);\n            revert CommitmentTooOld(\n                commitment,\n                commitmentTimestamp + maxCommitmentAge,\n                block.timestamp\n            );\n        }\n\n        delete (commitments[commitment]);\n\n        uint256 expires;\n\n        if (registration.resolver == address(0)) {\n            expires = base.register(\n                uint256(labelhash),\n                registration.owner,\n                registration.duration\n            );\n        } else {\n            expires = base.register(\n                uint256(labelhash),\n                address(this),\n                registration.duration\n            );\n\n            bytes32 namehash = keccak256(abi.encodePacked(ETH_NODE, labelhash));\n            ens.setRecord(\n                namehash,\n                registration.owner,\n                registration.resolver,\n                0\n            );\n            if (registration.data.length > 0)\n                Resolver(registration.resolver).multicallWithNodeCheck(\n                    namehash,\n                    registration.data\n                );\n\n            base.transferFrom(\n                address(this),\n                registration.owner,\n                uint256(labelhash)\n            );\n\n            if (registration.reverseRecord & REVERSE_RECORD_ETHEREUM_BIT != 0)\n                reverseRegistrar.setNameForAddr(\n                    msg.sender,\n                    msg.sender,\n                    registration.resolver,\n                    string.concat(registration.label, \".eth\")\n                );\n            if (registration.reverseRecord & REVERSE_RECORD_DEFAULT_BIT != 0)\n                defaultReverseRegistrar.setNameForAddr(\n                    msg.sender,\n                    string.concat(registration.label, \".eth\")\n                );\n        }\n\n        emit NameRegistered(\n            registration.label,\n            labelhash,\n            registration.owner,\n            price.base,\n            price.premium,\n            expires,\n            registration.referrer\n        );\n\n        if (msg.value > totalPrice)\n            payable(msg.sender).transfer(msg.value - totalPrice);\n    }\n\n    /// @notice Renews a name.\n    ///\n    /// @param label The label of the name.\n    /// @param duration The duration of the registration.\n    /// @param referrer The referrer of the registration.\n    function renew(\n        string calldata label,\n        uint256 duration,\n        bytes32 referrer\n    ) external payable override {\n        bytes32 labelhash = keccak256(bytes(label));\n\n        IPriceOracle.Price memory price = _rentPrice(\n            label,\n            labelhash,\n            duration\n        );\n        if (msg.value < price.base) revert InsufficientValue();\n\n        uint256 expires = base.renew(uint256(labelhash), duration);\n\n        emit NameRenewed(label, labelhash, price.base, expires, referrer);\n\n        if (msg.value > price.base)\n            payable(msg.sender).transfer(msg.value - price.base);\n    }\n\n    /// @notice Withdraws the balance of the contract to the owner.\n    function withdraw() public {\n        payable(owner()).transfer(address(this).balance);\n    }\n\n    /// @inheritdoc IERC165\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view override returns (bool) {\n        return\n            interfaceID == type(IETHRegistrarController).interfaceId ||\n            super.supportsInterface(interfaceID);\n    }\n\n    /* Internal functions */\n\n    function _rentPrice(\n        string calldata label,\n        bytes32 labelhash,\n        uint256 duration\n    ) internal view returns (IPriceOracle.Price memory price) {\n        price = prices.price(\n            label,\n            base.nameExpires(uint256(labelhash)),\n            duration\n        );\n    }\n\n    function _available(\n        string calldata label,\n        bytes32 labelhash\n    ) internal view returns (bool) {\n        return valid(label) && base.available(uint256(labelhash));\n    }\n}\n"
    },
    "contracts/ethregistrar/ExponentialPremiumPriceOracle.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ~0.8.17;\n\nimport \"./StablePriceOracle.sol\";\n\ncontract ExponentialPremiumPriceOracle is StablePriceOracle {\n    uint256 constant GRACE_PERIOD = 90 days;\n    uint256 immutable startPremium;\n    uint256 immutable endValue;\n\n    constructor(\n        AggregatorInterface _usdOracle,\n        uint256[] memory _rentPrices,\n        uint256 _startPremium,\n        uint256 totalDays\n    ) StablePriceOracle(_usdOracle, _rentPrices) {\n        startPremium = _startPremium;\n        endValue = _startPremium >> totalDays;\n    }\n\n    uint256 constant PRECISION = 1e18;\n    uint256 constant bit1 = 999989423469314432; // 0.5 ^ 1/65536 * (10 ** 18)\n    uint256 constant bit2 = 999978847050491904; // 0.5 ^ 2/65536 * (10 ** 18)\n    uint256 constant bit3 = 999957694548431104;\n    uint256 constant bit4 = 999915390886613504;\n    uint256 constant bit5 = 999830788931929088;\n    uint256 constant bit6 = 999661606496243712;\n    uint256 constant bit7 = 999323327502650752;\n    uint256 constant bit8 = 998647112890970240;\n    uint256 constant bit9 = 997296056085470080;\n    uint256 constant bit10 = 994599423483633152;\n    uint256 constant bit11 = 989228013193975424;\n    uint256 constant bit12 = 978572062087700096;\n    uint256 constant bit13 = 957603280698573696;\n    uint256 constant bit14 = 917004043204671232;\n    uint256 constant bit15 = 840896415253714560;\n    uint256 constant bit16 = 707106781186547584;\n\n    /// @dev Returns the pricing premium in internal base units.\n    function _premium(\n        string memory,\n        uint256 expires,\n        uint256\n    ) internal view override returns (uint256) {\n        expires = expires + GRACE_PERIOD;\n        if (expires > block.timestamp) {\n            return 0;\n        }\n\n        uint256 elapsed = block.timestamp - expires;\n        uint256 premium = decayedPremium(startPremium, elapsed);\n        if (premium >= endValue) {\n            return premium - endValue;\n        }\n        return 0;\n    }\n\n    /// @dev Returns the premium price at current time elapsed\n    /// @param startPremium starting price\n    /// @param elapsed time past since expiry\n    function decayedPremium(\n        uint256 startPremium,\n        uint256 elapsed\n    ) public pure returns (uint256) {\n        uint256 daysPast = (elapsed * PRECISION) / 1 days;\n        uint256 intDays = daysPast / PRECISION;\n        uint256 premium = startPremium >> intDays;\n        uint256 partDay = (daysPast - intDays * PRECISION);\n        uint256 fraction = (partDay * (2 ** 16)) / PRECISION;\n        uint256 totalPremium = addFractionalPremium(fraction, premium);\n        return totalPremium;\n    }\n\n    function addFractionalPremium(\n        uint256 fraction,\n        uint256 premium\n    ) internal pure returns (uint256) {\n        if (fraction & (1 << 0) != 0) {\n            premium = (premium * bit1) / PRECISION;\n        }\n        if (fraction & (1 << 1) != 0) {\n            premium = (premium * bit2) / PRECISION;\n        }\n        if (fraction & (1 << 2) != 0) {\n            premium = (premium * bit3) / PRECISION;\n        }\n        if (fraction & (1 << 3) != 0) {\n            premium = (premium * bit4) / PRECISION;\n        }\n        if (fraction & (1 << 4) != 0) {\n            premium = (premium * bit5) / PRECISION;\n        }\n        if (fraction & (1 << 5) != 0) {\n            premium = (premium * bit6) / PRECISION;\n        }\n        if (fraction & (1 << 6) != 0) {\n            premium = (premium * bit7) / PRECISION;\n        }\n        if (fraction & (1 << 7) != 0) {\n            premium = (premium * bit8) / PRECISION;\n        }\n        if (fraction & (1 << 8) != 0) {\n            premium = (premium * bit9) / PRECISION;\n        }\n        if (fraction & (1 << 9) != 0) {\n            premium = (premium * bit10) / PRECISION;\n        }\n        if (fraction & (1 << 10) != 0) {\n            premium = (premium * bit11) / PRECISION;\n        }\n        if (fraction & (1 << 11) != 0) {\n            premium = (premium * bit12) / PRECISION;\n        }\n        if (fraction & (1 << 12) != 0) {\n            premium = (premium * bit13) / PRECISION;\n        }\n        if (fraction & (1 << 13) != 0) {\n            premium = (premium * bit14) / PRECISION;\n        }\n        if (fraction & (1 << 14) != 0) {\n            premium = (premium * bit15) / PRECISION;\n        }\n        if (fraction & (1 << 15) != 0) {\n            premium = (premium * bit16) / PRECISION;\n        }\n        return premium;\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view virtual override returns (bool) {\n        return super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "contracts/ethregistrar/IBaseRegistrar.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../registry/ENS.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\ninterface IBaseRegistrar is IERC721 {\n    event ControllerAdded(address indexed controller);\n    event ControllerRemoved(address indexed controller);\n    event NameMigrated(\n        uint256 indexed id,\n        address indexed owner,\n        uint256 expires\n    );\n    event NameRegistered(\n        uint256 indexed id,\n        address indexed owner,\n        uint256 expires\n    );\n    event NameRenewed(uint256 indexed id, uint256 expires);\n\n    // Authorises a controller, who can register and renew domains.\n    function addController(address controller) external;\n\n    // Revoke controller permission for an address.\n    function removeController(address controller) external;\n\n    // Set the resolver for the TLD this registrar manages.\n    function setResolver(address resolver) external;\n\n    // Returns the expiration timestamp of the specified label hash.\n    function nameExpires(uint256 id) external view returns (uint256);\n\n    // Returns true if the specified name is available for registration.\n    function available(uint256 id) external view returns (bool);\n\n    /// @dev Register a name.\n    function register(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external returns (uint256);\n\n    function renew(uint256 id, uint256 duration) external returns (uint256);\n\n    /// @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\n    function reclaim(uint256 id, address owner) external;\n}\n"
    },
    "contracts/ethregistrar/IBulkRenewal.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IBulkRenewal {\n    function rentPrice(\n        string[] calldata names,\n        uint256 duration\n    ) external view returns (uint256 total);\n\n    function renewAll(\n        string[] calldata names,\n        uint256 duration,\n        bytes32 referrer\n    ) external payable;\n}\n"
    },
    "contracts/ethregistrar/IETHRegistrarController.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ~0.8.17;\n\nimport \"./IPriceOracle.sol\";\n\ninterface IETHRegistrarController {\n    struct Registration {\n        string label;\n        address owner;\n        uint256 duration;\n        bytes32 secret;\n        address resolver;\n        bytes[] data;\n        uint8 reverseRecord;\n        bytes32 referrer;\n    }\n\n    function rentPrice(\n        string memory label,\n        uint256 duration\n    ) external view returns (IPriceOracle.Price memory);\n\n    function available(string memory label) external returns (bool);\n\n    function makeCommitment(\n        Registration memory registration\n    ) external pure returns (bytes32 commitment);\n\n    function commit(bytes32 commitment) external;\n\n    function register(Registration memory registration) external payable;\n\n    function renew(\n        string calldata label,\n        uint256 duration,\n        bytes32 referrer\n    ) external payable;\n}\n"
    },
    "contracts/ethregistrar/ILinearPremiumPriceOracle.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ~0.8.17;\n\ninterface ILinearPremiumPriceOracle {\n    function timeUntilPremium(\n        uint256 expires,\n        uint256 amount\n    ) external view returns (uint256);\n}\n"
    },
    "contracts/ethregistrar/IPriceOracle.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.17 <0.9.0;\n\ninterface IPriceOracle {\n    struct Price {\n        uint256 base;\n        uint256 premium;\n    }\n\n    /// @dev Returns the price to register or renew a name.\n    /// @param name The name being registered or renewed.\n    /// @param expires When the name presently expires (0 if this is a new registration).\n    /// @param duration How long the name is being registered or extended for, in seconds.\n    /// @return base premium tuple of base price + premium price\n    function price(\n        string calldata name,\n        uint256 expires,\n        uint256 duration\n    ) external view returns (Price calldata);\n}\n"
    },
    "contracts/ethregistrar/LinearPremiumPriceOracle.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ~0.8.17;\n\nimport \"./SafeMath.sol\";\nimport \"./StablePriceOracle.sol\";\n\ncontract LinearPremiumPriceOracle is StablePriceOracle {\n    using SafeMath for *;\n\n    uint256 immutable GRACE_PERIOD = 90 days;\n\n    uint256 public immutable initialPremium;\n    uint256 public immutable premiumDecreaseRate;\n\n    bytes4 private constant TIME_UNTIL_PREMIUM_ID =\n        bytes4(keccak256(\"timeUntilPremium(uint,uint\"));\n\n    constructor(\n        AggregatorInterface _usdOracle,\n        uint256[] memory _rentPrices,\n        uint256 _initialPremium,\n        uint256 _premiumDecreaseRate\n    ) public StablePriceOracle(_usdOracle, _rentPrices) {\n        initialPremium = _initialPremium;\n        premiumDecreaseRate = _premiumDecreaseRate;\n    }\n\n    function _premium(\n        string memory name,\n        uint256 expires,\n        uint256 /*duration*/\n    ) internal view override returns (uint256) {\n        expires = expires.add(GRACE_PERIOD);\n        if (expires > block.timestamp) {\n            // No premium for renewals\n            return 0;\n        }\n\n        // Calculate the discount off the maximum premium\n        uint256 discount = premiumDecreaseRate.mul(\n            block.timestamp.sub(expires)\n        );\n\n        // If we've run out the premium period, return 0.\n        if (discount > initialPremium) {\n            return 0;\n        }\n\n        return initialPremium - discount;\n    }\n\n    /// @dev Returns the timestamp at which a name with the specified expiry date will have\n    ///      the specified re-registration price premium.\n    /// @param expires The timestamp at which the name expires.\n    /// @param amount The amount, in wei, the caller is willing to pay\n    /// @return The timestamp at which the premium for this domain will be `amount`.\n    function timeUntilPremium(\n        uint256 expires,\n        uint256 amount\n    ) external view returns (uint256) {\n        amount = weiToAttoUSD(amount);\n        require(amount <= initialPremium);\n\n        expires = expires.add(GRACE_PERIOD);\n\n        uint256 discount = initialPremium.sub(amount);\n        uint256 duration = discount.div(premiumDecreaseRate);\n        return expires.add(duration);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view virtual override returns (bool) {\n        return\n            (interfaceID == TIME_UNTIL_PREMIUM_ID) ||\n            super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "contracts/ethregistrar/SafeMath.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ~0.8.17;\n\n/// @title SafeMath\n/// @dev Unsigned math operations with safety checks that revert on error\nlibrary SafeMath {\n    /// @dev Multiplies two unsigned integers, reverts on overflow.\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /// @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /// @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /// @dev Adds two unsigned integers, reverts on overflow.\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /// @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n    ///      reverts when dividing by zero.\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n"
    },
    "contracts/ethregistrar/StablePriceOracle.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ~0.8.17;\n\nimport \"./IPriceOracle.sol\";\nimport \"../utils/StringUtils.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\ninterface AggregatorInterface {\n    function latestAnswer() external view returns (int256);\n}\n\n// StablePriceOracle sets a price in USD, based on an oracle.\ncontract StablePriceOracle is IPriceOracle {\n    using StringUtils for *;\n\n    // Rent in base price units by length\n    uint256 public immutable price1Letter;\n    uint256 public immutable price2Letter;\n    uint256 public immutable price3Letter;\n    uint256 public immutable price4Letter;\n    uint256 public immutable price5Letter;\n\n    // Oracle address\n    AggregatorInterface public immutable usdOracle;\n\n    event RentPriceChanged(uint256[] prices);\n\n    constructor(AggregatorInterface _usdOracle, uint256[] memory _rentPrices) {\n        usdOracle = _usdOracle;\n        price1Letter = _rentPrices[0];\n        price2Letter = _rentPrices[1];\n        price3Letter = _rentPrices[2];\n        price4Letter = _rentPrices[3];\n        price5Letter = _rentPrices[4];\n    }\n\n    function price(\n        string calldata name,\n        uint256 expires,\n        uint256 duration\n    ) external view override returns (IPriceOracle.Price memory) {\n        uint256 len = name.strlen();\n        uint256 basePrice;\n\n        if (len >= 5) {\n            basePrice = price5Letter * duration;\n        } else if (len == 4) {\n            basePrice = price4Letter * duration;\n        } else if (len == 3) {\n            basePrice = price3Letter * duration;\n        } else if (len == 2) {\n            basePrice = price2Letter * duration;\n        } else {\n            basePrice = price1Letter * duration;\n        }\n\n        return\n            IPriceOracle.Price({\n                base: attoUSDToWei(basePrice),\n                premium: attoUSDToWei(_premium(name, expires, duration))\n            });\n    }\n\n    /// @dev Returns the pricing premium in wei.\n    function premium(\n        string calldata name,\n        uint256 expires,\n        uint256 duration\n    ) external view returns (uint256) {\n        return attoUSDToWei(_premium(name, expires, duration));\n    }\n\n    /// @dev Returns the pricing premium in internal base units.\n    function _premium(\n        string memory name,\n        uint256 expires,\n        uint256 duration\n    ) internal view virtual returns (uint256) {\n        return 0;\n    }\n\n    function attoUSDToWei(uint256 amount) internal view returns (uint256) {\n        uint256 ethPrice = uint256(usdOracle.latestAnswer());\n        return (amount * 1e8) / ethPrice;\n    }\n\n    function weiToAttoUSD(uint256 amount) internal view returns (uint256) {\n        uint256 ethPrice = uint256(usdOracle.latestAnswer());\n        return (amount * ethPrice) / 1e8;\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view virtual returns (bool) {\n        return\n            interfaceID == type(IERC165).interfaceId ||\n            interfaceID == type(IPriceOracle).interfaceId;\n    }\n}\n"
    },
    "contracts/ethregistrar/StaticBulkRenewal.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ~0.8.17;\n\nimport \"./ETHRegistrarController.sol\";\nimport \"./IBulkRenewal.sol\";\nimport \"./IPriceOracle.sol\";\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\ncontract StaticBulkRenewal is IBulkRenewal {\n    ETHRegistrarController controller;\n\n    constructor(ETHRegistrarController _controller) {\n        controller = _controller;\n    }\n\n    function rentPrice(\n        string[] calldata names,\n        uint256 duration\n    ) external view override returns (uint256 total) {\n        uint256 length = names.length;\n        for (uint256 i = 0; i < length; ) {\n            IPriceOracle.Price memory price = controller.rentPrice(\n                names[i],\n                duration\n            );\n            unchecked {\n                ++i;\n                total += (price.base + price.premium);\n            }\n        }\n    }\n\n    function renewAll(\n        string[] calldata names,\n        uint256 duration,\n        bytes32 referrer\n    ) external payable override {\n        uint256 length = names.length;\n        uint256 total;\n        for (uint256 i = 0; i < length; ) {\n            IPriceOracle.Price memory price = controller.rentPrice(\n                names[i],\n                duration\n            );\n            uint256 totalPrice = price.base + price.premium;\n            controller.renew{value: totalPrice}(names[i], duration, referrer);\n            unchecked {\n                ++i;\n                total += totalPrice;\n            }\n        }\n        // Send any excess funds back\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) external pure returns (bool) {\n        return\n            interfaceID == type(IERC165).interfaceId ||\n            interfaceID == type(IBulkRenewal).interfaceId;\n    }\n}\n"
    },
    "contracts/registry/ENS.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface ENS {\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n\n    // Logged when an operator is added or removed.\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        bytes32 label,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        bytes32 label,\n        address owner\n    ) external returns (bytes32);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setOwner(bytes32 node, address owner) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function owner(bytes32 node) external view returns (address);\n\n    function resolver(bytes32 node) external view returns (address);\n\n    function ttl(bytes32 node) external view returns (uint64);\n\n    function recordExists(bytes32 node) external view returns (bool);\n\n    function isApprovedForAll(\n        address owner,\n        address operator\n    ) external view returns (bool);\n}\n"
    },
    "contracts/registry/ENSRegistry.sol": {
      "content": "pragma solidity >=0.8.4;\n\nimport \"./ENS.sol\";\n\n/// The ENS registry contract.\ncontract ENSRegistry is ENS {\n    struct Record {\n        address owner;\n        address resolver;\n        uint64 ttl;\n    }\n\n    mapping(bytes32 => Record) records;\n    mapping(address => mapping(address => bool)) operators;\n\n    // Permits modifications only by the owner of the specified node.\n    modifier authorised(bytes32 node) {\n        address owner = records[node].owner;\n        require(owner == msg.sender || operators[owner][msg.sender]);\n        _;\n    }\n\n    /// @dev Constructs a new ENS registry.\n    constructor() public {\n        records[0x0].owner = msg.sender;\n    }\n\n    /// @dev Sets the record for a node.\n    /// @param node The node to update.\n    /// @param owner The address of the new owner.\n    /// @param resolver The address of the resolver.\n    /// @param ttl The TTL in seconds.\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external virtual override {\n        setOwner(node, owner);\n        _setResolverAndTTL(node, resolver, ttl);\n    }\n\n    /// @dev Sets the record for a subnode.\n    /// @param node The parent node.\n    /// @param label The hash of the label specifying the subnode.\n    /// @param owner The address of the new owner.\n    /// @param resolver The address of the resolver.\n    /// @param ttl The TTL in seconds.\n    function setSubnodeRecord(\n        bytes32 node,\n        bytes32 label,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external virtual override {\n        bytes32 subnode = setSubnodeOwner(node, label, owner);\n        _setResolverAndTTL(subnode, resolver, ttl);\n    }\n\n    /// @dev Transfers ownership of a node to a new address. May only be called by the current owner of the node.\n    /// @param node The node to transfer ownership of.\n    /// @param owner The address of the new owner.\n    function setOwner(\n        bytes32 node,\n        address owner\n    ) public virtual override authorised(node) {\n        _setOwner(node, owner);\n        emit Transfer(node, owner);\n    }\n\n    /// @dev Transfers ownership of a subnode keccak256(node, label) to a new address. May only be called by the owner of the parent node.\n    /// @param node The parent node.\n    /// @param label The hash of the label specifying the subnode.\n    /// @param owner The address of the new owner.\n    function setSubnodeOwner(\n        bytes32 node,\n        bytes32 label,\n        address owner\n    ) public virtual override authorised(node) returns (bytes32) {\n        bytes32 subnode = keccak256(abi.encodePacked(node, label));\n        _setOwner(subnode, owner);\n        emit NewOwner(node, label, owner);\n        return subnode;\n    }\n\n    /// @dev Sets the resolver address for the specified node.\n    /// @param node The node to update.\n    /// @param resolver The address of the resolver.\n    function setResolver(\n        bytes32 node,\n        address resolver\n    ) public virtual override authorised(node) {\n        emit NewResolver(node, resolver);\n        records[node].resolver = resolver;\n    }\n\n    /// @dev Sets the TTL for the specified node.\n    /// @param node The node to update.\n    /// @param ttl The TTL in seconds.\n    function setTTL(\n        bytes32 node,\n        uint64 ttl\n    ) public virtual override authorised(node) {\n        emit NewTTL(node, ttl);\n        records[node].ttl = ttl;\n    }\n\n    /// @dev Enable or disable approval for a third party (\"operator\") to manage\n    ///      all of `msg.sender`'s ENS records. Emits the ApprovalForAll event.\n    /// @param operator Address to add to the set of authorized operators.\n    /// @param approved True if the operator is approved, false to revoke approval.\n    function setApprovalForAll(\n        address operator,\n        bool approved\n    ) external virtual override {\n        operators[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /// @dev Returns the address that owns the specified node.\n    /// @param node The specified node.\n    /// @return address of the owner.\n    function owner(\n        bytes32 node\n    ) public view virtual override returns (address) {\n        address addr = records[node].owner;\n        if (addr == address(this)) {\n            return address(0x0);\n        }\n\n        return addr;\n    }\n\n    /// @dev Returns the address of the resolver for the specified node.\n    /// @param node The specified node.\n    /// @return address of the resolver.\n    function resolver(\n        bytes32 node\n    ) public view virtual override returns (address) {\n        return records[node].resolver;\n    }\n\n    /// @dev Returns the TTL of a node, and any records associated with it.\n    /// @param node The specified node.\n    /// @return ttl of the node.\n    function ttl(bytes32 node) public view virtual override returns (uint64) {\n        return records[node].ttl;\n    }\n\n    /// @dev Returns whether a record has been imported to the registry.\n    /// @param node The specified node.\n    /// @return Bool if record exists\n    function recordExists(\n        bytes32 node\n    ) public view virtual override returns (bool) {\n        return records[node].owner != address(0x0);\n    }\n\n    /// @dev Query if an address is an authorized operator for another address.\n    /// @param owner The address that owns the records.\n    /// @param operator The address that acts on behalf of the owner.\n    /// @return True if `operator` is an approved operator for `owner`, false otherwise.\n    function isApprovedForAll(\n        address owner,\n        address operator\n    ) external view virtual override returns (bool) {\n        return operators[owner][operator];\n    }\n\n    function _setOwner(bytes32 node, address owner) internal virtual {\n        records[node].owner = owner;\n    }\n\n    function _setResolverAndTTL(\n        bytes32 node,\n        address resolver,\n        uint64 ttl\n    ) internal {\n        if (resolver != records[node].resolver) {\n            records[node].resolver = resolver;\n            emit NewResolver(node, resolver);\n        }\n\n        if (ttl != records[node].ttl) {\n            records[node].ttl = ttl;\n            emit NewTTL(node, ttl);\n        }\n    }\n}\n"
    },
    "contracts/registry/ENSRegistryWithFallback.sol": {
      "content": "pragma solidity >=0.8.4;\n\nimport \"./ENS.sol\";\nimport \"./ENSRegistry.sol\";\n\n/// The ENS registry contract.\ncontract ENSRegistryWithFallback is ENSRegistry {\n    ENS public old;\n\n    /// @dev Constructs a new ENS registrar.\n    constructor(ENS _old) public ENSRegistry() {\n        old = _old;\n    }\n\n    /// @dev Returns the address of the resolver for the specified node.\n    /// @param node The specified node.\n    /// @return address of the resolver.\n    function resolver(bytes32 node) public view override returns (address) {\n        if (!recordExists(node)) {\n            return old.resolver(node);\n        }\n\n        return super.resolver(node);\n    }\n\n    /// @dev Returns the address that owns the specified node.\n    /// @param node The specified node.\n    /// @return address of the owner.\n    function owner(bytes32 node) public view override returns (address) {\n        if (!recordExists(node)) {\n            return old.owner(node);\n        }\n\n        return super.owner(node);\n    }\n\n    /// @dev Returns the TTL of a node, and any records associated with it.\n    /// @param node The specified node.\n    /// @return ttl of the node.\n    function ttl(bytes32 node) public view override returns (uint64) {\n        if (!recordExists(node)) {\n            return old.ttl(node);\n        }\n\n        return super.ttl(node);\n    }\n\n    function _setOwner(bytes32 node, address owner) internal override {\n        address addr = owner;\n        if (addr == address(0x0)) {\n            addr = address(this);\n        }\n\n        super._setOwner(node, addr);\n    }\n}\n"
    },
    "contracts/registry/FIFSRegistrar.sol": {
      "content": "pragma solidity >=0.8.4;\n\nimport \"./ENS.sol\";\n\n/// A registrar that allocates subdomains to the first person to claim them.\ncontract FIFSRegistrar {\n    ENS ens;\n    bytes32 rootNode;\n\n    modifier only_owner(bytes32 label) {\n        address currentOwner = ens.owner(\n            keccak256(abi.encodePacked(rootNode, label))\n        );\n        require(currentOwner == address(0x0) || currentOwner == msg.sender);\n        _;\n    }\n\n    /// Constructor.\n    /// @param ensAddr The address of the ENS registry.\n    /// @param node The node that this registrar administers.\n    constructor(ENS ensAddr, bytes32 node) public {\n        ens = ensAddr;\n        rootNode = node;\n    }\n\n    /// Register a name, or change the owner of an existing registration.\n    /// @param label The hash of the label to register.\n    /// @param owner The address of the new owner.\n    function register(bytes32 label, address owner) public only_owner(label) {\n        ens.setSubnodeOwner(rootNode, label, owner);\n    }\n}\n"
    },
    "contracts/registry/TestRegistrar.sol": {
      "content": "pragma solidity >=0.8.4;\n\nimport \"./ENS.sol\";\n\n/// A registrar that allocates subdomains to the first person to claim them, but\n/// expires registrations a fixed period after they're initially claimed.\ncontract TestRegistrar {\n    uint256 constant registrationPeriod = 4 weeks;\n\n    ENS public immutable ens;\n    bytes32 public immutable rootNode;\n    mapping(bytes32 => uint256) public expiryTimes;\n\n    /// Constructor.\n    /// @param ensAddr The address of the ENS registry.\n    /// @param node The node that this registrar administers.\n    constructor(ENS ensAddr, bytes32 node) {\n        ens = ensAddr;\n        rootNode = node;\n    }\n\n    /// Register a name that's not currently registered\n    /// @param label The hash of the label to register.\n    /// @param owner The address of the new owner.\n    function register(bytes32 label, address owner) public {\n        require(expiryTimes[label] < block.timestamp);\n\n        expiryTimes[label] = block.timestamp + registrationPeriod;\n        ens.setSubnodeOwner(rootNode, label, owner);\n    }\n}\n"
    },
    "contracts/resolvers/IMulticallable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IMulticallable {\n    function multicall(\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    function multicallWithNodeCheck(\n        bytes32,\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n}\n"
    },
    "contracts/resolvers/mocks/DummyNameWrapper.sol": {
      "content": "pragma solidity ^0.8.4;\n\n/// @dev Implements a dummy NameWrapper which returns the caller's address\ncontract DummyNameWrapper {\n    function ownerOf(uint256 /* id */) public view returns (address) {\n        return tx.origin;\n    }\n}\n"
    },
    "contracts/resolvers/Multicallable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./IMulticallable.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nabstract contract Multicallable is IMulticallable, ERC165 {\n    function _multicall(\n        bytes32 nodehash,\n        bytes[] calldata data\n    ) internal returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            if (nodehash != bytes32(0)) {\n                bytes32 txNamehash = bytes32(data[i][4:36]);\n                require(\n                    txNamehash == nodehash,\n                    \"multicall: All records must have a matching namehash\"\n                );\n            }\n            (bool success, bytes memory result) = address(this).delegatecall(\n                data[i]\n            );\n            require(success);\n            results[i] = result;\n        }\n        return results;\n    }\n\n    // This function provides an extra security check when called\n    // from priviledged contracts (such as EthRegistrarController)\n    // that can set records on behalf of the node owners\n    function multicallWithNodeCheck(\n        bytes32 nodehash,\n        bytes[] calldata data\n    ) external returns (bytes[] memory results) {\n        return _multicall(nodehash, data);\n    }\n\n    function multicall(\n        bytes[] calldata data\n    ) public override returns (bytes[] memory results) {\n        return _multicall(bytes32(0), data);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view virtual override returns (bool) {\n        return\n            interfaceID == type(IMulticallable).interfaceId ||\n            super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "contracts/resolvers/OwnedResolver.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./profiles/ABIResolver.sol\";\nimport \"./profiles/AddrResolver.sol\";\nimport \"./profiles/ContentHashResolver.sol\";\nimport \"./profiles/DNSResolver.sol\";\nimport \"./profiles/InterfaceResolver.sol\";\nimport \"./profiles/NameResolver.sol\";\nimport \"./profiles/PubkeyResolver.sol\";\nimport \"./profiles/TextResolver.sol\";\nimport \"./profiles/ExtendedResolver.sol\";\n\n/// A simple resolver anyone can use; only allows the owner of a node to set its\n/// address.\ncontract OwnedResolver is\n    Ownable,\n    ABIResolver,\n    AddrResolver,\n    ContentHashResolver,\n    DNSResolver,\n    InterfaceResolver,\n    NameResolver,\n    PubkeyResolver,\n    TextResolver,\n    ExtendedResolver\n{\n    function isAuthorised(bytes32) internal view override returns (bool) {\n        return msg.sender == owner();\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    )\n        public\n        view\n        virtual\n        override(\n            ABIResolver,\n            AddrResolver,\n            ContentHashResolver,\n            DNSResolver,\n            InterfaceResolver,\n            NameResolver,\n            PubkeyResolver,\n            TextResolver\n        )\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "contracts/resolvers/profiles/ABIResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"./IABIResolver.sol\";\nimport \"../ResolverBase.sol\";\n\nabstract contract ABIResolver is IABIResolver, ResolverBase {\n    mapping(uint64 => mapping(bytes32 => mapping(uint256 => bytes))) versionable_abis;\n\n    /// Sets the ABI associated with an ENS node.\n    /// Nodes may have one ABI of each content type. To remove an ABI, set it to\n    /// the empty string.\n    /// @param node The node to update.\n    /// @param contentType The content type of the ABI\n    /// @param data The ABI data.\n    function setABI(\n        bytes32 node,\n        uint256 contentType,\n        bytes calldata data\n    ) external virtual authorised(node) {\n        // Content types must be powers of 2\n        require(((contentType - 1) & contentType) == 0);\n\n        versionable_abis[recordVersions[node]][node][contentType] = data;\n        emit ABIChanged(node, contentType);\n    }\n\n    /// Returns the ABI associated with an ENS node.\n    /// Defined in EIP205.\n    /// @param node The ENS node to query\n    /// @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\n    /// @return contentType The content type of the return value\n    /// @return data The ABI data\n    function ABI(\n        bytes32 node,\n        uint256 contentTypes\n    ) external view virtual override returns (uint256, bytes memory) {\n        mapping(uint256 => bytes) storage abiset = versionable_abis[\n            recordVersions[node]\n        ][node];\n\n        for (\n            uint256 contentType = 1;\n            contentType > 0 && contentType <= contentTypes;\n            contentType <<= 1\n        ) {\n            if (\n                (contentType & contentTypes) != 0 &&\n                abiset[contentType].length > 0\n            ) {\n                return (contentType, abiset[contentType]);\n            }\n        }\n\n        return (0, bytes(\"\"));\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view virtual override returns (bool) {\n        return\n            interfaceID == type(IABIResolver).interfaceId ||\n            super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "contracts/resolvers/profiles/AddrResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport {ResolverBase, IERC165} from \"../ResolverBase.sol\";\nimport {IAddrResolver} from \"./IAddrResolver.sol\";\nimport {IAddressResolver} from \"./IAddressResolver.sol\";\nimport {IHasAddressResolver} from \"./IHasAddressResolver.sol\";\nimport {ENSIP19, COIN_TYPE_ETH, COIN_TYPE_DEFAULT} from \"../../utils/ENSIP19.sol\";\n\nabstract contract AddrResolver is\n    IAddrResolver,\n    IAddressResolver,\n    IHasAddressResolver,\n    ResolverBase\n{\n    mapping(uint64 => mapping(bytes32 => mapping(uint256 => bytes))) versionable_addresses;\n\n    /// @notice The supplied address could not be converted to `address`.\n    /// @dev Error selector: `0x8d666f60`\n    error InvalidEVMAddress(bytes addressBytes);\n\n    /// @notice Set `addr(60)` of the associated ENS node.\n    ///         `address(0)` is stored as `new bytes(20)`.\n    /// @param node The node to update.\n    /// @param _addr The address to set.\n    function setAddr(\n        bytes32 node,\n        address _addr\n    ) external virtual authorised(node) {\n        setAddr(node, COIN_TYPE_ETH, abi.encodePacked(_addr));\n    }\n\n    /// @notice Get `addr(60)` as `address` of the associated ENS node.\n    /// @param node The node to query.\n    /// @return The associated address.\n    function addr(\n        bytes32 node\n    ) public view virtual override returns (address payable) {\n        return payable(address(bytes20(addr(node, COIN_TYPE_ETH))));\n    }\n\n    /// @notice Set the address for coin type of the associated ENS node.\n    ///         Reverts `InvalidEVMAddress` if coin type is EVM and not 0 or 20 bytes.\n    /// @param node The node to update.\n    /// @param coinType The coin type.\n    /// @param addressBytes The address to set.\n    function setAddr(\n        bytes32 node,\n        uint256 coinType,\n        bytes memory addressBytes\n    ) public virtual authorised(node) {\n        if (\n            addressBytes.length != 0 &&\n            addressBytes.length != 20 &&\n            ENSIP19.isEVMCoinType(coinType)\n        ) {\n            revert InvalidEVMAddress(addressBytes);\n        }\n        emit AddressChanged(node, coinType, addressBytes);\n        if (coinType == COIN_TYPE_ETH) {\n            emit AddrChanged(node, address(bytes20(addressBytes)));\n        }\n        versionable_addresses[recordVersions[node]][node][\n            coinType\n        ] = addressBytes;\n    }\n\n    /// @notice Get the address for coin type of the associated ENS node.\n    ///         If coin type is EVM and empty, defaults to `addr(COIN_TYPE_DEFAULT)`.\n    /// @param node The node to query.\n    /// @param coinType The coin type.\n    /// @return addressBytes The assocated address.\n    function addr(\n        bytes32 node,\n        uint256 coinType\n    ) public view virtual override returns (bytes memory addressBytes) {\n        mapping(uint256 => bytes) storage addrs = versionable_addresses[\n            recordVersions[node]\n        ][node];\n        addressBytes = addrs[coinType];\n        if (\n            addressBytes.length == 0 && ENSIP19.chainFromCoinType(coinType) > 0\n        ) {\n            addressBytes = addrs[COIN_TYPE_DEFAULT];\n        }\n    }\n\n    /// @inheritdoc IHasAddressResolver\n    function hasAddr(\n        bytes32 node,\n        uint256 coinType\n    ) external view returns (bool) {\n        return\n            versionable_addresses[recordVersions[node]][node][coinType].length >\n            0;\n    }\n\n    /// @inheritdoc IERC165\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override returns (bool) {\n        return\n            type(IAddrResolver).interfaceId == interfaceId ||\n            type(IAddressResolver).interfaceId == interfaceId ||\n            type(IHasAddressResolver).interfaceId == interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/resolvers/profiles/ContentHashResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"../ResolverBase.sol\";\nimport \"./IContentHashResolver.sol\";\n\nabstract contract ContentHashResolver is IContentHashResolver, ResolverBase {\n    mapping(uint64 => mapping(bytes32 => bytes)) versionable_hashes;\n\n    /// Sets the contenthash associated with an ENS node.\n    /// May only be called by the owner of that node in the ENS registry.\n    /// @param node The node to update.\n    /// @param hash The contenthash to set\n    function setContenthash(\n        bytes32 node,\n        bytes calldata hash\n    ) external virtual authorised(node) {\n        versionable_hashes[recordVersions[node]][node] = hash;\n        emit ContenthashChanged(node, hash);\n    }\n\n    /// Returns the contenthash associated with an ENS node.\n    /// @param node The ENS node to query.\n    /// @return The associated contenthash.\n    function contenthash(\n        bytes32 node\n    ) external view virtual override returns (bytes memory) {\n        return versionable_hashes[recordVersions[node]][node];\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view virtual override returns (bool) {\n        return\n            interfaceID == type(IContentHashResolver).interfaceId ||\n            super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "contracts/resolvers/profiles/DNSResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"../ResolverBase.sol\";\nimport \"../../dnssec-oracle/RRUtils.sol\";\nimport \"./IDNSRecordResolver.sol\";\nimport \"./IDNSZoneResolver.sol\";\n\nabstract contract DNSResolver is\n    IDNSRecordResolver,\n    IDNSZoneResolver,\n    ResolverBase\n{\n    using RRUtils for *;\n    using BytesUtils for bytes;\n\n    // Zone hashes for the domains.\n    // A zone hash is an EIP-1577 content hash in binary format that should point to a\n    // resource containing a single zonefile.\n    // node => contenthash\n    mapping(uint64 => mapping(bytes32 => bytes)) private versionable_zonehashes;\n\n    // The records themselves.  Stored as binary RRSETs\n    // node => version => name => resource => data\n    mapping(uint64 => mapping(bytes32 => mapping(bytes32 => mapping(uint16 => bytes))))\n        private versionable_records;\n\n    // Count of number of entries for a given name.  Required for DNS resolvers\n    // when resolving wildcards.\n    // node => version => name => number of records\n    mapping(uint64 => mapping(bytes32 => mapping(bytes32 => uint16)))\n        private versionable_nameEntriesCount;\n\n    /// Set one or more DNS records.  Records are supplied in wire-format.\n    /// Records with the same node/name/resource must be supplied one after the\n    /// other to ensure the data is updated correctly. For example, if the data\n    /// was supplied:\n    ///     a.example.com IN A 1.2.3.4\n    ///     a.example.com IN A 5.6.7.8\n    ///     www.example.com IN CNAME a.example.com.\n    /// then this would store the two A records for a.example.com correctly as a\n    /// single RRSET, however if the data was supplied:\n    ///     a.example.com IN A 1.2.3.4\n    ///     www.example.com IN CNAME a.example.com.\n    ///     a.example.com IN A 5.6.7.8\n    /// then this would store the first A record, the CNAME, then the second A\n    /// record which would overwrite the first.\n    ///\n    /// @param node the namehash of the node for which to set the records\n    /// @param data the DNS wire format records to set\n    function setDNSRecords(\n        bytes32 node,\n        bytes calldata data\n    ) external virtual authorised(node) {\n        uint16 resource = 0;\n        uint256 offset = 0;\n        bytes memory name;\n        bytes memory value;\n        bytes32 nameHash;\n        uint64 version = recordVersions[node];\n        // Iterate over the data to add the resource records\n        for (\n            RRUtils.RRIterator memory iter = data.iterateRRs(0);\n            !iter.done();\n            iter.next()\n        ) {\n            if (resource == 0) {\n                resource = iter.dnstype;\n                name = iter.name();\n                nameHash = keccak256(abi.encodePacked(name));\n                value = bytes(iter.rdata());\n            } else {\n                bytes memory newName = iter.name();\n                if (resource != iter.dnstype || !name.equals(newName)) {\n                    setDNSRRSet(\n                        node,\n                        name,\n                        resource,\n                        data,\n                        offset,\n                        iter.offset - offset,\n                        value.length == 0,\n                        version\n                    );\n                    resource = iter.dnstype;\n                    offset = iter.offset;\n                    name = newName;\n                    nameHash = keccak256(name);\n                    value = bytes(iter.rdata());\n                }\n            }\n        }\n        if (name.length > 0) {\n            setDNSRRSet(\n                node,\n                name,\n                resource,\n                data,\n                offset,\n                data.length - offset,\n                value.length == 0,\n                version\n            );\n        }\n    }\n\n    /// Obtain a DNS record.\n    /// @param node the namehash of the node for which to fetch the record\n    /// @param name the keccak-256 hash of the fully-qualified name for which to fetch the record\n    /// @param resource the ID of the resource as per https://en.wikipedia.org/wiki/List_of_DNS_record_types\n    /// @return the DNS record in wire format if present, otherwise empty\n    function dnsRecord(\n        bytes32 node,\n        bytes32 name,\n        uint16 resource\n    ) public view virtual override returns (bytes memory) {\n        return versionable_records[recordVersions[node]][node][name][resource];\n    }\n\n    /// Check if a given node has records.\n    /// @param node the namehash of the node for which to check the records\n    /// @param name the namehash of the node for which to check the records\n    function hasDNSRecords(\n        bytes32 node,\n        bytes32 name\n    ) public view virtual returns (bool) {\n        return (versionable_nameEntriesCount[recordVersions[node]][node][\n            name\n        ] != 0);\n    }\n\n    /// setZonehash sets the hash for the zone.\n    /// May only be called by the owner of that node in the ENS registry.\n    /// @param node The node to update.\n    /// @param hash The zonehash to set\n    function setZonehash(\n        bytes32 node,\n        bytes calldata hash\n    ) external virtual authorised(node) {\n        uint64 currentRecordVersion = recordVersions[node];\n        bytes memory oldhash = versionable_zonehashes[currentRecordVersion][\n            node\n        ];\n        versionable_zonehashes[currentRecordVersion][node] = hash;\n        emit DNSZonehashChanged(node, oldhash, hash);\n    }\n\n    /// zonehash obtains the hash for the zone.\n    /// @param node The ENS node to query.\n    /// @return The associated contenthash.\n    function zonehash(\n        bytes32 node\n    ) external view virtual override returns (bytes memory) {\n        return versionable_zonehashes[recordVersions[node]][node];\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view virtual override returns (bool) {\n        return\n            interfaceID == type(IDNSRecordResolver).interfaceId ||\n            interfaceID == type(IDNSZoneResolver).interfaceId ||\n            super.supportsInterface(interfaceID);\n    }\n\n    function setDNSRRSet(\n        bytes32 node,\n        bytes memory name,\n        uint16 resource,\n        bytes memory data,\n        uint256 offset,\n        uint256 size,\n        bool deleteRecord,\n        uint64 version\n    ) private {\n        bytes32 nameHash = keccak256(name);\n        bytes memory rrData = data.substring(offset, size);\n        if (deleteRecord) {\n            if (\n                versionable_records[version][node][nameHash][resource].length !=\n                0\n            ) {\n                versionable_nameEntriesCount[version][node][nameHash]--;\n            }\n            delete (versionable_records[version][node][nameHash][resource]);\n            emit DNSRecordDeleted(node, name, resource);\n        } else {\n            if (\n                versionable_records[version][node][nameHash][resource].length ==\n                0\n            ) {\n                versionable_nameEntriesCount[version][node][nameHash]++;\n            }\n            versionable_records[version][node][nameHash][resource] = rrData;\n            emit DNSRecordChanged(node, name, resource, rrData);\n        }\n    }\n}\n"
    },
    "contracts/resolvers/profiles/ExtendedDNSResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"../../resolvers/profiles/IExtendedDNSResolver.sol\";\nimport \"../../resolvers/profiles/IAddressResolver.sol\";\nimport \"../../resolvers/profiles/IAddrResolver.sol\";\nimport \"../../resolvers/profiles/ITextResolver.sol\";\nimport \"../../utils/HexUtils.sol\";\nimport \"../../utils/BytesUtils.sol\";\n\n/// @dev Resolves names on ENS by interpreting record data stored in a DNS TXT record.\n///      This resolver implements the IExtendedDNSResolver interface, meaning that when\n///      a DNS name specifies it as the resolver via a TXT record, this resolver's\n///      resolve() method is invoked, and is passed any additional information from that\n///      text record. This resolver implements a simple text parser allowing a variety\n///      of records to be specified in text, which will then be used to resolve the name\n///      in ENS.\n///\n///      To use this, set a TXT record on your DNS name in the following format:\n///          ENS1 <address or name of ExtendedDNSResolver> <record data>\n///\n///      For example:\n///          ENS1 2.dnsname.ens.eth a[60]=0x1234...\n///\n///      The record data consists of a series of key=value pairs, separated by spaces. Keys\n///      may have an optional argument in square brackets, and values may be either unquoted\n///       - in which case they may not contain spaces - or single-quoted. Single quotes in\n///      a quoted value may be backslash-escaped.\n///\n///\n///                                       ┌────────┐\n///                                       │ ┌───┐  │\n///        ┌──────────────────────────────┴─┤\" \"│◄─┴────────────────────────────────────────┐\n///        │                                └───┘                                           │\n///        │  ┌───┐    ┌───┐    ┌───┐    ┌───┐    ┌───┐    ┌───┐    ┌────────────┐    ┌───┐ │\n///      ^─┴─►│key├─┬─►│\"[\"├───►│arg├───►│\"]\"├─┬─►│\"=\"├─┬─►│\"'\"├───►│quoted_value├───►│\"'\"├─┼─$\n///           └───┘ │  └───┘    └───┘    └───┘ │  └───┘ │  └───┘    └────────────┘    └───┘ │\n///                 └──────────────────────────┘        │          ┌──────────────┐         │\n///                                                     └─────────►│unquoted_value├─────────┘\n///                                                                └──────────────┘\n///\n///      Record types:\n///       - a[<coinType>] - Specifies how an `addr()` request should be resolved for the specified\n///         `coinType`. Ethereum has `coinType` 60. The value must be 0x-prefixed hexadecimal, and will\n///         be returned unmodified; this means that non-EVM addresses will need to be translated\n///         into binary format and then encoded in hex.\n///         Examples:\n///          - a[60]=0xFe89cc7aBB2C4183683ab71653C4cdc9B02D44b7\n///          - a[0]=0x00149010587f8364b964fcaa70687216b53bd2cbd798\n///       - a[e<chainId>] - Specifies how an `addr()` request should be resolved for the specified\n///         `chainId`. The value must be 0x-prefixed hexadecimal. When encoding an address for an\n///         EVM-based cryptocurrency that uses a chainId instead of a coinType, this syntax *must*\n///         be used in place of the coin type - eg, Optimism is `a[e10]`, not `a[2147483658]`.\n///         A list of supported cryptocurrencies for both syntaxes can be found here:\n///           https://github.com/ensdomains/address-encoder/blob/master/docs/supported-cryptocurrencies.md\n///         Example:\n///          - a[e10]=0xFe89cc7aBB2C4183683ab71653C4cdc9B02D44b7\n///       - t[<key>] - Specifies how a `text()` request should be resolved for the specified `key`.\n///         Examples:\n///          - t[com.twitter]=nicksdjohnson\n///          - t[url]='https://ens.domains/'\n///          - t[note]='I\\'m great'\ncontract ExtendedDNSResolver is IExtendedDNSResolver, IERC165 {\n    using HexUtils for *;\n    using BytesUtils for *;\n    using Strings for *;\n\n    uint256 private constant COIN_TYPE_ETH = 60;\n\n    error NotImplemented();\n    error InvalidAddressFormat(bytes addr);\n\n    function supportsInterface(\n        bytes4 interfaceId\n    ) external view virtual override returns (bool) {\n        return interfaceId == type(IExtendedDNSResolver).interfaceId;\n    }\n\n    function resolve(\n        bytes calldata /* name */,\n        bytes calldata data,\n        bytes calldata context\n    ) external pure override returns (bytes memory) {\n        bytes4 selector = bytes4(data);\n        if (selector == IAddrResolver.addr.selector) {\n            return _resolveAddr(context);\n        } else if (selector == IAddressResolver.addr.selector) {\n            return _resolveAddress(data, context);\n        } else if (selector == ITextResolver.text.selector) {\n            return _resolveText(data, context);\n        }\n        revert NotImplemented();\n    }\n\n    function _resolveAddress(\n        bytes calldata data,\n        bytes calldata context\n    ) internal pure returns (bytes memory) {\n        (, uint256 coinType) = abi.decode(data[4:], (bytes32, uint256));\n        bytes memory value;\n        // Per https://docs.ens.domains/ensip/11#specification\n        if (coinType & 0x80000000 != 0) {\n            value = _findValue(\n                context,\n                bytes.concat(\n                    \"a[e\",\n                    bytes((coinType & 0x7fffffff).toString()),\n                    \"]=\"\n                )\n            );\n        } else {\n            value = _findValue(\n                context,\n                bytes.concat(\"a[\", bytes(coinType.toString()), \"]=\")\n            );\n        }\n        if (value.length == 0) {\n            return value;\n        }\n        (address record, bool valid) = value.hexToAddress(2, value.length);\n        if (!valid) revert InvalidAddressFormat(value);\n        return abi.encode(record);\n    }\n\n    function _resolveAddr(\n        bytes calldata context\n    ) internal pure returns (bytes memory) {\n        bytes memory value = _findValue(context, \"a[60]=\");\n        if (value.length == 0) {\n            return value;\n        }\n        (address record, bool valid) = value.hexToAddress(2, value.length);\n        if (!valid) revert InvalidAddressFormat(value);\n        return abi.encode(record);\n    }\n\n    function _resolveText(\n        bytes calldata data,\n        bytes calldata context\n    ) internal pure returns (bytes memory) {\n        (, string memory key) = abi.decode(data[4:], (bytes32, string));\n        bytes memory value = _findValue(\n            context,\n            bytes.concat(\"t[\", bytes(key), \"]=\")\n        );\n        return abi.encode(value);\n    }\n\n    uint256 constant STATE_START = 0;\n    uint256 constant STATE_IGNORED_KEY = 1;\n    uint256 constant STATE_IGNORED_KEY_ARG = 2;\n    uint256 constant STATE_VALUE = 3;\n    uint256 constant STATE_QUOTED_VALUE = 4;\n    uint256 constant STATE_UNQUOTED_VALUE = 5;\n    uint256 constant STATE_IGNORED_VALUE = 6;\n    uint256 constant STATE_IGNORED_QUOTED_VALUE = 7;\n    uint256 constant STATE_IGNORED_UNQUOTED_VALUE = 8;\n\n    /// @dev Implements a DFA to parse the text record, looking for an entry\n    ///      matching `key`.\n    /// @param data The text record to parse.\n    /// @param key The exact key to search for.\n    /// @return value The value if found, or an empty string if `key` does not exist.\n    function _findValue(\n        bytes memory data,\n        bytes memory key\n    ) internal pure returns (bytes memory value) {\n        // Here we use a simple state machine to parse the text record. We\n        // process characters one at a time; each character can trigger a\n        // transition to a new state, or terminate the DFA and return a value.\n        // For states that expect to process a number of tokens, we use\n        // inner loops for efficiency reasons, to avoid the need to go\n        // through the outer loop and switch statement for every character.\n        uint256 state = STATE_START;\n        uint256 len = data.length;\n        for (uint256 i = 0; i < len; ) {\n            if (state == STATE_START) {\n                // Look for a matching key.\n                if (data.equals(i, key, 0, key.length)) {\n                    i += key.length;\n                    state = STATE_VALUE;\n                } else {\n                    state = STATE_IGNORED_KEY;\n                }\n            } else if (state == STATE_IGNORED_KEY) {\n                for (; i < len; i++) {\n                    if (data[i] == \"=\") {\n                        state = STATE_IGNORED_VALUE;\n                        i += 1;\n                        break;\n                    } else if (data[i] == \"[\") {\n                        state = STATE_IGNORED_KEY_ARG;\n                        i += 1;\n                        break;\n                    }\n                }\n            } else if (state == STATE_IGNORED_KEY_ARG) {\n                for (; i < len; i++) {\n                    if (data[i] == \"]\") {\n                        state = STATE_IGNORED_VALUE;\n                        i += 1;\n                        if (data[i] == \"=\") {\n                            i += 1;\n                        }\n                        break;\n                    }\n                }\n            } else if (state == STATE_VALUE) {\n                if (data[i] == \"'\") {\n                    state = STATE_QUOTED_VALUE;\n                    i += 1;\n                } else {\n                    state = STATE_UNQUOTED_VALUE;\n                }\n            } else if (state == STATE_QUOTED_VALUE) {\n                uint256 start = i;\n                uint256 valueLen = 0;\n                bool escaped = false;\n                for (; i < len; i++) {\n                    if (escaped) {\n                        data[start + valueLen] = data[i];\n                        valueLen += 1;\n                        escaped = false;\n                    } else {\n                        if (data[i] == \"\\\\\") {\n                            escaped = true;\n                        } else if (data[i] == \"'\") {\n                            return data.substring(start, valueLen);\n                        } else {\n                            data[start + valueLen] = data[i];\n                            valueLen += 1;\n                        }\n                    }\n                }\n            } else if (state == STATE_UNQUOTED_VALUE) {\n                uint256 start = i;\n                for (; i < len; i++) {\n                    if (data[i] == \" \") {\n                        return data.substring(start, i - start);\n                    }\n                }\n                return data.substring(start, len - start);\n            } else if (state == STATE_IGNORED_VALUE) {\n                if (data[i] == \"'\") {\n                    state = STATE_IGNORED_QUOTED_VALUE;\n                    i += 1;\n                } else {\n                    state = STATE_IGNORED_UNQUOTED_VALUE;\n                }\n            } else if (state == STATE_IGNORED_QUOTED_VALUE) {\n                bool escaped = false;\n                for (; i < len; i++) {\n                    if (escaped) {\n                        escaped = false;\n                    } else {\n                        if (data[i] == \"\\\\\") {\n                            escaped = true;\n                        } else if (data[i] == \"'\") {\n                            i += 1;\n                            while (data[i] == \" \") {\n                                i += 1;\n                            }\n                            state = STATE_START;\n                            break;\n                        }\n                    }\n                }\n            } else {\n                assert(state == STATE_IGNORED_UNQUOTED_VALUE);\n                for (; i < len; i++) {\n                    if (data[i] == \" \") {\n                        while (data[i] == \" \") {\n                            i += 1;\n                        }\n                        state = STATE_START;\n                        break;\n                    }\n                }\n            }\n        }\n        return \"\";\n    }\n}\n"
    },
    "contracts/resolvers/profiles/ExtendedResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ncontract ExtendedResolver {\n    function resolve(\n        bytes memory /* name */,\n        bytes memory data\n    ) external view returns (bytes memory) {\n        (bool success, bytes memory result) = address(this).staticcall(data);\n        if (success) {\n            return result;\n        } else {\n            // Revert with the reason provided by the call\n            assembly {\n                revert(add(result, 0x20), mload(result))\n            }\n        }\n    }\n}\n"
    },
    "contracts/resolvers/profiles/IABIResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IABIResolver {\n    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\n\n    /// Returns the ABI associated with an ENS node.\n    /// Defined in EIP205.\n    /// @param node The ENS node to query\n    /// @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\n    /// @return contentType The content type of the return value\n    /// @return data The ABI data\n    function ABI(\n        bytes32 node,\n        uint256 contentTypes\n    ) external view returns (uint256, bytes memory);\n}\n"
    },
    "contracts/resolvers/profiles/IAddressResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\n/// Interface for the new (multicoin) addr function.\ninterface IAddressResolver {\n    event AddressChanged(\n        bytes32 indexed node,\n        uint256 coinType,\n        bytes newAddress\n    );\n\n    function addr(\n        bytes32 node,\n        uint256 coinType\n    ) external view returns (bytes memory);\n}\n"
    },
    "contracts/resolvers/profiles/IAddrResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\n/// Interface for the legacy (ETH-only) addr function.\ninterface IAddrResolver {\n    event AddrChanged(bytes32 indexed node, address a);\n\n    /// Returns the address associated with an ENS node.\n    /// @param node The ENS node to query.\n    /// @return The associated address.\n    function addr(bytes32 node) external view returns (address payable);\n}\n"
    },
    "contracts/resolvers/profiles/IContentHashResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IContentHashResolver {\n    event ContenthashChanged(bytes32 indexed node, bytes hash);\n\n    /// Returns the contenthash associated with an ENS node.\n    /// @param node The ENS node to query.\n    /// @return The associated contenthash.\n    function contenthash(bytes32 node) external view returns (bytes memory);\n}\n"
    },
    "contracts/resolvers/profiles/IDNSRecordResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IDNSRecordResolver {\n    // DNSRecordChanged is emitted whenever a given node/name/resource's RRSET is updated.\n    event DNSRecordChanged(\n        bytes32 indexed node,\n        bytes name,\n        uint16 resource,\n        bytes record\n    );\n    // DNSRecordDeleted is emitted whenever a given node/name/resource's RRSET is deleted.\n    event DNSRecordDeleted(bytes32 indexed node, bytes name, uint16 resource);\n\n    /// Obtain a DNS record.\n    /// @param node the namehash of the node for which to fetch the record\n    /// @param name the keccak-256 hash of the fully-qualified name for which to fetch the record\n    /// @param resource the ID of the resource as per https://en.wikipedia.org/wiki/List_of_DNS_record_types\n    /// @return the DNS record in wire format if present, otherwise empty\n    function dnsRecord(\n        bytes32 node,\n        bytes32 name,\n        uint16 resource\n    ) external view returns (bytes memory);\n}\n"
    },
    "contracts/resolvers/profiles/IDNSZoneResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IDNSZoneResolver {\n    // DNSZonehashChanged is emitted whenever a given node's zone hash is updated.\n    event DNSZonehashChanged(\n        bytes32 indexed node,\n        bytes lastzonehash,\n        bytes zonehash\n    );\n\n    /// zonehash obtains the hash for the zone.\n    /// @param node The ENS node to query.\n    /// @return The associated contenthash.\n    function zonehash(bytes32 node) external view returns (bytes memory);\n}\n"
    },
    "contracts/resolvers/profiles/IExtendedDNSResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IExtendedDNSResolver {\n    function resolve(\n        bytes memory name,\n        bytes memory data,\n        bytes memory context\n    ) external view returns (bytes memory);\n}\n"
    },
    "contracts/resolvers/profiles/IExtendedResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IExtendedResolver {\n    function resolve(\n        bytes memory name,\n        bytes memory data\n    ) external view returns (bytes memory);\n}\n"
    },
    "contracts/resolvers/profiles/IHasAddressResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IHasAddressResolver {\n    /// @notice Determine if an addresss is stored for the coin type of the associated ENS node.\n    /// @param node The node to query.\n    /// @param coinType The coin type.\n    /// @return True if the associated address is not empty.\n    function hasAddr(\n        bytes32 node,\n        uint256 coinType\n    ) external view returns (bool);\n}\n"
    },
    "contracts/resolvers/profiles/IInterfaceResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IInterfaceResolver {\n    event InterfaceChanged(\n        bytes32 indexed node,\n        bytes4 indexed interfaceID,\n        address implementer\n    );\n\n    /// Returns the address of a contract that implements the specified interface for this name.\n    /// If an implementer has not been set for this interfaceID and name, the resolver will query\n    /// the contract at `addr()`. If `addr()` is set, a contract exists at that address, and that\n    /// contract implements EIP165 and returns `true` for the specified interfaceID, its address\n    /// will be returned.\n    /// @param node The ENS node to query.\n    /// @param interfaceID The EIP 165 interface ID to check for.\n    /// @return The address that implements this interface, or 0 if the interface is unsupported.\n    function interfaceImplementer(\n        bytes32 node,\n        bytes4 interfaceID\n    ) external view returns (address);\n}\n"
    },
    "contracts/resolvers/profiles/INameResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface INameResolver {\n    event NameChanged(bytes32 indexed node, string name);\n\n    /// Returns the name associated with an ENS node, for reverse records.\n    /// Defined in EIP181.\n    /// @param node The ENS node to query.\n    /// @return The associated name.\n    function name(bytes32 node) external view returns (string memory);\n}\n"
    },
    "contracts/resolvers/profiles/InterfaceResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"../ResolverBase.sol\";\nimport \"./AddrResolver.sol\";\nimport \"./IInterfaceResolver.sol\";\n\nabstract contract InterfaceResolver is IInterfaceResolver, AddrResolver {\n    mapping(uint64 => mapping(bytes32 => mapping(bytes4 => address))) versionable_interfaces;\n\n    /// Sets an interface associated with a name.\n    /// Setting the address to 0 restores the default behaviour of querying the contract at `addr()` for interface support.\n    /// @param node The node to update.\n    /// @param interfaceID The EIP 165 interface ID.\n    /// @param implementer The address of a contract that implements this interface for this node.\n    function setInterface(\n        bytes32 node,\n        bytes4 interfaceID,\n        address implementer\n    ) external virtual authorised(node) {\n        versionable_interfaces[recordVersions[node]][node][\n            interfaceID\n        ] = implementer;\n        emit InterfaceChanged(node, interfaceID, implementer);\n    }\n\n    /// Returns the address of a contract that implements the specified interface for this name.\n    /// If an implementer has not been set for this interfaceID and name, the resolver will query\n    /// the contract at `addr()`. If `addr()` is set, a contract exists at that address, and that\n    /// contract implements EIP165 and returns `true` for the specified interfaceID, its address\n    /// will be returned.\n    /// @param node The ENS node to query.\n    /// @param interfaceID The EIP 165 interface ID to check for.\n    /// @return The address that implements this interface, or 0 if the interface is unsupported.\n    function interfaceImplementer(\n        bytes32 node,\n        bytes4 interfaceID\n    ) external view virtual override returns (address) {\n        address implementer = versionable_interfaces[recordVersions[node]][\n            node\n        ][interfaceID];\n        if (implementer != address(0)) {\n            return implementer;\n        }\n\n        address a = addr(node);\n        if (a == address(0)) {\n            return address(0);\n        }\n\n        (bool success, bytes memory returnData) = a.staticcall(\n            abi.encodeWithSignature(\n                \"supportsInterface(bytes4)\",\n                type(IERC165).interfaceId\n            )\n        );\n        if (!success || returnData.length < 32 || returnData[31] == 0) {\n            // EIP 165 not supported by target\n            return address(0);\n        }\n\n        (success, returnData) = a.staticcall(\n            abi.encodeWithSignature(\"supportsInterface(bytes4)\", interfaceID)\n        );\n        if (!success || returnData.length < 32 || returnData[31] == 0) {\n            // Specified interface not supported by target\n            return address(0);\n        }\n\n        return a;\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view virtual override returns (bool) {\n        return\n            interfaceID == type(IInterfaceResolver).interfaceId ||\n            super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "contracts/resolvers/profiles/IPubkeyResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IPubkeyResolver {\n    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\n\n    /// Returns the SECP256k1 public key associated with an ENS node.\n    /// Defined in EIP 619.\n    /// @param node The ENS node to query\n    /// @return x The X coordinate of the curve point for the public key.\n    /// @return y The Y coordinate of the curve point for the public key.\n    function pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y);\n}\n"
    },
    "contracts/resolvers/profiles/ITextResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface ITextResolver {\n    event TextChanged(\n        bytes32 indexed node,\n        string indexed indexedKey,\n        string key,\n        string value\n    );\n\n    /// Returns the text data associated with an ENS node and key.\n    /// @param node The ENS node to query.\n    /// @param key The text data key to query.\n    /// @return The associated text data.\n    function text(\n        bytes32 node,\n        string calldata key\n    ) external view returns (string memory);\n}\n"
    },
    "contracts/resolvers/profiles/IVersionableResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IVersionableResolver {\n    event VersionChanged(bytes32 indexed node, uint64 newVersion);\n\n    function recordVersions(bytes32 node) external view returns (uint64);\n}\n"
    },
    "contracts/resolvers/profiles/NameResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"../ResolverBase.sol\";\nimport \"./INameResolver.sol\";\n\nabstract contract NameResolver is INameResolver, ResolverBase {\n    mapping(uint64 => mapping(bytes32 => string)) versionable_names;\n\n    /// Sets the name associated with an ENS node, for reverse records.\n    /// May only be called by the owner of that node in the ENS registry.\n    /// @param node The node to update.\n    function setName(\n        bytes32 node,\n        string calldata newName\n    ) external virtual authorised(node) {\n        versionable_names[recordVersions[node]][node] = newName;\n        emit NameChanged(node, newName);\n    }\n\n    /// Returns the name associated with an ENS node, for reverse records.\n    /// Defined in EIP181.\n    /// @param node The ENS node to query.\n    /// @return The associated name.\n    function name(\n        bytes32 node\n    ) external view virtual override returns (string memory) {\n        return versionable_names[recordVersions[node]][node];\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view virtual override returns (bool) {\n        return\n            interfaceID == type(INameResolver).interfaceId ||\n            super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "contracts/resolvers/profiles/PubkeyResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"../ResolverBase.sol\";\nimport \"./IPubkeyResolver.sol\";\n\nabstract contract PubkeyResolver is IPubkeyResolver, ResolverBase {\n    struct PublicKey {\n        bytes32 x;\n        bytes32 y;\n    }\n\n    mapping(uint64 => mapping(bytes32 => PublicKey)) versionable_pubkeys;\n\n    /// Sets the SECP256k1 public key associated with an ENS node.\n    /// @param node The ENS node to query\n    /// @param x the X coordinate of the curve point for the public key.\n    /// @param y the Y coordinate of the curve point for the public key.\n    function setPubkey(\n        bytes32 node,\n        bytes32 x,\n        bytes32 y\n    ) external virtual authorised(node) {\n        versionable_pubkeys[recordVersions[node]][node] = PublicKey(x, y);\n        emit PubkeyChanged(node, x, y);\n    }\n\n    /// Returns the SECP256k1 public key associated with an ENS node.\n    /// Defined in EIP 619.\n    /// @param node The ENS node to query\n    /// @return x The X coordinate of the curve point for the public key.\n    /// @return y The Y coordinate of the curve point for the public key.\n    function pubkey(\n        bytes32 node\n    ) external view virtual override returns (bytes32 x, bytes32 y) {\n        uint64 currentRecordVersion = recordVersions[node];\n        return (\n            versionable_pubkeys[currentRecordVersion][node].x,\n            versionable_pubkeys[currentRecordVersion][node].y\n        );\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view virtual override returns (bool) {\n        return\n            interfaceID == type(IPubkeyResolver).interfaceId ||\n            super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "contracts/resolvers/profiles/TextResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"../ResolverBase.sol\";\nimport \"./ITextResolver.sol\";\n\nabstract contract TextResolver is ITextResolver, ResolverBase {\n    mapping(uint64 => mapping(bytes32 => mapping(string => string))) versionable_texts;\n\n    /// Sets the text data associated with an ENS node and key.\n    /// May only be called by the owner of that node in the ENS registry.\n    /// @param node The node to update.\n    /// @param key The key to set.\n    /// @param value The text data value to set.\n    function setText(\n        bytes32 node,\n        string calldata key,\n        string calldata value\n    ) external virtual authorised(node) {\n        versionable_texts[recordVersions[node]][node][key] = value;\n        emit TextChanged(node, key, key, value);\n    }\n\n    /// Returns the text data associated with an ENS node and key.\n    /// @param node The ENS node to query.\n    /// @param key The text data key to query.\n    /// @return The associated text data.\n    function text(\n        bytes32 node,\n        string calldata key\n    ) external view virtual override returns (string memory) {\n        return versionable_texts[recordVersions[node]][node][key];\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view virtual override returns (bool) {\n        return\n            interfaceID == type(ITextResolver).interfaceId ||\n            super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "contracts/resolvers/PublicResolver.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"../registry/ENS.sol\";\nimport \"./profiles/ABIResolver.sol\";\nimport \"./profiles/AddrResolver.sol\";\nimport \"./profiles/ContentHashResolver.sol\";\nimport \"./profiles/DNSResolver.sol\";\nimport \"./profiles/InterfaceResolver.sol\";\nimport \"./profiles/NameResolver.sol\";\nimport \"./profiles/PubkeyResolver.sol\";\nimport \"./profiles/TextResolver.sol\";\nimport \"./Multicallable.sol\";\nimport {ReverseClaimer} from \"../reverseRegistrar/ReverseClaimer.sol\";\nimport {INameWrapper} from \"../wrapper/INameWrapper.sol\";\n\n/// A simple resolver anyone can use; only allows the owner of a node to set its\n/// address.\ncontract PublicResolver is\n    Multicallable,\n    ABIResolver,\n    AddrResolver,\n    ContentHashResolver,\n    DNSResolver,\n    InterfaceResolver,\n    NameResolver,\n    PubkeyResolver,\n    TextResolver,\n    ReverseClaimer\n{\n    ENS immutable ens;\n    INameWrapper immutable nameWrapper;\n    address immutable trustedETHController;\n    address immutable trustedReverseRegistrar;\n\n    /// A mapping of operators. An address that is authorised for an address\n    /// may make any changes to the name that the owner could, but may not update\n    /// the set of authorisations.\n    /// (owner, operator) => approved\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /// A mapping of delegates. A delegate that is authorised by an owner\n    /// for a name may make changes to the name's resolver, but may not update\n    /// the set of token approvals.\n    /// (owner, name, delegate) => approved\n    mapping(address => mapping(bytes32 => mapping(address => bool)))\n        private _tokenApprovals;\n\n    // Logged when an operator is added or removed.\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    // Logged when a delegate is approved or  an approval is revoked.\n    event Approved(\n        address owner,\n        bytes32 indexed node,\n        address indexed delegate,\n        bool indexed approved\n    );\n\n    constructor(\n        ENS _ens,\n        INameWrapper wrapperAddress,\n        address _trustedETHController,\n        address _trustedReverseRegistrar\n    ) ReverseClaimer(_ens, msg.sender) {\n        ens = _ens;\n        nameWrapper = wrapperAddress;\n        trustedETHController = _trustedETHController;\n        trustedReverseRegistrar = _trustedReverseRegistrar;\n    }\n\n    /// @dev See {IERC1155-setApprovalForAll}.\n    function setApprovalForAll(address operator, bool approved) external {\n        require(\n            msg.sender != operator,\n            \"ERC1155: setting approval status for self\"\n        );\n\n        _operatorApprovals[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /// @dev See {IERC1155-isApprovedForAll}.\n    function isApprovedForAll(\n        address account,\n        address operator\n    ) public view returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /// @dev Approve a delegate to be able to updated records on a node.\n    function approve(bytes32 node, address delegate, bool approved) external {\n        require(msg.sender != delegate, \"Setting delegate status for self\");\n\n        _tokenApprovals[msg.sender][node][delegate] = approved;\n        emit Approved(msg.sender, node, delegate, approved);\n    }\n\n    /// @dev Check to see if the delegate has been approved by the owner for the node.\n    function isApprovedFor(\n        address owner,\n        bytes32 node,\n        address delegate\n    ) public view returns (bool) {\n        return _tokenApprovals[owner][node][delegate];\n    }\n\n    function isAuthorised(bytes32 node) internal view override returns (bool) {\n        if (\n            msg.sender == trustedETHController ||\n            msg.sender == trustedReverseRegistrar\n        ) {\n            return true;\n        }\n        address owner = ens.owner(node);\n        if (owner == address(nameWrapper)) {\n            owner = nameWrapper.ownerOf(uint256(node));\n        }\n        return\n            owner == msg.sender ||\n            isApprovedForAll(owner, msg.sender) ||\n            isApprovedFor(owner, node, msg.sender);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    )\n        public\n        view\n        override(\n            Multicallable,\n            ABIResolver,\n            AddrResolver,\n            ContentHashResolver,\n            DNSResolver,\n            InterfaceResolver,\n            NameResolver,\n            PubkeyResolver,\n            TextResolver\n        )\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "contracts/resolvers/Resolver.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"./profiles/IABIResolver.sol\";\nimport \"./profiles/IAddressResolver.sol\";\nimport \"./profiles/IAddrResolver.sol\";\nimport \"./profiles/IContentHashResolver.sol\";\nimport \"./profiles/IDNSRecordResolver.sol\";\nimport \"./profiles/IDNSZoneResolver.sol\";\nimport \"./profiles/IInterfaceResolver.sol\";\nimport \"./profiles/INameResolver.sol\";\nimport \"./profiles/IPubkeyResolver.sol\";\nimport \"./profiles/ITextResolver.sol\";\nimport \"./profiles/IExtendedResolver.sol\";\n\n/// A generic resolver interface which includes all the functions including the ones deprecated\ninterface Resolver is\n    IERC165,\n    IABIResolver,\n    IAddressResolver,\n    IAddrResolver,\n    IContentHashResolver,\n    IDNSRecordResolver,\n    IDNSZoneResolver,\n    IInterfaceResolver,\n    INameResolver,\n    IPubkeyResolver,\n    ITextResolver,\n    IExtendedResolver\n{\n    /* Deprecated events */\n    event ContentChanged(bytes32 indexed node, bytes32 hash);\n\n    function setApprovalForAll(address, bool) external;\n\n    function approve(bytes32 node, address delegate, bool approved) external;\n\n    function isApprovedForAll(address account, address operator) external;\n\n    function isApprovedFor(\n        address owner,\n        bytes32 node,\n        address delegate\n    ) external;\n\n    function setABI(\n        bytes32 node,\n        uint256 contentType,\n        bytes calldata data\n    ) external;\n\n    function setAddr(bytes32 node, address addr) external;\n\n    function setAddr(bytes32 node, uint256 coinType, bytes calldata a) external;\n\n    function setContenthash(bytes32 node, bytes calldata hash) external;\n\n    function setDnsrr(bytes32 node, bytes calldata data) external;\n\n    function setName(bytes32 node, string calldata _name) external;\n\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external;\n\n    function setText(\n        bytes32 node,\n        string calldata key,\n        string calldata value\n    ) external;\n\n    function setInterface(\n        bytes32 node,\n        bytes4 interfaceID,\n        address implementer\n    ) external;\n\n    function multicall(\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    function multicallWithNodeCheck(\n        bytes32 nodehash,\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    /* Deprecated functions */\n    function content(bytes32 node) external view returns (bytes32);\n\n    function multihash(bytes32 node) external view returns (bytes memory);\n\n    function setContent(bytes32 node, bytes32 hash) external;\n\n    function setMultihash(bytes32 node, bytes calldata hash) external;\n}\n"
    },
    "contracts/resolvers/ResolverBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"./profiles/IVersionableResolver.sol\";\n\nabstract contract ResolverBase is ERC165, IVersionableResolver {\n    mapping(bytes32 => uint64) public recordVersions;\n\n    function isAuthorised(bytes32 node) internal view virtual returns (bool);\n\n    modifier authorised(bytes32 node) {\n        require(isAuthorised(node));\n        _;\n    }\n\n    /// Increments the record version associated with an ENS node.\n    /// May only be called by the owner of that node in the ENS registry.\n    /// @param node The node to update.\n    function clearRecords(bytes32 node) public virtual authorised(node) {\n        recordVersions[node]++;\n        emit VersionChanged(node, recordVersions[node]);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view virtual override returns (bool) {\n        return\n            interfaceID == type(IVersionableResolver).interfaceId ||\n            super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "contracts/resolvers/ResolverFeatures.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary ResolverFeatures {\n    /// @notice Implements `resolve(multicall([...]))`.\n    /// @dev Feature: `0x96b62db8`\n    bytes4 constant RESOLVE_MULTICALL =\n        bytes4(keccak256(\"eth.ens.resolver.extended.multicall\"));\n\n    /// @notice Returns the same records independent of name or node.\n    /// @dev Feature: `0x86fb8da8`\n    bytes4 constant SINGULAR = bytes4(keccak256(\"eth.ens.resolver.singular\"));\n}\n"
    },
    "contracts/reverseRegistrar/DefaultReverseRegistrar.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nimport {Ownable} from \"@openzeppelin/contracts-v5/access/Ownable.sol\";\nimport {MessageHashUtils} from \"@openzeppelin/contracts-v5/utils/cryptography/MessageHashUtils.sol\";\nimport {ERC165} from \"@openzeppelin/contracts-v5/utils/introspection/ERC165.sol\";\n\nimport {IDefaultReverseRegistrar} from \"./IDefaultReverseRegistrar.sol\";\nimport {StandaloneReverseRegistrar} from \"./StandaloneReverseRegistrar.sol\";\nimport {SignatureUtils} from \"./SignatureUtils.sol\";\nimport {Controllable} from \"../root/Controllable.sol\";\n\n/// @title Default Reverse Registrar\n/// @notice A default reverse registrar. Only one instance of this contract is deployed.\ncontract DefaultReverseRegistrar is\n    IDefaultReverseRegistrar,\n    ERC165,\n    StandaloneReverseRegistrar,\n    Controllable\n{\n    using SignatureUtils for bytes;\n    using MessageHashUtils for bytes32;\n\n    /// @inheritdoc IDefaultReverseRegistrar\n    function setName(string calldata name) external {\n        _setName(msg.sender, name);\n    }\n\n    /// @inheritdoc IDefaultReverseRegistrar\n    function setNameForAddrWithSignature(\n        address addr,\n        uint256 signatureExpiry,\n        string calldata name,\n        bytes calldata signature\n    ) external {\n        // Follow ERC191 version 0 https://eips.ethereum.org/EIPS/eip-191\n        bytes32 message = keccak256(\n            abi.encodePacked(\n                address(this),\n                this.setNameForAddrWithSignature.selector,\n                addr,\n                signatureExpiry,\n                name\n            )\n        ).toEthSignedMessageHash();\n\n        signature.validateSignatureWithExpiry(addr, message, signatureExpiry);\n\n        _setName(addr, name);\n    }\n\n    function setNameForAddr(\n        address addr,\n        string calldata name\n    ) external onlyController {\n        _setName(addr, name);\n    }\n\n    /// @inheritdoc ERC165\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view override(ERC165, StandaloneReverseRegistrar) returns (bool) {\n        return\n            interfaceID == type(IDefaultReverseRegistrar).interfaceId ||\n            super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "contracts/reverseRegistrar/IDefaultReverseRegistrar.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Interface for the Default Reverse Registrar.\ninterface IDefaultReverseRegistrar {\n    /// @notice Sets the `nameForAddr()` record for the calling account.\n    ///\n    /// @param name The name to set.\n    function setName(string memory name) external;\n\n    /// @notice Sets the `nameForAddr()` record for the addr provided account using a signature.\n    ///\n    /// @param addr The address to set the name for.\n    /// @param name The name to set.\n    /// @param signatureExpiry Date when the signature expires.\n    /// @param signature The signature from the addr.\n    function setNameForAddrWithSignature(\n        address addr,\n        uint256 signatureExpiry,\n        string memory name,\n        bytes memory signature\n    ) external;\n\n    function setNameForAddr(address addr, string memory name) external;\n}\n"
    },
    "contracts/reverseRegistrar/IL2ReverseRegistrar.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Interface for the L2 Reverse Registrar.\ninterface IL2ReverseRegistrar {\n    /// @notice Sets the `nameForAddr()` record for the calling account.\n    ///\n    /// @param name The name to set.\n    function setName(string memory name) external;\n\n    /// @notice Sets the `nameForAddr()` record for the addr provided account.\n    ///\n    /// @param addr The address to set the name for.\n    /// @param name The name to set.\n    function setNameForAddr(address addr, string memory name) external;\n\n    /// @notice Sets the `nameForAddr()` record for the addr provided account using a signature.\n    ///\n    /// @param addr The address to set the name for.\n    /// @param name The name to set.\n    /// @param coinTypes The coin types to set. Must be inclusive of the coin type for the contract.\n    /// @param signatureExpiry Date when the signature expires.\n    /// @param signature The signature from the addr.\n    function setNameForAddrWithSignature(\n        address addr,\n        uint256 signatureExpiry,\n        string memory name,\n        uint256[] memory coinTypes,\n        bytes memory signature\n    ) external;\n\n    /// @notice Sets the `nameForAddr()` record for the contract provided that is owned with `Ownable`.\n    ///\n    /// @param contractAddr The address of the contract to set the name for (implementing Ownable).\n    /// @param owner The owner of the contract (via Ownable).\n    /// @param signatureExpiry The expiry of the signature.\n    /// @param name The name to set.\n    /// @param coinTypes The coin types to set. Must be inclusive of the coin type for the contract.\n    /// @param signature The signature of an address that will return true on isValidSignature for the owner.\n    function setNameForOwnableWithSignature(\n        address contractAddr,\n        address owner,\n        uint256 signatureExpiry,\n        string memory name,\n        uint256[] memory coinTypes,\n        bytes memory signature\n    ) external;\n}\n"
    },
    "contracts/reverseRegistrar/IReverseRegistrar.sol": {
      "content": "pragma solidity >=0.8.4;\n\ninterface IReverseRegistrar {\n    function setDefaultResolver(address resolver) external;\n\n    function claim(address owner) external returns (bytes32);\n\n    function claimForAddr(\n        address addr,\n        address owner,\n        address resolver\n    ) external returns (bytes32);\n\n    function claimWithResolver(\n        address owner,\n        address resolver\n    ) external returns (bytes32);\n\n    function setName(string memory name) external returns (bytes32);\n\n    function setNameForAddr(\n        address addr,\n        address owner,\n        address resolver,\n        string memory name\n    ) external returns (bytes32);\n\n    function node(address addr) external pure returns (bytes32);\n}\n"
    },
    "contracts/reverseRegistrar/IStandaloneReverseRegistrar.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Interface for a standalone reverse registrar.\ninterface IStandaloneReverseRegistrar {\n    /// @notice Emitted when the name for an address is changed.\n    ///\n    /// @param addr The address of the reverse record.\n    /// @param name The name of the reverse record.\n    event NameForAddrChanged(address indexed addr, string name);\n\n    /// @notice Returns the name for an address.\n    ///\n    /// @param addr The address to get the name for.\n    /// @return The name for the address.\n    function nameForAddr(address addr) external view returns (string memory);\n}\n"
    },
    "contracts/reverseRegistrar/L2ReverseRegistrar.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nimport {Ownable} from \"@openzeppelin/contracts-v5/access/Ownable.sol\";\nimport {MessageHashUtils} from \"@openzeppelin/contracts-v5/utils/cryptography/MessageHashUtils.sol\";\nimport {ERC165} from \"@openzeppelin/contracts-v5/utils/introspection/ERC165.sol\";\n\nimport {IL2ReverseRegistrar} from \"./IL2ReverseRegistrar.sol\";\nimport {StandaloneReverseRegistrar} from \"./StandaloneReverseRegistrar.sol\";\nimport {SignatureUtils} from \"./SignatureUtils.sol\";\n\n/// @title L2 Reverse Registrar\n/// @notice An L2 Reverse Registrar. Deployed to each L2 chain.\ncontract L2ReverseRegistrar is\n    IL2ReverseRegistrar,\n    ERC165,\n    StandaloneReverseRegistrar\n{\n    using SignatureUtils for bytes;\n    using MessageHashUtils for bytes32;\n\n    /// @notice The coin type for the chain this contract is deployed to.\n    uint256 public immutable coinType;\n\n    /// @notice Thrown when the specified address is not the owner of the contract\n    error NotOwnerOfContract();\n\n    /// @notice Thrown when the coin type is not found in the provided array\n    error CoinTypeNotFound();\n\n    /// @notice The caller is not authorised to perform the action\n    error Unauthorised();\n\n    /// @notice Checks if the caller is authorised\n    ///\n    /// @param addr The address to check.\n    modifier authorised(address addr) {\n        if (addr != msg.sender && !_ownsContract(addr, msg.sender)) {\n            revert Unauthorised();\n        }\n        _;\n    }\n\n    /// @notice Ensures the coin type of the contract is included in the provided array\n    ///\n    /// @param coinTypes The coin types to check.\n    modifier validCoinTypes(uint256[] calldata coinTypes) {\n        _validateCoinTypes(coinTypes);\n        _;\n    }\n\n    /// @notice Initialises the contract by setting the coin type.\n    ///\n    /// @param coinType_ The cointype converted from the chainId of the chain this contract is deployed to.\n    constructor(uint256 coinType_) {\n        coinType = coinType_;\n    }\n\n    /// @inheritdoc IL2ReverseRegistrar\n    function setName(string calldata name) external authorised(msg.sender) {\n        _setName(msg.sender, name);\n    }\n\n    /// @inheritdoc IL2ReverseRegistrar\n    function setNameForAddr(\n        address addr,\n        string calldata name\n    ) external authorised(addr) {\n        _setName(addr, name);\n    }\n\n    /// @inheritdoc IL2ReverseRegistrar\n    function setNameForAddrWithSignature(\n        address addr,\n        uint256 signatureExpiry,\n        string calldata name,\n        uint256[] calldata coinTypes,\n        bytes calldata signature\n    ) external validCoinTypes(coinTypes) {\n        // Follow ERC191 version 0 https://eips.ethereum.org/EIPS/eip-191\n        bytes32 message = keccak256(\n            abi.encodePacked(\n                address(this),\n                this.setNameForAddrWithSignature.selector,\n                addr,\n                signatureExpiry,\n                name,\n                coinTypes\n            )\n        ).toEthSignedMessageHash();\n\n        signature.validateSignatureWithExpiry(addr, message, signatureExpiry);\n\n        _setName(addr, name);\n    }\n\n    /// @inheritdoc IL2ReverseRegistrar\n    function setNameForOwnableWithSignature(\n        address contractAddr,\n        address owner,\n        uint256 signatureExpiry,\n        string calldata name,\n        uint256[] calldata coinTypes,\n        bytes calldata signature\n    ) external validCoinTypes(coinTypes) {\n        // Follow ERC191 version 0 https://eips.ethereum.org/EIPS/eip-191\n        bytes32 message = keccak256(\n            abi.encodePacked(\n                address(this),\n                this.setNameForOwnableWithSignature.selector,\n                contractAddr,\n                owner,\n                signatureExpiry,\n                name,\n                coinTypes\n            )\n        ).toEthSignedMessageHash();\n\n        if (!_ownsContract(contractAddr, owner)) revert NotOwnerOfContract();\n\n        signature.validateSignatureWithExpiry(owner, message, signatureExpiry);\n\n        _setName(contractAddr, name);\n    }\n\n    /// @notice Checks if the provided contractAddr is a contract and is owned by the\n    ///         provided addr.\n    ///\n    /// @param contractAddr The address of the contract to check.\n    /// @param addr The address to check ownership against.\n    function _ownsContract(\n        address contractAddr,\n        address addr\n    ) internal view returns (bool) {\n        if (contractAddr.code.length == 0) return false;\n        try Ownable(contractAddr).owner() returns (address owner) {\n            return owner == addr;\n        } catch {\n            return false;\n        }\n    }\n\n    /// @notice Ensures the coin type for the contract is included in the provided array.\n    ///\n    /// @param coinTypes The coin types to check.\n    function _validateCoinTypes(uint256[] calldata coinTypes) internal view {\n        for (uint256 i = 0; i < coinTypes.length; i++) {\n            if (coinTypes[i] == coinType) return;\n        }\n\n        revert CoinTypeNotFound();\n    }\n\n    /// @inheritdoc ERC165\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view override(ERC165, StandaloneReverseRegistrar) returns (bool) {\n        return\n            interfaceID == type(IL2ReverseRegistrar).interfaceId ||\n            super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "contracts/reverseRegistrar/L2ReverseRegistrarWithMigration.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nimport {Ownable} from \"@openzeppelin/contracts-v5/access/Ownable.sol\";\n\nimport {L2ReverseRegistrar} from \"./L2ReverseRegistrar.sol\";\nimport {INameResolver} from \"../resolvers/profiles/INameResolver.sol\";\nimport {AddressUtils} from \"../utils/AddressUtils.sol\";\n\n/// @notice An L2 Reverse Registrar that allows migrating from a prior resolver.\ncontract L2ReverseRegistrarWithMigration is L2ReverseRegistrar, Ownable {\n    using AddressUtils for address;\n\n    /// @notice The old reverse resolver to migrate from\n    INameResolver immutable oldReverseResolver;\n\n    /// @notice The parent node of reverse nodes. The convention is '${coinType}.reverse'\n    bytes32 immutable parentNode;\n\n    /// @notice Initialises the contract by setting the parent node, coin type, and old reverse resolver.\n    ///\n    /// @param coinType_ The cointype converted from the chainId of the chain this contract is deployed to.\n    /// @param owner_ The initial owner of the contract.\n    /// @param parentNode_ The parent node to set. The convention is '${coinType}.reverse'.\n    /// @param oldReverseResolver_ The old reverse resolver.\n    constructor(\n        uint256 coinType_,\n        address owner_,\n        bytes32 parentNode_,\n        INameResolver oldReverseResolver_\n    ) L2ReverseRegistrar(coinType_) Ownable(owner_) {\n        parentNode = parentNode_;\n        oldReverseResolver = oldReverseResolver_;\n    }\n\n    /// @notice Migrates the names from the old reverse resolver to the new one.\n    ///         Only callable by the owner.\n    ///\n    /// @param addresses The addresses to migrate.\n    function batchSetName(address[] calldata addresses) external onlyOwner {\n        for (uint256 i = 0; i < addresses.length; i++) {\n            // namehash of `[addresses[i]].[coinType].reverse`\n            bytes32 node = keccak256(\n                abi.encodePacked(parentNode, addresses[i].sha3HexAddress())\n            );\n            string memory name = oldReverseResolver.name(node);\n\n            // equivalent to _setName(addresses[i], name);\n            // internal because the name value isn't in calldata\n            _names[addresses[i]] = name;\n            emit NameForAddrChanged(addresses[i], name);\n        }\n    }\n}\n"
    },
    "contracts/reverseRegistrar/ReverseClaimer.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.17 <0.9.0;\n\nimport {ENS} from \"../registry/ENS.sol\";\nimport {IReverseRegistrar} from \"../reverseRegistrar/IReverseRegistrar.sol\";\n\ncontract ReverseClaimer {\n    bytes32 constant ADDR_REVERSE_NODE =\n        0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\n\n    constructor(ENS ens, address claimant) {\n        IReverseRegistrar reverseRegistrar = IReverseRegistrar(\n            ens.owner(ADDR_REVERSE_NODE)\n        );\n        reverseRegistrar.claim(claimant);\n    }\n}\n"
    },
    "contracts/reverseRegistrar/ReverseRegistrar.sol": {
      "content": "pragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../registry/ENS.sol\";\nimport \"./IReverseRegistrar.sol\";\nimport \"../root/Controllable.sol\";\n\nabstract contract NameResolver {\n    function setName(bytes32 node, string memory name) public virtual;\n}\n\nbytes32 constant lookup = 0x3031323334353637383961626364656600000000000000000000000000000000;\n\nbytes32 constant ADDR_REVERSE_NODE = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\n\n// namehash('addr.reverse')\n\ncontract ReverseRegistrar is Ownable, Controllable, IReverseRegistrar {\n    ENS public immutable ens;\n    NameResolver public defaultResolver;\n\n    event ReverseClaimed(address indexed addr, bytes32 indexed node);\n    event DefaultResolverChanged(NameResolver indexed resolver);\n\n    /// @dev Constructor\n    /// @param ensAddr The address of the ENS registry.\n    constructor(ENS ensAddr) {\n        ens = ensAddr;\n\n        // Assign ownership of the reverse record to our deployer\n        ReverseRegistrar oldRegistrar = ReverseRegistrar(\n            ensAddr.owner(ADDR_REVERSE_NODE)\n        );\n        if (address(oldRegistrar) != address(0x0)) {\n            oldRegistrar.claim(msg.sender);\n        }\n    }\n\n    modifier authorised(address addr) {\n        require(\n            addr == msg.sender ||\n                controllers[msg.sender] ||\n                ens.isApprovedForAll(addr, msg.sender) ||\n                ownsContract(addr),\n            \"ReverseRegistrar: Caller is not a controller or authorised by address or the address itself\"\n        );\n        _;\n    }\n\n    function setDefaultResolver(address resolver) public override onlyOwner {\n        require(\n            address(resolver) != address(0),\n            \"ReverseRegistrar: Resolver address must not be 0\"\n        );\n        defaultResolver = NameResolver(resolver);\n        emit DefaultResolverChanged(NameResolver(resolver));\n    }\n\n    /// @dev Transfers ownership of the reverse ENS record associated with the\n    ///      calling account.\n    /// @param owner The address to set as the owner of the reverse record in ENS.\n    /// @return The ENS node hash of the reverse record.\n    function claim(address owner) public override returns (bytes32) {\n        return claimForAddr(msg.sender, owner, address(defaultResolver));\n    }\n\n    /// @dev Transfers ownership of the reverse ENS record associated with the\n    ///      calling account.\n    /// @param addr The reverse record to set\n    /// @param owner The address to set as the owner of the reverse record in ENS.\n    /// @param resolver The resolver of the reverse node\n    /// @return The ENS node hash of the reverse record.\n    function claimForAddr(\n        address addr,\n        address owner,\n        address resolver\n    ) public override authorised(addr) returns (bytes32) {\n        bytes32 labelHash = sha3HexAddress(addr);\n        bytes32 reverseNode = keccak256(\n            abi.encodePacked(ADDR_REVERSE_NODE, labelHash)\n        );\n        emit ReverseClaimed(addr, reverseNode);\n        ens.setSubnodeRecord(ADDR_REVERSE_NODE, labelHash, owner, resolver, 0);\n        return reverseNode;\n    }\n\n    /// @dev Transfers ownership of the reverse ENS record associated with the\n    ///      calling account.\n    /// @param owner The address to set as the owner of the reverse record in ENS.\n    /// @param resolver The address of the resolver to set; 0 to leave unchanged.\n    /// @return The ENS node hash of the reverse record.\n    function claimWithResolver(\n        address owner,\n        address resolver\n    ) public override returns (bytes32) {\n        return claimForAddr(msg.sender, owner, resolver);\n    }\n\n    /// @dev Sets the `name()` record for the reverse ENS record associated with\n    /// the calling account. First updates the resolver to the default reverse\n    /// resolver if necessary.\n    /// @param name The name to set for this address.\n    /// @return The ENS node hash of the reverse record.\n    function setName(string memory name) public override returns (bytes32) {\n        return\n            setNameForAddr(\n                msg.sender,\n                msg.sender,\n                address(defaultResolver),\n                name\n            );\n    }\n\n    /// @dev Sets the `name()` record for the reverse ENS record associated with\n    /// the account provided. Updates the resolver to a designated resolver\n    /// Only callable by controllers and authorised users\n    /// @param addr The reverse record to set\n    /// @param owner The owner of the reverse node\n    /// @param resolver The resolver of the reverse node\n    /// @param name The name to set for this address.\n    /// @return The ENS node hash of the reverse record.\n    function setNameForAddr(\n        address addr,\n        address owner,\n        address resolver,\n        string memory name\n    ) public override returns (bytes32) {\n        bytes32 node = claimForAddr(addr, owner, resolver);\n        NameResolver(resolver).setName(node, name);\n        return node;\n    }\n\n    /// @dev Returns the node hash for a given account's reverse records.\n    /// @param addr The address to hash\n    /// @return The ENS node hash.\n    function node(address addr) public pure override returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(ADDR_REVERSE_NODE, sha3HexAddress(addr))\n            );\n    }\n\n    /// @dev An optimised function to compute the sha3 of the lower-case\n    ///      hexadecimal representation of an Ethereum address.\n    /// @param addr The address to hash\n    /// @return ret The SHA3 hash of the lower-case hexadecimal encoding of the\n    ///         input address.\n    function sha3HexAddress(address addr) private pure returns (bytes32 ret) {\n        assembly {\n            for {\n                let i := 40\n            } gt(i, 0) {} {\n                i := sub(i, 1)\n                mstore8(i, byte(and(addr, 0xf), lookup))\n                addr := div(addr, 0x10)\n                i := sub(i, 1)\n                mstore8(i, byte(and(addr, 0xf), lookup))\n                addr := div(addr, 0x10)\n            }\n\n            ret := keccak256(0, 40)\n        }\n    }\n\n    function ownsContract(address addr) internal view returns (bool) {\n        try Ownable(addr).owner() returns (address owner) {\n            return owner == msg.sender;\n        } catch {\n            return false;\n        }\n    }\n}\n"
    },
    "contracts/reverseRegistrar/SignatureUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {SignatureChecker} from \"@openzeppelin/contracts-v5/utils/cryptography/SignatureChecker.sol\";\n\ninterface IUniversalSignatureValidator {\n    function isValidSig(\n        address _signer,\n        bytes32 _hash,\n        bytes calldata _signature\n    ) external returns (bool);\n}\n\n/// @notice Utility functions for validating signatures with expiry.\nlibrary SignatureUtils {\n    /// @notice The ERC6492 detection suffix.\n    bytes32 private constant ERC6492_DETECTION_SUFFIX =\n        0x6492649264926492649264926492649264926492649264926492649264926492;\n\n    /// @notice The universal signature validator.\n    IUniversalSignatureValidator public constant validator =\n        IUniversalSignatureValidator(\n            0x164af34fAF9879394370C7f09064127C043A35E9\n        );\n\n    /// @notice The signature is invalid\n    error InvalidSignature();\n\n    /// @notice The signature expiry is too high\n    error SignatureExpiryTooHigh();\n\n    /// @notice The signature has expired\n    error SignatureExpired();\n\n    /// @notice Validates a signature with expiry.\n    ///\n    /// @param signature The signature to validate.\n    /// @param addr The address that signed the message.\n    /// @param message The message that was signed.\n    /// @param signatureExpiry The expiry of the signature.\n    function validateSignatureWithExpiry(\n        bytes calldata signature,\n        address addr,\n        bytes32 message,\n        uint256 signatureExpiry\n    ) internal {\n        // ERC6492 check is done internally because UniversalSigValidator is not gas efficient.\n        // We only want to use UniversalSigValidator for ERC6492 signatures.\n        if (\n            bytes32(signature[signature.length - 32:signature.length]) ==\n            ERC6492_DETECTION_SUFFIX\n        ) {\n            if (!validator.isValidSig(addr, message, signature))\n                revert InvalidSignature();\n        } else {\n            if (!SignatureChecker.isValidSignatureNow(addr, message, signature))\n                revert InvalidSignature();\n        }\n        if (signatureExpiry < block.timestamp) revert SignatureExpired();\n        if (signatureExpiry > block.timestamp + 1 hours)\n            revert SignatureExpiryTooHigh();\n    }\n}\n"
    },
    "contracts/reverseRegistrar/StandaloneReverseRegistrar.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nimport {ERC165} from \"@openzeppelin/contracts-v5/utils/introspection/ERC165.sol\";\n\nimport {IStandaloneReverseRegistrar} from \"./IStandaloneReverseRegistrar.sol\";\n\n/// @title Standalone Reverse Registrar\n/// @notice A standalone reverse registrar, detached from the ENS registry.\ncontract StandaloneReverseRegistrar is ERC165, IStandaloneReverseRegistrar {\n    /// @notice The mapping of addresses to names.\n    mapping(address => string) internal _names;\n\n    /// @inheritdoc IStandaloneReverseRegistrar\n    function nameForAddr(\n        address addr\n    ) external view returns (string memory name) {\n        name = _names[addr];\n    }\n\n    /// @notice Sets the name for an address.\n    ///\n    /// @dev Authorisation should be checked before calling.\n    ///\n    /// @param addr The address to set the name for.\n    /// @param name The name to set.\n    function _setName(address addr, string calldata name) internal {\n        _names[addr] = name;\n        emit NameForAddrChanged(addr, name);\n    }\n\n    /// @inheritdoc ERC165\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view virtual override(ERC165) returns (bool) {\n        return\n            interfaceID == type(IStandaloneReverseRegistrar).interfaceId ||\n            super.supportsInterface(interfaceID);\n    }\n}\n"
    },
    "contracts/reverseResolver/AbstractReverseResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ERC165} from \"@openzeppelin/contracts-v5/utils/introspection/ERC165.sol\";\nimport {IExtendedResolver} from \"../resolvers/profiles/IExtendedResolver.sol\";\nimport {IAddressResolver} from \"../resolvers/profiles/IAddressResolver.sol\";\nimport {IAddrResolver} from \"../resolvers/profiles/IAddrResolver.sol\";\nimport {INameResolver} from \"../resolvers/profiles/INameResolver.sol\";\nimport {INameReverser} from \"./INameReverser.sol\";\nimport {ENSIP19, COIN_TYPE_DEFAULT, COIN_TYPE_ETH} from \"../utils/ENSIP19.sol\";\n\nabstract contract AbstractReverseResolver is\n    IExtendedResolver,\n    INameReverser,\n    ERC165\n{\n    /// @notice The coin type for the resolver.\n    uint256 public immutable coinType;\n\n    /// @notice The address returned by `addr(coinType)` for the resolver.\n    address private immutable registrar;\n\n    /// @notice `resolve()` was called with a profile other than `name()` or `addr(*)`.\n    /// @dev Error selector: `0x7b1c461b`\n    error UnsupportedResolverProfile(bytes4 selector);\n\n    /// @notice `name` is not a valid DNS-encoded ENSIP-19 reverse name or namespace.\n    /// @dev Error selector: `0x5fe9a5df`\n    error UnreachableName(bytes name);\n\n    constructor(uint256 _coinType, address _registrar) {\n        coinType = _coinType;\n        registrar = _registrar;\n    }\n\n    /// @inheritdoc ERC165\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view override returns (bool) {\n        return\n            interfaceId == type(IExtendedResolver).interfaceId ||\n            interfaceId == type(INameReverser).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /// @notice The EVM Chain ID corresponding to the `coinType`.\n    function chainId() external view returns (uint32) {\n        return ENSIP19.chainFromCoinType(coinType);\n    }\n\n    /// @dev Resolve one address to a name.\n    ///      If this reverts `OffchainLookup`, it must return an abi-encoded result since\n    ///      it is invoked during `resolve()`.\n    function _resolveName(\n        address addr\n    ) internal view virtual returns (string memory name);\n\n    /// @notice Resolves the following profiles according to ENSIP-10:\n    ///         - `name()` if `name` is an ENSIP-19 reverse name of an EVM address for `coinType`.\n    ///         - `addr(*) = registrar` if `name` is an ENSIP-19 reverse namespace for `coinType`.\n    ///         Caller should enable EIP-3668.\n    /// @dev This function may execute over multiple steps.\n    /// @param name The reverse name to resolve, in normalised and DNS-encoded form.\n    /// @param data The resolution data, as specified in ENSIP-10.\n    /// @return result The encoded response for the requested profile.\n    function resolve(\n        bytes calldata name,\n        bytes calldata data\n    ) external view returns (bytes memory result) {\n        bytes4 selector = bytes4(data);\n        if (selector == INameResolver.name.selector) {\n            (bytes memory a, uint256 ct) = ENSIP19.parse(name);\n            if (\n                a.length != 20 ||\n                !(\n                    coinType == COIN_TYPE_DEFAULT\n                        ? ENSIP19.isEVMCoinType(ct)\n                        : ct == coinType\n                )\n            ) {\n                revert UnreachableName(name);\n            }\n            address addr = address(bytes20(a));\n            return abi.encode(_resolveName(addr));\n        } else if (selector == IAddrResolver.addr.selector) {\n            (bool valid, ) = ENSIP19.parseNamespace(name, 0);\n            if (!valid) revert UnreachableName(name);\n            return\n                abi.encode(coinType == COIN_TYPE_ETH ? registrar : address(0));\n        } else if (selector == IAddressResolver.addr.selector) {\n            (bool valid, ) = ENSIP19.parseNamespace(name, 0);\n            if (!valid) revert UnreachableName(name);\n            (, uint256 ct) = abi.decode(data[4:], (bytes32, uint256));\n            return\n                abi.encode(\n                    coinType == ct ? abi.encodePacked(registrar) : new bytes(0)\n                );\n        } else {\n            revert UnsupportedResolverProfile(selector);\n        }\n    }\n\n    // `INameReverser.resolveNames()` is not implemented here because it causes\n    // an incorrect \"Unreachable code\" compiler warning if `_resolveName()` reverts.\n    // https://github.com/ethereum/solidity/issues/15426#issuecomment-2917868211\n    //\n    // /// @inheritdoc INameReverser\n    // function resolveNames(\n    //     address[] memory addrs,\n    //     uint8 /*perPage*/\n    // ) external view returns (string[] memory names) {\n    //     names = new string[](addrs.length);\n    //     for (uint256 i; i < addrs.length; i++) {\n    //         names[i] = _resolveName(addrs[i]);\n    //     }\n    // }\n}\n"
    },
    "contracts/reverseResolver/ChainReverseResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {AbstractReverseResolver} from \"./AbstractReverseResolver.sol\";\nimport {Ownable} from \"@openzeppelin/contracts-v5/access/Ownable.sol\";\nimport {GatewayFetchTarget, IGatewayVerifier} from \"@unruggable/gateways/contracts/GatewayFetchTarget.sol\";\nimport {GatewayFetcher, GatewayRequest} from \"@unruggable/gateways/contracts/GatewayFetcher.sol\";\nimport {IStandaloneReverseRegistrar} from \"../reverseRegistrar/IStandaloneReverseRegistrar.sol\";\nimport {INameReverser} from \"./INameReverser.sol\";\n\n/// @title Chain Reverse Resolver\n/// @notice Reverses an EVM address using the first non-null response from the following sources:\n///         1. `L2ReverseRegistrar` on L2 chain via Unruggable Gateway\n///         2. `IStandaloneReverseRegistrar` for \"default.reverse\"\ncontract ChainReverseResolver is\n    AbstractReverseResolver,\n    GatewayFetchTarget,\n    Ownable\n{\n    using GatewayFetcher for GatewayRequest;\n\n    /// @notice The reverse registrar contract for \"default.reverse\".\n    IStandaloneReverseRegistrar public immutable defaultRegistrar;\n\n    /// @notice The reverse registrar address on the L2 chain.\n    address public immutable l2Registrar;\n\n    /// @notice Storage slot for the names mapping in `L2ReverseRegistrar`.\n    uint256 constant NAMES_SLOT = 0;\n\n    /// @notice The verifier contract for the L2 chain.\n    IGatewayVerifier public gatewayVerifier;\n\n    /// @notice Gateway URLs for the verifier contract.\n    string[] public gatewayURLs;\n\n    /// @notice Emitted when the gateway verifier is changed.\n    event GatewayVerifierChanged(address verifier);\n\n    /// @notice Emitted when the gateway URLs are changed.\n    event GatewayURLsChanged(string[] urls);\n\n    constructor(\n        address _owner,\n        uint256 coinType,\n        IStandaloneReverseRegistrar _defaultRegistrar,\n        address _l2Registrar,\n        IGatewayVerifier verifier,\n        string[] memory gateways\n    ) Ownable(_owner) AbstractReverseResolver(coinType, _l2Registrar) {\n        defaultRegistrar = _defaultRegistrar;\n        l2Registrar = _l2Registrar;\n        gatewayVerifier = verifier;\n        gatewayURLs = gateways;\n    }\n\n    /// @notice Set gateway URLs.\n    /// @param gateways The new gateway URLs.\n    function setGatewayURLs(string[] memory gateways) external onlyOwner {\n        gatewayURLs = gateways;\n        emit GatewayURLsChanged(gateways);\n    }\n\n    /// @notice Set the verifier contract.\n    /// @param verifier The new verifier contract.\n    function setGatewayVerifier(address verifier) external onlyOwner {\n        gatewayVerifier = IGatewayVerifier(verifier);\n        emit GatewayVerifierChanged(verifier);\n    }\n\n    /// @inheritdoc AbstractReverseResolver\n    function _resolveName(\n        address addr\n    ) internal view override returns (string memory) {\n        GatewayRequest memory req = GatewayFetcher.newRequest(1);\n        req.setTarget(l2Registrar); // target L2 registrar\n        req.setSlot(NAMES_SLOT).push(addr).follow().readBytes(); // names[addr]\n        req.setOutput(0);\n        fetch(\n            gatewayVerifier,\n            req,\n            this.resolveNameCallback.selector, // ==> step 2\n            abi.encode(addr),\n            gatewayURLs\n        );\n    }\n\n    /// @dev CCIP-Read callback for `_resolveName()`.\n    /// @param values The outputs for `GatewayRequest` (1 name).\n    /// @param extraData The contextual data passed from `_resolveName()`.\n    /// @return result The abi-encoded name for the given address.\n    function resolveNameCallback(\n        bytes[] memory values,\n        uint8 /* exitCode */,\n        bytes calldata extraData\n    ) external view returns (bytes memory result) {\n        string memory name = string(values[0]);\n        if (bytes(name).length == 0) {\n            address addr = abi.decode(extraData, (address));\n            name = defaultRegistrar.nameForAddr(addr);\n        }\n        result = abi.encode(name);\n    }\n\n    /// @inheritdoc INameReverser\n    function resolveNames(\n        address[] memory addrs,\n        uint8 perPage\n    ) external view returns (string[] memory names) {\n        names = new string[](addrs.length);\n        _resolveNames(addrs, names, 0, perPage);\n    }\n\n    /// @dev Resolve the next page of addresses to names.\n    ///      This function executes over multiple steps.\n    function _resolveNames(\n        address[] memory addrs,\n        string[] memory names,\n        uint256 start,\n        uint8 perPage\n    ) internal view {\n        uint256 end = start + perPage;\n        if (end > addrs.length) end = addrs.length;\n        uint8 count = uint8(end - start);\n        if (count == 0) return; // done\n        GatewayRequest memory req = GatewayFetcher.newRequest(count);\n        req.setTarget(l2Registrar); // target L2 registrar\n        for (uint256 i; i < count; i++) {\n            req.setSlot(NAMES_SLOT).push(addrs[start + i]).follow().readBytes(); // names[addr[i]]\n            req.setOutput(uint8(i));\n        }\n        fetch(\n            gatewayVerifier,\n            req,\n            this.resolveNamesCallback.selector, // ==> step 2\n            abi.encode(addrs, names, start, perPage),\n            gatewayURLs\n        );\n    }\n\n    /// @dev CCIP-Read callback for `_resolveNames()`.\n    ///      Recursive if there are still addresses to resolve.\n    /// @param values The outputs for `GatewayRequest` (N names).\n    /// @param extraData The contextual data passed from `_resolveNames()`.\n    /// @return names The resolved names.\n    function resolveNamesCallback(\n        bytes[] memory values,\n        uint8 /* exitCode */,\n        bytes calldata extraData\n    ) external view returns (string[] memory names) {\n        address[] memory addrs;\n        uint256 start;\n        uint8 perPage;\n        (addrs, names, start, perPage) = abi.decode(\n            extraData,\n            (address[], string[], uint256, uint8)\n        );\n        for (uint256 i; i < values.length; i++) {\n            string memory name = string(values[i]);\n            if (bytes(name).length == 0) {\n                name = defaultRegistrar.nameForAddr(addrs[i]);\n            }\n            names[start + i] = name;\n        }\n        _resolveNames(addrs, names, start + values.length, perPage); // ==> goto step 1 again\n    }\n}\n"
    },
    "contracts/reverseResolver/DefaultReverseResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {AbstractReverseResolver} from \"./AbstractReverseResolver.sol\";\nimport {IStandaloneReverseRegistrar} from \"../reverseRegistrar/IStandaloneReverseRegistrar.sol\";\nimport {INameReverser} from \"./INameReverser.sol\";\nimport {COIN_TYPE_DEFAULT} from \"../utils/ENSIP19.sol\";\n\n/// @title Default Reverse Resolver\n/// @notice Reverses an EVM address using the `IStandaloneReverseRegistrar` for \"default.reverse\".\ncontract DefaultReverseResolver is AbstractReverseResolver {\n    /// @notice The reverse registrar contract for \"default.reverse\".\n    IStandaloneReverseRegistrar public immutable defaultRegistrar;\n\n    constructor(\n        IStandaloneReverseRegistrar _defaultRegistrar\n    ) AbstractReverseResolver(COIN_TYPE_DEFAULT, address(_defaultRegistrar)) {\n        defaultRegistrar = _defaultRegistrar;\n    }\n\n    /// @inheritdoc AbstractReverseResolver\n    function _resolveName(\n        address addr\n    ) internal view override returns (string memory name) {\n        name = defaultRegistrar.nameForAddr(addr);\n    }\n\n    /// @inheritdoc INameReverser\n    function resolveNames(\n        address[] memory addrs,\n        uint8 /*perPage*/\n    ) external view returns (string[] memory names) {\n        names = new string[](addrs.length);\n        for (uint256 i; i < addrs.length; i++) {\n            names[i] = _resolveName(addrs[i]);\n        }\n    }\n}\n"
    },
    "contracts/reverseResolver/ETHReverseResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {AbstractReverseResolver} from \"./AbstractReverseResolver.sol\";\nimport {ENS} from \"../registry/ENS.sol\";\nimport {INameResolver} from \"../resolvers/profiles/INameResolver.sol\";\nimport {IStandaloneReverseRegistrar} from \"../reverseRegistrar/IStandaloneReverseRegistrar.sol\";\nimport {INameReverser} from \"./INameReverser.sol\";\nimport {COIN_TYPE_ETH} from \"../utils/ENSIP19.sol\";\nimport {HexUtils} from \"../utils/HexUtils.sol\";\n\n/// @title Ethereum Reverse Resolver\n/// @notice Reverses an EVM address using the first non-null response from the following sources:\n///         1. `IStandaloneReverseRegistrar` for \"addr.reverse\"\n///         2. `name()` from \"{addr}.addr.reverse\" in V1 Registry\n///         3. `IStandaloneReverseRegistrar` for \"default.reverse\"\ncontract ETHReverseResolver is AbstractReverseResolver {\n    /// @dev Namehash of \"addr.reverse\"\n    bytes32 constant ADDR_REVERSE_NODE =\n        0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\n\n    /// @notice The registry contract.\n    ENS public immutable registry;\n\n    /// @notice The reverse registrar contract for \"addr.reverse\".\n    IStandaloneReverseRegistrar public immutable addrRegistrar;\n\n    /// @notice The reverse registrar contract for \"default.reverse\".\n    IStandaloneReverseRegistrar public immutable defaultRegistrar;\n\n    constructor(\n        ENS ens,\n        IStandaloneReverseRegistrar _addrRegistrar,\n        IStandaloneReverseRegistrar _defaultRegistrar\n    ) AbstractReverseResolver(COIN_TYPE_ETH, address(_addrRegistrar)) {\n        registry = ens;\n        addrRegistrar = _addrRegistrar;\n        defaultRegistrar = _defaultRegistrar;\n    }\n\n    /// @inheritdoc AbstractReverseResolver\n    function _resolveName(\n        address addr\n    ) internal view override returns (string memory name) {\n        name = addrRegistrar.nameForAddr(addr);\n        if (bytes(name).length == 0) {\n            bytes32 node = keccak256(\n                abi.encode(\n                    ADDR_REVERSE_NODE,\n                    keccak256(bytes(HexUtils.addressToHex(addr)))\n                )\n            );\n            address resolver = registry.resolver(node);\n            (bool ok, bytes memory v) = resolver.staticcall{gas: 100000}(\n                abi.encodeCall(INameResolver.name, (node))\n            );\n            if (ok && v.length >= 32) {\n                name = abi.decode(v, (string));\n            }\n            if (bytes(name).length == 0) {\n                name = defaultRegistrar.nameForAddr(addr);\n            }\n        }\n    }\n\n    /// @inheritdoc INameReverser\n    function resolveNames(\n        address[] memory addrs,\n        uint8 /*perPage*/\n    ) external view returns (string[] memory names) {\n        names = new string[](addrs.length);\n        for (uint256 i; i < addrs.length; i++) {\n            names[i] = _resolveName(addrs[i]);\n        }\n    }\n}\n"
    },
    "contracts/reverseResolver/INameReverser.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface INameReverser {\n    /// @notice Resolve multiple EVM addresses to names.\n    ///         Caller should enable EIP-3668.\n    /// @dev This function may execute over multiple steps.\n    /// @param addrs The addresses to resolve.\n    /// @param perPage The maximum number of addresses to resolve per call.\n    ///                Ignored if this function does not revert `OffchainLookup`.\n    /// @return names The resolved names.\n    function resolveNames(\n        address[] memory addrs,\n        uint8 perPage\n    ) external view returns (string[] memory names);\n}\n"
    },
    "contracts/root/Controllable.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract Controllable is Ownable {\n    mapping(address => bool) public controllers;\n\n    event ControllerChanged(address indexed controller, bool enabled);\n\n    modifier onlyController() {\n        require(\n            controllers[msg.sender],\n            \"Controllable: Caller is not a controller\"\n        );\n        _;\n    }\n\n    function setController(address controller, bool enabled) public onlyOwner {\n        controllers[controller] = enabled;\n        emit ControllerChanged(controller, enabled);\n    }\n}\n"
    },
    "contracts/root/Ownable.sol": {
      "content": "pragma solidity ^0.8.4;\n\ncontract Ownable {\n    address public owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    modifier onlyOwner() {\n        require(isOwner(msg.sender));\n        _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n\n    function isOwner(address addr) public view returns (bool) {\n        return owner == addr;\n    }\n}\n"
    },
    "contracts/root/Root.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport \"../registry/ENS.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./Controllable.sol\";\n\ncontract Root is Ownable, Controllable {\n    bytes32 private constant ROOT_NODE = bytes32(0);\n\n    bytes4 private constant INTERFACE_META_ID =\n        bytes4(keccak256(\"supportsInterface(bytes4)\"));\n\n    event TLDLocked(bytes32 indexed label);\n\n    ENS public ens;\n    mapping(bytes32 => bool) public locked;\n\n    constructor(ENS _ens) public {\n        ens = _ens;\n    }\n\n    function setSubnodeOwner(\n        bytes32 label,\n        address owner\n    ) external onlyController {\n        require(!locked[label]);\n        ens.setSubnodeOwner(ROOT_NODE, label, owner);\n    }\n\n    function setResolver(address resolver) external onlyOwner {\n        ens.setResolver(ROOT_NODE, resolver);\n    }\n\n    function lock(bytes32 label) external onlyOwner {\n        emit TLDLocked(label);\n        locked[label] = true;\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) external pure returns (bool) {\n        return interfaceID == INTERFACE_META_ID;\n    }\n}\n"
    },
    "contracts/test/mocks/MockERC20.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.17 <0.9.0;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockERC20 is ERC20 {\n    constructor(\n        string memory name,\n        string memory symbol,\n        address[] memory addresses\n    ) ERC20(name, symbol) {\n        _mint(msg.sender, 100 * 10 ** uint256(decimals()));\n\n        for (uint256 i = 0; i < addresses.length; i++) {\n            _mint(addresses[i], 100 * 10 ** uint256(decimals()));\n        }\n    }\n}\n"
    },
    "contracts/test/mocks/MockERC6492WalletFactory.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.17 <0.9.0;\n// import signatureVerifier by openzepellin\nimport {SignatureChecker} from \"@openzeppelin/contracts-v5/utils/cryptography/SignatureChecker.sol\";\nimport {MockSmartContractWallet} from \"./MockSmartContractWallet.sol\";\n\ncontract MockERC6492WalletFactory {\n    error Create2Failed();\n\n    bytes32 private constant SALT =\n        0x00000000000000000000000000000000000000000000000000000000cafebabe;\n\n    function getInitCode(address owner) private pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                type(MockSmartContractWallet).creationCode,\n                bytes32(uint256(uint160(owner)))\n            );\n    }\n\n    function predictAddress(address owner) public view returns (address) {\n        return\n            address(\n                uint160(\n                    uint256(\n                        keccak256(\n                            abi.encodePacked(\n                                bytes1(0xff),\n                                address(this),\n                                SALT,\n                                keccak256(getInitCode(owner))\n                            )\n                        )\n                    )\n                )\n            );\n    }\n\n    function createWallet(address owner) public returns (address addr) {\n        bytes memory bytecode = getInitCode(owner);\n        assembly (\"memory-safe\") {\n            addr := create2(0, add(bytecode, 0x20), mload(bytecode), SALT)\n            // if no address was created, and returndata is not empty, bubble revert\n            if and(iszero(addr), not(iszero(returndatasize()))) {\n                let p := mload(0x40)\n                returndatacopy(p, 0, returndatasize())\n                revert(p, returndatasize())\n            }\n        }\n\n        if (addr == address(0)) revert Create2Failed();\n    }\n}\n"
    },
    "contracts/test/mocks/MockOffchainResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"../../../contracts/resolvers/profiles/IExtendedResolver.sol\";\n\nerror OffchainLookup(\n    address sender,\n    string[] urls,\n    bytes callData,\n    bytes4 callbackFunction,\n    bytes extraData\n);\n\ncontract MockOffchainResolver is IExtendedResolver, ERC165 {\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override returns (bool) {\n        return\n            interfaceId == type(IExtendedResolver).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    function resolve(\n        bytes calldata /* name */,\n        bytes calldata data\n    ) external view returns (bytes memory) {\n        string[] memory urls = new string[](1);\n        urls[0] = \"https://example.com/\";\n        revert OffchainLookup(\n            address(this),\n            urls,\n            data,\n            MockOffchainResolver.resolveCallback.selector,\n            data\n        );\n    }\n\n    function addr(bytes32) external pure returns (bytes memory) {\n        return abi.encode(\"onchain\");\n    }\n\n    function resolveCallback(\n        bytes calldata response,\n        bytes calldata extraData\n    ) external view returns (bytes memory) {\n        (, bytes memory callData, ) = abi.decode(\n            extraData,\n            (bytes, bytes, bytes4)\n        );\n        if (bytes4(callData) == bytes4(keccak256(\"addr(bytes32)\"))) {\n            (bytes memory result, , ) = abi.decode(\n                response,\n                (bytes, uint64, bytes)\n            );\n            return result;\n        }\n        return abi.encode(address(this));\n    }\n}\n"
    },
    "contracts/test/mocks/MockOwnable.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.17 <0.9.0;\n\ncontract MockOwnable {\n    address public owner;\n\n    constructor(address _owner) {\n        owner = _owner;\n    }\n}\n"
    },
    "contracts/test/mocks/MockReverseClaimerImplementer.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.17 <0.9.0;\n\nimport {ENS} from \"../../../contracts/registry/ENS.sol\";\nimport {ReverseClaimer} from \"../../../contracts/reverseRegistrar/ReverseClaimer.sol\";\n\ncontract MockReverseClaimerImplementer is ReverseClaimer {\n    constructor(ENS ens, address claimant) ReverseClaimer(ens, claimant) {}\n}\n"
    },
    "contracts/test/mocks/MockSmartContractWallet.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.17 <0.9.0;\n// import signatureVerifier by openzepellin\nimport \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\n\ncontract MockSmartContractWallet {\n    address public owner;\n\n    constructor(address _owner) {\n        owner = _owner;\n    }\n\n    function isValidSignature(\n        bytes32 hash,\n        bytes memory signature\n    ) public view returns (bytes4) {\n        if (SignatureChecker.isValidSignatureNow(owner, hash, signature)) {\n            return 0x1626ba7e;\n        }\n        return 0xffffffff;\n    }\n}\n"
    },
    "contracts/universalResolver/AbstractUniversalResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {ERC165Checker} from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nimport {IUniversalResolver} from \"./IUniversalResolver.sol\";\nimport {CCIPBatcher, CCIPReader} from \"../ccipRead/CCIPBatcher.sol\";\nimport {IGatewayProvider} from \"../ccipRead/IGatewayProvider.sol\";\nimport {NameCoder} from \"../utils/NameCoder.sol\";\nimport {BytesUtils} from \"../utils/BytesUtils.sol\";\nimport {ENSIP19, COIN_TYPE_ETH, COIN_TYPE_DEFAULT} from \"../utils/ENSIP19.sol\";\nimport {IFeatureSupporter} from \"../utils/IFeatureSupporter.sol\";\nimport {ResolverFeatures} from \"../resolvers/ResolverFeatures.sol\";\n\n// resolver profiles\nimport {IExtendedResolver} from \"../resolvers/profiles/IExtendedResolver.sol\";\nimport {INameResolver} from \"../resolvers/profiles/INameResolver.sol\";\nimport {IAddrResolver} from \"../resolvers/profiles/IAddrResolver.sol\";\nimport {IAddressResolver} from \"../resolvers/profiles/IAddressResolver.sol\";\nimport {IMulticallable} from \"../resolvers/IMulticallable.sol\";\n\nabstract contract AbstractUniversalResolver is\n    IUniversalResolver,\n    CCIPBatcher,\n    ERC165\n{\n    /// @dev The default batch gateways.\n    IGatewayProvider public immutable batchGatewayProvider;\n\n    constructor(\n        IGatewayProvider _batchGatewayProvider\n    ) CCIPReader(DEFAULT_UNSAFE_CALL_GAS) {\n        batchGatewayProvider = _batchGatewayProvider;\n    }\n\n    /// @inheritdoc ERC165\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(ERC165) returns (bool) {\n        return\n            type(IUniversalResolver).interfaceId == interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /// @inheritdoc IUniversalResolver\n    function findResolver(\n        bytes memory name\n    ) public view virtual returns (address, bytes32, uint256);\n\n    /// @dev A valid resolver and its relevant properties.\n    struct ResolverInfo {\n        bytes name; // dns-encoded name (safe to decode)\n        uint256 offset; // byte offset into name used for resolver\n        bytes32 node; // namehash(name)\n        address resolver;\n        bool extended; // IExtendedResolver\n    }\n\n    /// @dev Returns a valid resolver for `name` or reverts.\n    /// @param name The name to search.\n    /// @return info The resolver information.\n    function requireResolver(\n        bytes memory name\n    ) public view returns (ResolverInfo memory info) {\n        // https://docs.ens.domains/ensip/10\n        (info.resolver, info.node, info.offset) = findResolver(name);\n        info.name = name;\n        _checkResolver(info);\n    }\n\n    /// @dev Asserts that the resolver information is valid.\n    function _checkResolver(ResolverInfo memory info) internal view {\n        if (info.resolver == address(0)) {\n            revert ResolverNotFound(info.name);\n        } else if (\n            ERC165Checker.supportsERC165InterfaceUnchecked(\n                info.resolver,\n                type(IExtendedResolver).interfaceId\n            )\n        ) {\n            info.extended = true;\n        } else if (info.offset != 0) {\n            revert ResolverNotFound(info.name); // immediate resolver requires exact match\n        } else if (info.resolver.code.length == 0) {\n            revert ResolverNotContract(info.name, info.resolver);\n        }\n    }\n\n    /// @notice Same as `resolveWithGateways()` but uses default batch gateways.\n    function resolve(\n        bytes calldata name,\n        bytes calldata data\n    ) external view returns (bytes memory, address) {\n        return resolveWithGateways(name, data, batchGatewayProvider.gateways());\n    }\n\n    /// @notice Performs ENS resolution process for the supplied name and resolution data.\n    ///         Caller should enable EIP-3668.\n    /// @dev This function executes over multiple steps.\n    /// @param name The name to resolve, in normalised and DNS-encoded form.\n    /// @param data The resolution data, as specified in ENSIP-10.\n    /// @param gateways The list of batch gateway URLs to use.\n    /// @return result The encoded response for the requested call.\n    /// @return resolver The address of the resolver that supplied `result`.\n    function resolveWithGateways(\n        bytes calldata name,\n        bytes calldata data,\n        string[] memory gateways\n    ) public view returns (bytes memory result, address resolver) {\n        result;\n        resolver;\n        ResolverInfo memory info = requireResolver(name);\n        _callResolver(\n            info,\n            data,\n            gateways,\n            this.resolveCallback.selector, // ==> step 2\n            abi.encode(info.resolver)\n        );\n    }\n\n    /// @notice Same as `resolveWithGateways()` but uses the supplied resolver.\n    function resolveWithResolver(\n        address resolver,\n        bytes calldata name,\n        bytes calldata data,\n        string[] memory gateways\n    ) external view returns (bytes memory) {\n        ResolverInfo memory info;\n        info.name = name;\n        info.node = NameCoder.namehash(name, 0);\n        info.resolver = resolver;\n        _checkResolver(info);\n        _callResolver(\n            info,\n            data,\n            gateways,\n            this.resolveCallback.selector, // ==> step 2\n            abi.encode(resolver)\n        );\n    }\n\n    /// @dev CCIP-Read callback for `resolveWithGateways()`.\n    /// @param response The response from the resolver.\n    /// @param extraData The contextual data passed from `resolveWith*()`.\n    function resolveCallback(\n        bytes calldata response,\n        bytes calldata extraData\n    ) external pure returns (bytes memory, address) {\n        return (response, abi.decode(extraData, (address)));\n    }\n\n    /// @notice Same as `reverseWithGateways()` but uses default batch gateways.\n    function reverse(\n        bytes calldata lookupAddress,\n        uint256 coinType\n    ) external view returns (string memory, address, address) {\n        return\n            reverseWithGateways(\n                lookupAddress,\n                coinType,\n                batchGatewayProvider.gateways()\n            );\n    }\n\n    struct ReverseArgs {\n        bytes lookupAddress; // parsed input address\n        uint256 coinType; // parsed coinType\n        string[] gateways; // supplied gateways\n        address resolver; // valid reverse resolver\n    }\n\n    /// @notice Performs ENS reverse resolution for the supplied address and coin type.\n    ///         Caller should enable EIP-3668.\n    /// @dev This function executes over multiple steps.\n    /// @param lookupAddress The input address.\n    /// @param coinType The coin type.\n    /// @param gateways The list of batch gateway URLs to use.\n    /// @return primary The resolved primary name.\n    /// @return resolver The resolver address for primary name.\n    /// @return reverseResolver The resolver address for the reverse name.\n    function reverseWithGateways(\n        bytes calldata lookupAddress,\n        uint256 coinType,\n        string[] memory gateways\n    )\n        public\n        view\n        returns (\n            string memory primary,\n            address resolver,\n            address reverseResolver\n        )\n    {\n        primary;\n        resolver;\n        reverseResolver;\n        // https://docs.ens.domains/ensip/19\n        ResolverInfo memory info = requireResolver(\n            NameCoder.encode(ENSIP19.reverseName(lookupAddress, coinType)) // reverts EmptyAddress\n        );\n        _callResolver(\n            info,\n            abi.encodeCall(INameResolver.name, (info.node)),\n            gateways,\n            this.reverseNameCallback.selector, // ==> step 2\n            abi.encode(\n                ReverseArgs(lookupAddress, coinType, gateways, info.resolver)\n            )\n        );\n    }\n\n    /// @dev CCIP-Read callback for `reverseWithGateways()`.\n    /// @param response The abi-encoded `name()` response from the reverse resolver.\n    /// @param extraData The contextual data passed from `reverseWithGateways()`.\n    function reverseNameCallback(\n        bytes calldata response,\n        bytes calldata extraData\n    ) external view returns (string memory primary, address, address) {\n        ReverseArgs memory args = abi.decode(extraData, (ReverseArgs));\n        primary = abi.decode(response, (string));\n        if (bytes(primary).length == 0) {\n            return (\"\", address(0), args.resolver);\n        }\n        ResolverInfo memory info = requireResolver(NameCoder.encode(primary));\n        _callResolver(\n            info,\n            args.coinType == COIN_TYPE_ETH\n                ? abi.encodeCall(IAddrResolver.addr, (info.node))\n                : abi.encodeCall(\n                    IAddressResolver.addr,\n                    (info.node, args.coinType)\n                ),\n            args.gateways,\n            this.reverseAddressCallback.selector, // ==> step 3\n            abi.encode(args, primary, info.resolver)\n        );\n    }\n\n    /// @dev CCIP-Read callback for `reverseNameCallback()`.\n    ///      Reverts `ReverseAddressMismatch`.\n    /// @param response The abi-encoded `addr()` response from the forward resolver.\n    /// @param extraData The contextual data passed from `reverseNameCallback()`.\n    function reverseAddressCallback(\n        bytes calldata response,\n        bytes calldata extraData\n    )\n        external\n        pure\n        returns (\n            string memory primary,\n            address resolver,\n            address reverseResolver\n        )\n    {\n        ReverseArgs memory args;\n        (args, primary, resolver) = abi.decode(\n            extraData,\n            (ReverseArgs, string, address)\n        );\n        bytes memory primaryAddress;\n        if (args.coinType == COIN_TYPE_ETH) {\n            address addr = abi.decode(response, (address));\n            primaryAddress = abi.encodePacked(addr);\n        } else {\n            primaryAddress = abi.decode(response, (bytes));\n        }\n        if (!BytesUtils.equals(args.lookupAddress, primaryAddress)) {\n            revert ReverseAddressMismatch(primary, primaryAddress);\n        }\n        reverseResolver = args.resolver;\n    }\n\n    /// @dev Efficiently call a resolver.\n    ///      If features are supported, and not a multicall or extended w/`RESOLVE_MULTICALL`, performs a direct call.\n    ///      Otherwise, uses the batch gateway.\n    /// @param info The resolver to call.\n    /// @param call The calldata.\n    /// @param gateways The list of batch gateway URLs to use.\n    /// @param callbackFunction The function selector to call after resolution.\n    /// @param extraData The contextual data passed to `callbackFunction`.\n    function _callResolver(\n        ResolverInfo memory info,\n        bytes memory call,\n        string[] memory gateways,\n        bytes4 callbackFunction,\n        bytes memory extraData\n    ) internal view {\n        if (\n            ERC165Checker.supportsERC165InterfaceUnchecked(\n                info.resolver,\n                type(IFeatureSupporter).interfaceId\n            ) &&\n            (bytes4(call) != IMulticallable.multicall.selector ||\n                (info.extended &&\n                    IFeatureSupporter(info.resolver).supportsFeature(\n                        ResolverFeatures.RESOLVE_MULTICALL\n                    )))\n        ) {\n            ccipRead(\n                address(info.resolver),\n                info.extended\n                    ? abi.encodeCall(\n                        IExtendedResolver.resolve,\n                        (info.name, call)\n                    )\n                    : call,\n                this.resolveDirectCallback.selector,\n                this.resolveDirectCallbackError.selector,\n                abi.encode(\n                    info.extended,\n                    bytes4(call),\n                    callbackFunction,\n                    extraData\n                )\n            );\n        } else {\n            bytes[] memory calls;\n            bool multi = bytes4(call) == IMulticallable.multicall.selector;\n            if (multi) {\n                calls = abi.decode(\n                    BytesUtils.substring(call, 4, call.length - 4),\n                    (bytes[])\n                );\n            } else {\n                calls = new bytes[](1);\n                calls[0] = call;\n            }\n            if (info.extended) {\n                for (uint256 i; i < calls.length; ++i) {\n                    calls[i] = abi.encodeCall(\n                        IExtendedResolver.resolve,\n                        (info.name, calls[i])\n                    );\n                }\n            }\n            ccipRead(\n                address(this),\n                abi.encodeCall(\n                    this.ccipBatch,\n                    (createBatch(info.resolver, calls, gateways))\n                ),\n                this.resolveBatchCallback.selector,\n                IDENTITY_FUNCTION,\n                abi.encode(info.extended, multi, callbackFunction, extraData)\n            );\n        }\n    }\n\n    /// @dev CCIP-Read callback for `_callResolver()` from calling the resolver successfully.\n    function resolveDirectCallback(\n        bytes memory response,\n        bytes calldata extraData\n    ) external view {\n        (\n            bool extended,\n            bytes4 callSelector,\n            bytes4 callbackFunction,\n            bytes memory extraData_\n        ) = abi.decode(extraData, (bool, bytes4, bytes4, bytes));\n        if (response.length == 0) {\n            revert UnsupportedResolverProfile(callSelector);\n        }\n        if (extended) {\n            response = abi.decode(response, (bytes)); // unwrap resolve()\n        }\n        ccipRead(\n            address(this),\n            abi.encodeWithSelector(callbackFunction, response, extraData_)\n        );\n    }\n\n    /// @dev CCIP-Read callback for `_callResolver()` from calling the resolver unsuccessfully.\n    function resolveDirectCallbackError(\n        bytes calldata response,\n        bytes calldata\n    ) external pure {\n        _propagateResolverError(response);\n    }\n\n    /// @dev CCIP-Read callback for `_callResolver()` from calling the batch gateway successfully.\n    function resolveBatchCallback(\n        bytes calldata response,\n        bytes calldata extraData\n    ) external view {\n        Lookup[] memory lookups = abi.decode(response, (Batch)).lookups;\n        (\n            bool extended,\n            bool multi,\n            bytes4 callbackFunction,\n            bytes memory extraData_\n        ) = abi.decode(extraData, (bool, bool, bytes4, bytes));\n        bytes memory answer;\n        if (multi) {\n            bytes[] memory m = new bytes[](lookups.length);\n            for (uint256 i; i < lookups.length; ++i) {\n                Lookup memory lu = lookups[i];\n                bytes memory v = lu.data;\n                if (extended && (lu.flags & FLAGS_ANY_ERROR) == 0) {\n                    v = abi.decode(v, (bytes)); // unwrap resolve()\n                }\n                m[i] = v;\n            }\n            answer = abi.encode(m);\n        } else {\n            Lookup memory lu = lookups[0];\n            answer = lu.data;\n            if ((lu.flags & FLAG_BATCH_ERROR) != 0) {\n                assembly {\n                    revert(add(answer, 32), mload(answer)) // propagate batch gateway errors\n                }\n            } else if ((lu.flags & FLAG_CALL_ERROR) != 0) {\n                _propagateResolverError(answer);\n            } else if (answer.length == 0) {\n                revert UnsupportedResolverProfile(bytes4(lu.call));\n            }\n            if (extended) {\n                answer = abi.decode(answer, (bytes)); // unwrap resolve()\n            }\n        }\n        ccipRead(\n            address(this),\n            abi.encodeWithSelector(callbackFunction, answer, extraData_)\n        );\n    }\n\n    /// @dev Propagate the revert from the resolver.\n    /// @param v The error data.\n    function _propagateResolverError(bytes memory v) internal pure {\n        if (bytes4(v) == UnsupportedResolverProfile.selector) {\n            assembly {\n                revert(add(v, 32), mload(v))\n            }\n        } else {\n            revert ResolverError(v);\n        }\n    }\n}\n"
    },
    "contracts/universalResolver/IUniversalResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Interface for the UniversalResolver.\n/// @dev Interface selector: `0xcd191b34`\ninterface IUniversalResolver {\n    /// @notice A resolver could not be found for the supplied name.\n    /// @dev Error selector: `0x77209fe8`\n    error ResolverNotFound(bytes name);\n\n    /// @notice The resolver is not a contract.\n    /// @dev Error selector: `0x1e9535f2`\n    error ResolverNotContract(bytes name, address resolver);\n\n    /// @notice The resolver did not respond.\n    /// @dev Error selector: `0x7b1c461b`\n    error UnsupportedResolverProfile(bytes4 selector);\n\n    /// @notice The resolver returned an error.\n    /// @dev Error selector: `0x95c0c752`\n    error ResolverError(bytes errorData);\n\n    /// @notice The resolved address from reverse resolution does not match the supplied address.\n    /// @dev Error selector: `0xef9c03ce`\n    error ReverseAddressMismatch(string primary, bytes primaryAddress);\n\n    /// @notice An HTTP error occurred on a resolving gateway.\n    /// @dev Error selector: `0x01800152`\n    error HttpError(uint16 status, string message);\n\n    /// @dev Find the resolver address for `name`.\n    ///      Does not perform any validity checks on the resolver.\n    /// @param name The name to search.\n    /// @return resolver The resolver or `address(0)` if not found.\n    /// @return node The namehash of `name`.\n    /// @return offset The offset into `name` corresponding to `resolver`.\n    function findResolver(\n        bytes memory name\n    ) external view returns (address resolver, bytes32 node, uint256 offset);\n\n    /// @notice Performs ENS name resolution for the supplied name and resolution data.\n    /// @notice Caller should enable EIP-3668.\n    /// @param name The name to resolve, in normalised and DNS-encoded form.\n    /// @param data The resolution data, as specified in ENSIP-10.\n    ///             For a multicall, the data should be encoded as `multicall(bytes[])`.\n    /// @return result The result of the resolution.\n    ///                For a multicall, the result is encoded as `(bytes[])`.\n    /// @return resolver The resolver that was used to resolve the name.\n    function resolve(\n        bytes calldata name,\n        bytes calldata data\n    ) external view returns (bytes memory result, address resolver);\n\n    /// @notice Performs ENS reverse resolution for the supplied address and coin type.\n    /// @notice Caller should enable EIP-3668.\n    /// @param lookupAddress The address to reverse resolve, in encoded form.\n    /// @param coinType The coin type to use for the reverse resolution.\n    ///                 For ETH, this is 60.\n    ///                 For other EVM chains, coinType is calculated as `0x80000000 | chainId`.\n    /// @return primary The reverse resolution result.\n    /// @return resolver The resolver that was used to resolve the name.\n    /// @return reverseResolver The resolver that was used to resolve the reverse name.\n    function reverse(\n        bytes calldata lookupAddress,\n        uint256 coinType\n    )\n        external\n        view\n        returns (\n            string memory primary,\n            address resolver,\n            address reverseResolver\n        );\n}\n"
    },
    "contracts/universalResolver/mocks/DummyShapeshiftResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {IFeatureSupporter} from \"../../utils/IFeatureSupporter.sol\";\nimport {IExtendedResolver} from \"../../resolvers/profiles/IExtendedResolver.sol\";\nimport {IMulticallable} from \"../../resolvers/IMulticallable.sol\";\nimport {OffchainLookup} from \"../../ccipRead/EIP3668.sol\";\n\n/// @dev This resolver can perform all resolver permutations.\n///      When this contract triggers OffchainLookup(), it uses a data-url, so no server is required.\n///      The actual response is set using `setResponse()`.\ncontract DummyShapeshiftResolver is\n    IExtendedResolver,\n    IERC165,\n    IFeatureSupporter\n{\n    // https://github.com/ensdomains/ensips/pull/18\n    error UnsupportedResolverProfile(bytes4 call);\n\n    mapping(bytes => bytes) public responses;\n    mapping(bytes4 => bool) public features;\n    uint256 public featureCount;\n    bool public isERC165 = true; // default\n    bool public isExtended;\n    bool public isOffchain;\n    bool public revertUnsupported;\n    bool public revertEmpty;\n\n    function setResponse(bytes memory req, bytes memory res) external {\n        responses[req] = res;\n    }\n\n    function setFeature(bytes4 feature, bool on) external {\n        if (features[feature] != on) {\n            features[feature] = on;\n            featureCount = on ? featureCount + 1 : featureCount - 1;\n        }\n    }\n\n    function setOld() external {\n        isERC165 = false;\n        isExtended = false;\n    }\n\n    function setExtended(bool x) external {\n        isERC165 = true;\n        isExtended = x;\n    }\n\n    function setOffchain(bool x) external {\n        isOffchain = x;\n    }\n\n    function setRevertUnsupportedResolverProfile(bool x) external {\n        revertUnsupported = x;\n    }\n\n    function setRevertEmpty(bool x) external {\n        revertEmpty = x;\n    }\n\n    fallback() external {\n        if (isExtended) return;\n        bytes memory v = responses[msg.data];\n        if (v.length == 0) {\n            if (revertEmpty) {\n                assembly {\n                    revert(0, 0)\n                }\n            }\n            return;\n        }\n        if (isOffchain) _revertOffchain(v);\n        _revertIfError(v);\n        assembly {\n            return(add(v, 32), mload(v))\n        }\n    }\n\n    function supportsInterface(bytes4 x) external view returns (bool) {\n        if (!isERC165) {\n            assembly {\n                return(0, 0)\n            }\n        }\n        return\n            type(IERC165).interfaceId == x ||\n            (type(IExtendedResolver).interfaceId == x && isExtended) ||\n            (type(IFeatureSupporter).interfaceId == x && featureCount > 0);\n    }\n\n    function supportsFeature(bytes4 x) external view returns (bool) {\n        return features[x];\n    }\n\n    function resolve(\n        bytes memory,\n        bytes memory call\n    ) external view returns (bytes memory) {\n        bytes memory v = responses[call];\n        if (v.length == 0 && revertUnsupported) {\n            revert UnsupportedResolverProfile(bytes4(call));\n        }\n        if (isOffchain) _revertOffchain(v);\n        _revertIfError(v);\n        return v;\n    }\n\n    function _revertOffchain(bytes memory v) internal view {\n        string[] memory urls = new string[](1);\n        urls[0] = 'data:application/json,{\"data\":\"0x\"}';\n        revert OffchainLookup(\n            address(this),\n            urls,\n            \"\",\n            this.callback.selector,\n            v\n        );\n    }\n\n    function callback(\n        bytes memory,\n        bytes memory v\n    ) external view returns (bytes memory) {\n        _revertIfError(v);\n        if (isExtended) return v;\n        assembly {\n            return(add(v, 32), mload(v))\n        }\n    }\n\n    function _revertIfError(bytes memory v) internal pure {\n        if ((v.length & 31) != 0) {\n            assembly {\n                revert(add(v, 32), mload(v))\n            }\n        }\n    }\n\n    // function enableMulticall(bytes[] memory calls) external {\n    //     bytes[] memory m = new bytes[](calls.length);\n    //     for (uint256 i; i < calls.length; i++) {\n    //         m[i] = responses[calls[i]];\n    //     }\n    //     setResponse(\n    //         abi.encodeCall(IResolveMulticall.multicall, (calls)),\n    //         abi.encode(m)\n    //     );\n    // }\n}\n"
    },
    "contracts/universalResolver/RegistryUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ENS} from \"../registry/ENS.sol\";\nimport {NameCoder} from \"../utils/NameCoder.sol\";\n\nlibrary RegistryUtils {\n    /// @notice Find the resolver for `name[offset:]`.\n    /// @dev Reverts `DNSDecodingFailed`.\n    /// @param registry The ENS registry.\n    /// @param name The DNS-encoded name to search.\n    /// @param offset The offset into `name` to begin the search.\n    /// @return resolver The resolver or `address(0)` if not found.\n    /// @return node The namehash of `name[offset:]`.\n    /// @return resolverOffset The offset into `name` corresponding to `resolver`.\n    function findResolver(\n        ENS registry,\n        bytes memory name,\n        uint256 offset\n    )\n        internal\n        view\n        returns (address resolver, bytes32 node, uint256 resolverOffset)\n    {\n        (bytes32 labelHash, uint256 next) = NameCoder.readLabel(name, offset);\n        if (labelHash != bytes32(0)) {\n            (\n                address parentResolver,\n                bytes32 parentNode,\n                uint256 parentOffset\n            ) = findResolver(registry, name, next);\n            node = NameCoder.namehash(parentNode, labelHash);\n            resolver = registry.resolver(node);\n            return\n                resolver != address(0)\n                    ? (resolver, node, offset)\n                    : (parentResolver, node, parentOffset);\n        }\n    }\n}\n"
    },
    "contracts/universalResolver/UniversalResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {AbstractUniversalResolver, IGatewayProvider} from \"./AbstractUniversalResolver.sol\";\nimport {RegistryUtils, ENS} from \"./RegistryUtils.sol\";\nimport {ReverseClaimer} from \"../reverseRegistrar/ReverseClaimer.sol\";\n\ncontract UniversalResolver is AbstractUniversalResolver, ReverseClaimer {\n    ENS public immutable registry;\n\n    constructor(\n        address owner,\n        ENS ens,\n        IGatewayProvider batchGatewayProvider\n    )\n        AbstractUniversalResolver(batchGatewayProvider)\n        ReverseClaimer(ens, owner)\n    {\n        registry = ens;\n    }\n\n    /// @inheritdoc AbstractUniversalResolver\n    function findResolver(\n        bytes memory name\n    ) public view override returns (address, bytes32, uint256) {\n        return RegistryUtils.findResolver(registry, name, 0);\n    }\n}\n"
    },
    "contracts/utils/AddressUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nlibrary AddressUtils {\n    // This is the hex encoding of the string 'abcdefghijklmnopqrstuvwxyz'\n    // It is used as a constant to lookup the characters of the hex address\n    bytes32 constant lookup =\n        0x3031323334353637383961626364656600000000000000000000000000000000;\n\n    /**\n     * @dev An optimised function to compute the sha3 of the lower-case\n     *      hexadecimal representation of an Ethereum address.\n     * @param addr The address to hash\n     * @return ret The SHA3 hash of the lower-case hexadecimal encoding of the\n     *         input address.\n     */\n    function sha3HexAddress(address addr) internal pure returns (bytes32 ret) {\n        assembly {\n            for {\n                let i := 40\n            } gt(i, 0) {} {\n                i := sub(i, 1)\n                mstore8(i, byte(and(addr, 0xf), lookup))\n                addr := div(addr, 0x10)\n                i := sub(i, 1)\n                mstore8(i, byte(and(addr, 0xf), lookup))\n                addr := div(addr, 0x10)\n            }\n\n            ret := keccak256(0, 40)\n        }\n    }\n}\n"
    },
    "contracts/utils/BytesUtils_LEGACY.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n// ********************************************************************************\n/// @dev DO NOT USE THIS CONTRACT\n/// This library is provided so NameWrapper can remain unmodified.\n/// The rest of the repo can switch to NameCoder, w/hashed label support.\n// ********************************************************************************\n\nimport {BytesUtils} from \"./BytesUtils.sol\";\n\nlibrary BytesUtils_LEGACY {\n    /// @dev Returns the ENS namehash of a DNS-encoded name.\n    /// @param self The DNS-encoded name to hash.\n    /// @param offset The offset at which to start hashing.\n    /// @return The namehash of the name.\n    function namehash(\n        bytes memory self,\n        uint256 offset\n    ) internal pure returns (bytes32) {\n        (bytes32 labelhash, uint256 newOffset) = readLabel(self, offset);\n        if (labelhash == bytes32(0)) {\n            require(offset == self.length - 1, \"namehash: Junk at end of name\");\n            return bytes32(0);\n        }\n        return\n            keccak256(abi.encodePacked(namehash(self, newOffset), labelhash));\n    }\n\n    /// @dev Returns the keccak-256 hash of a DNS-encoded label, and the offset to the start of the next label.\n    /// @param self The byte string to read a label from.\n    /// @param idx The index to read a label at.\n    /// @return labelhash The hash of the label at the specified index, or 0 if it is the last label.\n    /// @return newIdx The index of the start of the next label.\n    function readLabel(\n        bytes memory self,\n        uint256 idx\n    ) internal pure returns (bytes32 labelhash, uint256 newIdx) {\n        require(idx < self.length, \"readLabel: Index out of bounds\");\n        uint256 len = uint256(uint8(self[idx]));\n        if (len > 0) {\n            labelhash = BytesUtils.keccak(self, idx + 1, len);\n        } else {\n            labelhash = bytes32(0);\n        }\n        newIdx = idx + len + 1;\n    }\n}\n"
    },
    "contracts/utils/BytesUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nlibrary BytesUtils {\n    /// @dev `offset` was beyond `length`.\n    ///       Error selector: `0x8a3c1cfb`\n    error OffsetOutOfBoundsError(uint256 offset, uint256 length);\n\n    /// @dev Assert `end` is not beyond the length of `v`.\n    function _checkBound(bytes memory v, uint256 end) internal pure {\n        if (end > v.length) {\n            revert OffsetOutOfBoundsError(end, v.length);\n        }\n    }\n\n    /// @dev Compute `keccak256(v[off:off+len])`.\n    /// @param v The source bytes.\n    /// @param off The offset into the source.\n    /// @param len The number of bytes to hash.\n    /// @return ret The corresponding hash.\n    function keccak(\n        bytes memory v,\n        uint256 off,\n        uint256 len\n    ) internal pure returns (bytes32 ret) {\n        _checkBound(v, off + len);\n        assembly {\n            ret := keccak256(add(add(v, 32), off), len)\n        }\n    }\n\n    /// @dev Lexicographically compare two byte strings.\n    /// @param vA The first bytes to compare.\n    /// @param vB The second bytes to compare.\n    /// @return Positive number if `A > B`, negative number if `A < B`, or zero if `A == B`.\n    function compare(\n        bytes memory vA,\n        bytes memory vB\n    ) internal pure returns (int256) {\n        return compare(vA, 0, vA.length, vB, 0, vB.length);\n    }\n\n    /// @dev Lexicographically compare two byte ranges: `A = vA[offA:offA+lenA]` and `B = vB[offB:offB+lenB]`.\n    /// @param vA The first bytes.\n    /// @param offA The offset of the first bytes.\n    /// @param lenA The length of the first bytes.\n    /// @param vB The second bytes.\n    /// @param offB The offset of the second bytes.\n    /// @param lenB The length of the second bytes.\n    /// @return Positive number if `A > B`, negative number if `A < B`, or zero if `A == B`.\n    function compare(\n        bytes memory vA,\n        uint256 offA,\n        uint256 lenA,\n        bytes memory vB,\n        uint256 offB,\n        uint256 lenB\n    ) internal pure returns (int256) {\n        _checkBound(vA, offA + lenA);\n        _checkBound(vB, offB + lenB);\n        uint256 ptrA;\n        uint256 ptrB;\n        assembly {\n            ptrA := add(vA, offA)\n            ptrB := add(vB, offB)\n        }\n        uint256 shortest = lenA < lenB ? lenA : lenB;\n        for (uint256 i; i < shortest; i += 32) {\n            uint256 a;\n            uint256 b;\n            assembly {\n                ptrA := add(ptrA, 32)\n                ptrB := add(ptrB, 32)\n                a := mload(ptrA)\n                b := mload(ptrB)\n            }\n            if (a != b) {\n                uint256 rest = shortest - i;\n                if (rest < 32) {\n                    rest = (32 - rest) << 3; // bits to drop\n                    a >>= rest; // shift out the\n                    b >>= rest; // irrelevant bits\n                }\n                if (a < b) {\n                    return -1;\n                } else if (a > b) {\n                    return 1;\n                }\n            }\n        }\n        return int256(lenA) - int256(lenB);\n    }\n\n    /// @dev Determine if `a[offA:offA+len] == b[offB:offB+len]`.\n    /// @param vA The first bytes.\n    /// @param offA The offset into the first bytes.\n    /// @param vB The second bytes.\n    /// @param offB The offset into the second bytes.\n    /// @param len The number of bytes to compare.\n    /// @return True if the byte ranges are equal.\n    function equals(\n        bytes memory vA,\n        uint256 offA,\n        bytes memory vB,\n        uint256 offB,\n        uint256 len\n    ) internal pure returns (bool) {\n        return keccak(vA, offA, len) == keccak(vB, offB, len);\n    }\n\n    /// @dev Determine if `a[offA:] == b[offB:]`.\n    /// @param vA The first bytes.\n    /// @param offA The offset into the first bytes.\n    /// @param vB The second bytes.\n    /// @param offB The offset into the second bytes.\n    /// @return True if the byte ranges are equal.\n    function equals(\n        bytes memory vA,\n        uint256 offA,\n        bytes memory vB,\n        uint256 offB\n    ) internal pure returns (bool) {\n        _checkBound(vA, offA);\n        _checkBound(vB, offB);\n        return\n            keccak(vA, offA, vA.length - offA) ==\n            keccak(vB, offB, vB.length - offB);\n    }\n\n    /// @dev Determine if `a[offA:] == b`.\n    /// @param vA The first bytes.\n    /// @param offA The offset into the first bytes.\n    /// @param vB The second bytes.\n    /// @return True if the byte ranges are equal.\n    function equals(\n        bytes memory vA,\n        uint256 offA,\n        bytes memory vB\n    ) internal pure returns (bool) {\n        return\n            vA.length == offA + vB.length &&\n            keccak(vA, offA, vB.length) == keccak256(vB);\n    }\n\n    /// @dev Determine if `a == b`.\n    /// @param vA The first bytes.\n    /// @param vB The second bytes.\n    /// @return True if the bytes are equal.\n    function equals(\n        bytes memory vA,\n        bytes memory vB\n    ) internal pure returns (bool) {\n        return vA.length == vB.length && keccak256(vA) == keccak256(vB);\n    }\n\n    /// @dev Returns `uint8(v[off])`.\n    /// @param v The source bytes.\n    /// @param off The offset into the source.\n    /// @return The corresponding `uint8`.\n    function readUint8(\n        bytes memory v,\n        uint256 off\n    ) internal pure returns (uint8) {\n        _checkBound(v, off + 1);\n        return uint8(v[off]);\n    }\n\n    /// @dev Returns `uint16(bytes2(v[off:off+2]))`.\n    /// @param v The source bytes.\n    /// @param off The offset into the source.\n    /// @return ret The corresponding `uint16`.\n    function readUint16(\n        bytes memory v,\n        uint256 off\n    ) internal pure returns (uint16 ret) {\n        _checkBound(v, off + 2);\n        assembly {\n            ret := shr(240, mload(add(add(v, 32), off)))\n        }\n    }\n\n    /// @dev Returns `uint32(bytes4(v[off:off+4]))`.\n    /// @param v The source bytes.\n    /// @param off The offset into the source.\n    /// @return ret The corresponding `uint32`.\n    function readUint32(\n        bytes memory v,\n        uint256 off\n    ) internal pure returns (uint32 ret) {\n        _checkBound(v, off + 4);\n        assembly {\n            ret := shr(224, mload(add(add(v, 32), off)))\n        }\n    }\n\n    /// @dev Returns `bytes20(v[off:off+20])`.\n    /// @param v The source bytes.\n    /// @param off The offset into the source.\n    /// @return ret The corresponding `bytes20`.\n    function readBytes20(\n        bytes memory v,\n        uint256 off\n    ) internal pure returns (bytes20 ret) {\n        _checkBound(v, off + 20);\n        assembly {\n            ret := shl(96, mload(add(add(v, 20), off)))\n        }\n    }\n\n    /// @dev Returns `bytes32(v[off:off+32])`.\n    /// @param v The source bytes.\n    /// @param off The offset into the source.\n    /// @return ret The corresponding `bytes32`.\n    function readBytes32(\n        bytes memory v,\n        uint256 off\n    ) internal pure returns (bytes32 ret) {\n        _checkBound(v, off + 32);\n        assembly {\n            ret := mload(add(add(v, 32), off))\n        }\n    }\n\n    /// @dev Returns `bytes32(bytesN(v[off:off+len]))`.\n    ///      Accepts 0-32 bytes or reverts.\n    /// @param v The source bytes.\n    /// @param off The offset into the source.\n    /// @param len The number of bytes.\n    /// @return ret The corresponding N-bytes left-aligned in a `bytes32`.\n    function readBytesN(\n        bytes memory v,\n        uint256 off,\n        uint256 len\n    ) internal pure returns (bytes32 ret) {\n        assert(len <= 32);\n        _checkBound(v, off + len);\n        assembly {\n            let mask := sub(shl(shl(3, sub(32, len)), 1), 1) // <(32-N)x00><NxFF>\n            ret := and(mload(add(add(v, 32), off)), not(mask))\n        }\n    }\n\n    /// @dev Copy `mem[src:src+len]` to `mem[dst:dst+len]`.\n    /// @param src The source memory offset.\n    /// @param dst The destination memory offset.\n    /// @param len The number of bytes to copy.\n    function unsafeMemcpy(uint256 dst, uint256 src, uint256 len) internal pure {\n        assembly {\n            // Copy word-length chunks while offsible\n            // prettier-ignore\n            for {} gt(len, 31) {} {\n                mstore(dst, mload(src))\n                dst := add(dst, 32)\n                src := add(src, 32)\n                len := sub(len, 32)\n            }\n            // Copy remaining bytes\n            if len {\n                let mask := sub(shl(shl(3, sub(32, len)), 1), 1) // see above\n                let wSrc := and(mload(src), not(mask))\n                let wDst := and(mload(dst), mask)\n                mstore(dst, or(wSrc, wDst))\n            }\n        }\n    }\n\n    /// @dev Copy `vSrc[offSrc:offSrc+len]` to `vDst[offDst:offDst:len]`.\n    /// @param vSrc The source bytes.\n    /// @param offSrc The offset into the source to begin the copy.\n    /// @param vDst The destination bytes.\n    /// @param offDst The offset into the destination to place the copy.\n    /// @param len The number of bytes to copy.\n    function copyBytes(\n        bytes memory vSrc,\n        uint256 offSrc,\n        bytes memory vDst,\n        uint256 offDst,\n        uint256 len\n    ) internal pure {\n        _checkBound(vSrc, offSrc + len);\n        _checkBound(vDst, offDst + len);\n        uint256 src;\n        uint256 dst;\n        assembly {\n            src := add(add(vSrc, 32), offSrc)\n            dst := add(add(vDst, 32), offDst)\n        }\n        unsafeMemcpy(dst, src, len);\n    }\n\n    /// @dev Copies a substring into a new byte string.\n    /// @param vSrc The byte string to copy from.\n    /// @param off The offset to start copying at.\n    /// @param len The number of bytes to copy.\n    /// @return vDst The copied substring.\n    function substring(\n        bytes memory vSrc,\n        uint256 off,\n        uint256 len\n    ) internal pure returns (bytes memory vDst) {\n        vDst = new bytes(len);\n        copyBytes(vSrc, off, vDst, 0, len);\n    }\n\n    /// @dev Find the first occurrence of `needle`.\n    /// @param v The bytes to search.\n    /// @param off The offset to start searching.\n    /// @param len The number of bytes to search.\n    /// @param needle The byte to search for.\n    /// @return The offset of `needle`, or `type(uint256).max` if not found.\n    function find(\n        bytes memory v,\n        uint256 off,\n        uint256 len,\n        bytes1 needle\n    ) internal pure returns (uint256) {\n        for (uint256 end = off + len; off < end; off++) {\n            if (v[off] == needle) {\n                return off;\n            }\n        }\n        return type(uint256).max;\n    }\n}\n"
    },
    "contracts/utils/ENSIP19.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {HexUtils} from \"../utils/HexUtils.sol\";\nimport {NameCoder} from \"../utils/NameCoder.sol\";\n\nuint32 constant CHAIN_ID_ETH = 1;\n\nuint256 constant COIN_TYPE_ETH = 60;\nuint256 constant COIN_TYPE_DEFAULT = 1 << 31; // 0x8000_0000\n\nstring constant SLUG_ETH = \"addr\"; // <=> COIN_TYPE_ETH\nstring constant SLUG_DEFAULT = \"default\"; // <=> COIN_TYPE_DEFAULT\nstring constant TLD_REVERSE = \"reverse\";\n\n/// @dev Library for generating reverse names according to ENSIP-19.\n/// https://docs.ens.domains/ensip/19\nlibrary ENSIP19 {\n    /// @dev The supplied address was `0x`.\n    ///      Error selector: `0x7138356f`\n    error EmptyAddress();\n\n    /// @dev Extract Chain ID from `coinType`.\n    /// @param coinType The coin type.\n    /// @return The Chain ID or 0 if non-EVM Chain.\n    function chainFromCoinType(\n        uint256 coinType\n    ) internal pure returns (uint32) {\n        if (coinType == COIN_TYPE_ETH) return CHAIN_ID_ETH;\n        coinType ^= COIN_TYPE_DEFAULT;\n        return uint32(coinType < COIN_TYPE_DEFAULT ? coinType : 0);\n    }\n\n    /// @dev Determine if Coin Type is for an EVM address.\n    /// @param coinType The coin type.\n    /// @return True if coin type represents an EVM address.\n    function isEVMCoinType(uint256 coinType) internal pure returns (bool) {\n        return coinType == COIN_TYPE_DEFAULT || chainFromCoinType(coinType) > 0;\n    }\n\n    /// @dev Generate Reverse Name from Address + Coin Type.\n    ///      Reverts `EmptyAddress` if `addressBytes` is `0x`.\n    /// @param addressBytes The input address.\n    /// @param coinType The coin type.\n    /// @return The ENS reverse name, eg. `1234abcd.addr.reverse`.\n    function reverseName(\n        bytes memory addressBytes,\n        uint256 coinType\n    ) internal pure returns (string memory) {\n        if (addressBytes.length == 0) {\n            revert EmptyAddress();\n        }\n        return\n            string(\n                abi.encodePacked(\n                    HexUtils.bytesToHex(addressBytes),\n                    bytes1(\".\"),\n                    coinType == COIN_TYPE_ETH\n                        ? SLUG_ETH\n                        : coinType == COIN_TYPE_DEFAULT\n                            ? SLUG_DEFAULT\n                            : HexUtils.unpaddedUintToHex(coinType, true),\n                    bytes1(\".\"),\n                    TLD_REVERSE\n                )\n            );\n    }\n\n    /// @dev Parse Reverse Name into Address + Coin Type.\n    ///      Matches: `/^[0-9a-fA-F]+\\.([0-9a-f]{1,64}|addr|default)\\.reverse$/`.\n    ///      Reverts `DNSDecodingFailed`.\n    /// @param name The DNS-encoded name.\n    /// @return addressBytes The address or empty if invalid.\n    /// @return coinType The coin type.\n    function parse(\n        bytes memory name\n    ) internal pure returns (bytes memory addressBytes, uint256 coinType) {\n        (, uint256 offset) = NameCoder.readLabel(name, 0);\n        bool valid;\n        (addressBytes, valid) = HexUtils.hexToBytes(name, 1, offset);\n        if (!valid || addressBytes.length == 0) return (\"\", 0); // addressBytes not 1+ hex\n        (valid, coinType) = parseNamespace(name, offset);\n        if (!valid) return (\"\", 0); // invalid namespace\n    }\n\n    /// @dev Parse Reverse Namespace into Coin Type.\n    ///      Matches: `/^([0-9a-f]{1,64}|addr|default)\\.reverse$/`.\n    ///      Reverts `DNSDecodingFailed`.\n    /// @param name The DNS-encoded name.\n    /// @param offset The offset to begin parsing.\n    /// @return valid True if a valid reverse namespace.\n    /// @return coinType The coin type.\n    function parseNamespace(\n        bytes memory name,\n        uint256 offset\n    ) internal pure returns (bool valid, uint256 coinType) {\n        (bytes32 labelHash, uint256 offsetTLD) = NameCoder.readLabel(\n            name,\n            offset\n        );\n        if (labelHash == keccak256(bytes(SLUG_ETH))) {\n            coinType = COIN_TYPE_ETH;\n        } else if (labelHash == keccak256(bytes(SLUG_DEFAULT))) {\n            coinType = COIN_TYPE_DEFAULT;\n        } else if (labelHash == bytes32(0)) {\n            return (false, 0); // no slug\n        } else {\n            (bytes32 word, bool validHex) = HexUtils.hexStringToBytes32(\n                name,\n                1 + offset,\n                offsetTLD\n            );\n            if (!validHex) return (false, 0); // invalid coinType or too long\n            coinType = uint256(word);\n        }\n        (labelHash, offset) = NameCoder.readLabel(name, offsetTLD);\n        if (labelHash != keccak256(bytes(TLD_REVERSE))) return (false, 0); // invalid tld\n        (labelHash, ) = NameCoder.readLabel(name, offset);\n        if (labelHash != bytes32(0)) return (false, 0); // not tld\n        valid = true;\n    }\n}\n"
    },
    "contracts/utils/ERC20Recoverable.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @notice Contract is used to recover ERC20 tokens sent to the contract by mistake.\n\ncontract ERC20Recoverable is Ownable {\n    /// @notice Recover ERC20 tokens sent to the contract by mistake.\n    /// @dev The contract is Ownable and only the owner can call the recover function.\n    /// @param _to The address to send the tokens to.\n    /// @param _token The address of the ERC20 token to recover\n    /// @param _amount The amount of tokens to recover.\n    function recoverFunds(\n        address _token,\n        address _to,\n        uint256 _amount\n    ) external onlyOwner {\n        IERC20(_token).transfer(_to, _amount);\n    }\n}\n"
    },
    "contracts/utils/HexUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nlibrary HexUtils {\n    /// @dev Convert `hexString[off:end]` to `bytes32`.\n    ///      Accepts 0-64 hex-chars.\n    ///      Uses right alignment: `1` &rarr; `0000000000000000000000000000000000000000000000000000000000000001`.\n    /// @param hexString The string to parse.\n    /// @param off The index to start parsing.\n    /// @param end The (exclusive) index to stop parsing.\n    /// @return word The parsed bytes32.\n    /// @return valid True if the parse was successful.\n    function hexStringToBytes32(\n        bytes memory hexString,\n        uint256 off,\n        uint256 end\n    ) internal pure returns (bytes32 word, bool valid) {\n        if (end < off) return (\"\", false); // invalid range\n        uint256 nibbles = end - off;\n        if (nibbles > 64 || end > hexString.length) {\n            return (bytes32(0), false); // too large or out of bounds\n        }\n        uint256 src;\n        assembly {\n            src := add(add(hexString, 32), off)\n        }\n        valid = unsafeBytes(src, 0, nibbles);\n        assembly {\n            let pad := sub(32, shr(1, add(nibbles, 1))) // number of bytes\n            word := shr(shl(3, pad), mload(0)) // right align\n        }\n    }\n\n    /// @dev Convert `hexString[off:end]` to `address`.\n    ///      Accepts exactly 40 hex-chars.\n    /// @param hexString The string to parse.\n    /// @param off The index to start parsing.\n    /// @param end The (exclusive) index to stop parsing.\n    /// @return addr The parsed address.\n    /// @return valid True if the parse was successful.\n    function hexToAddress(\n        bytes memory hexString,\n        uint256 off,\n        uint256 end\n    ) internal pure returns (address addr, bool valid) {\n        if (off + 40 != end) return (address(0), false); // wrong length\n        bytes32 word;\n        (word, valid) = hexStringToBytes32(hexString, off, end);\n        addr = address(uint160(uint256(word)));\n    }\n\n    /// @dev Convert `hexString[off:end]` to `bytes`.\n    ///      Accepts 0+ hex-chars.\n    /// @param hexString The string to parse.\n    /// @param off The index to start parsing.\n    /// @param end The (exclusive) index to stop parsing.\n    /// @return v The parsed bytes.\n    /// @return valid True if the parse was successful.\n    function hexToBytes(\n        bytes memory hexString,\n        uint256 off,\n        uint256 end\n    ) internal pure returns (bytes memory v, bool valid) {\n        if (end < off) return (\"\", false); // invalid range\n        uint256 nibbles = end - off;\n        v = new bytes((1 + nibbles) >> 1); // round up\n        uint256 src;\n        uint256 dst;\n        assembly {\n            src := add(add(hexString, 32), off)\n            dst := add(v, 32)\n        }\n        valid = unsafeBytes(src, dst, nibbles);\n    }\n\n    /// @dev Convert arbitrary hex-encoded memory to bytes.\n    ///      If nibbles is odd, leading hex-char is padded, eg. `F` &rarr; `0x0F`.\n    ///      Matches: `/^[0-9a-f]*$/i`.\n    /// @param src The memory offset of first hex-char of input.\n    /// @param dst The memory offset of first byte of output (cannot alias `src`).\n    /// @param nibbles The number of hex-chars to convert.\n    /// @return valid True if all characters were hex.\n    function unsafeBytes(\n        uint256 src,\n        uint256 dst,\n        uint256 nibbles\n    ) internal pure returns (bool valid) {\n        assembly {\n            function getHex(c, i) -> ascii {\n                c := byte(i, c)\n                // chars 48-57: 0-9\n                if and(gt(c, 47), lt(c, 58)) {\n                    ascii := sub(c, 48)\n                    leave\n                }\n                // chars 65-70: A-F\n                if and(gt(c, 64), lt(c, 71)) {\n                    ascii := add(sub(c, 65), 10)\n                    leave\n                }\n                // chars 97-102: a-f\n                if and(gt(c, 96), lt(c, 103)) {\n                    ascii := add(sub(c, 97), 10)\n                    leave\n                }\n                // invalid char\n                ascii := 0x100\n            }\n            valid := true\n            let end := add(src, nibbles)\n            if and(nibbles, 1) {\n                let b := getHex(mload(src), 0) // \"f\" -> 15\n                mstore8(dst, b) // write ascii byte\n                src := add(src, 1) // update pointers\n                dst := add(dst, 1)\n                if gt(b, 255) {\n                    valid := false\n                    src := end // terminate loop\n                }\n            }\n            // prettier-ignore\n            for {} lt(src, end) {\n                src := add(src, 2) // 2 nibbles\n                dst := add(dst, 1) // per byte\n            } {\n                let word := mload(src) // read word (left aligned)\n                let b := or(shl(4, getHex(word, 0)), getHex(word, 1)) // \"ff\" -> 255\n                if gt(b, 255) {\n                    valid := false\n                    break\n                }\n                mstore8(dst, b) // write ascii byte\n            }\n        }\n    }\n\n    /// @dev Format `address` as a hex string.\n    /// @param addr The address to format.\n    /// @return hexString The corresponding hex string w/o a 0x-prefix.\n    function addressToHex(\n        address addr\n    ) internal pure returns (string memory hexString) {\n        // return bytesToHex(abi.encodePacked(addr));\n        hexString = new string(40);\n        uint256 dst;\n        assembly {\n            mstore(0, addr)\n            dst := add(hexString, 32)\n        }\n        unsafeHex(12, dst, 40);\n    }\n\n    /// @dev Format `uint256` as a variable-length hex string without zero padding.\n    /// * unpaddedUintToHex(0, true)  = \"0\"\n    /// * unpaddedUintToHex(1, true)  = \"1\"\n    /// * unpaddedUintToHex(0, false) = \"00\"\n    /// * unpaddedUintToHex(1, false) = \"01\"\n    /// @param value The number to format.\n    /// @param dropZeroNibble If true, the leading byte will use one nibble if less than 16.\n    /// @return hexString The corresponding hex string w/o an 0x-prefix.\n    function unpaddedUintToHex(\n        uint256 value,\n        bool dropZeroNibble\n    ) internal pure returns (string memory hexString) {\n        uint256 temp = value;\n        uint256 shift;\n        for (uint256 b = 128; b >= 8; b >>= 1) {\n            if (temp < (1 << b)) {\n                shift += b; // number of zero upper bits\n            } else {\n                temp >>= b; // shift away lower half\n            }\n        }\n        if (dropZeroNibble && temp < 16) shift += 4;\n        uint256 nibbles = 64 - (shift >> 2);\n        hexString = new string(nibbles);\n        uint256 dst;\n        assembly {\n            mstore(0, shl(shift, value)) // left-align\n            dst := add(hexString, 32)\n        }\n        unsafeHex(0, dst, nibbles);\n    }\n\n    /// @dev Format `bytes` as a hex string.\n    /// @param v The bytes to format.\n    /// @return hexString The corresponding hex string w/o a 0x-prefix.\n    function bytesToHex(\n        bytes memory v\n    ) internal pure returns (string memory hexString) {\n        uint256 nibbles = v.length << 1;\n        hexString = new string(nibbles);\n        uint256 src;\n        uint256 dst;\n        assembly {\n            src := add(v, 32)\n            dst := add(hexString, 32)\n        }\n        unsafeHex(src, dst, nibbles);\n    }\n\n    /// @dev Converts arbitrary memory to a hex string.\n    /// @param src The memory offset of first nibble of input.\n    /// @param dst The memory offset of first hex-char of output (can alias `src`).\n    /// @param nibbles The number of nibbles to convert and the byte-length of the output.\n    function unsafeHex(\n        uint256 src,\n        uint256 dst,\n        uint256 nibbles\n    ) internal pure {\n        unchecked {\n            for (uint256 end = dst + nibbles; dst < end; src += 32) {\n                uint256 word;\n                assembly {\n                    word := mload(src)\n                }\n                for (uint256 shift = 256; dst < end && shift > 0; dst++) {\n                    uint256 b = (word >> (shift -= 4)) & 15; // each nibble\n                    b = b < 10 ? b + 0x30 : b + 0x57; // (\"a\" - 10) => 0x57\n                    assembly {\n                        mstore8(dst, b)\n                    }\n                }\n            }\n        }\n    }\n}\n"
    },
    "contracts/utils/IFeatureSupporter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Interface for expressing contract features not visible from the ABI.\n/// @dev Interface selector: `0x582de3e7`\ninterface IFeatureSupporter {\n    /// @notice Check if a feature is supported.\n    /// @param feature The feature.\n    /// @return True if the feature is supported by the contract.\n    function supportsFeature(bytes4 feature) external view returns (bool);\n}\n"
    },
    "contracts/utils/LowLevelCallUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\nlibrary LowLevelCallUtils {\n    using Address for address;\n\n    /// @dev Makes a static call to the specified `target` with `data`. Return data can be fetched with\n    ///      `returnDataSize` and `readReturnData`.\n    /// @param target The address to staticcall.\n    /// @param data The data to pass to the call.\n    /// @return success True if the call succeeded, or false if it reverts.\n    function functionStaticCall(\n        address target,\n        bytes memory data\n    ) internal view returns (bool success) {\n        return functionStaticCall(target, data, gasleft());\n    }\n\n    /// @dev Makes a static call to the specified `target` with `data` using `gasLimit`. Return data can be fetched with\n    ///      `returnDataSize` and `readReturnData`.\n    /// @param target The address to staticcall.\n    /// @param data The data to pass to the call.\n    /// @param gasLimit The gas limit to use for the call.\n    /// @return success True if the call succeeded, or false if it reverts.\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        uint256 gasLimit\n    ) internal view returns (bool success) {\n        require(\n            target.isContract(),\n            \"LowLevelCallUtils: static call to non-contract\"\n        );\n        assembly {\n            success := staticcall(\n                gasLimit,\n                target,\n                add(data, 32),\n                mload(data),\n                0,\n                0\n            )\n        }\n    }\n\n    /// @dev Returns the size of the return data of the most recent external call.\n    function returnDataSize() internal pure returns (uint256 len) {\n        assembly {\n            len := returndatasize()\n        }\n    }\n\n    /// @dev Reads return data from the most recent external call.\n    /// @param offset Offset into the return data.\n    /// @param length Number of bytes to return.\n    function readReturnData(\n        uint256 offset,\n        uint256 length\n    ) internal pure returns (bytes memory data) {\n        data = new bytes(length);\n        assembly {\n            returndatacopy(add(data, 32), offset, length)\n        }\n    }\n\n    /// @dev Reverts with the return data from the most recent external call.\n    function propagateRevert() internal pure {\n        assembly {\n            returndatacopy(0, 0, returndatasize())\n            revert(0, returndatasize())\n        }\n    }\n}\n"
    },
    "contracts/utils/MigrationHelper.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport {IBaseRegistrar} from \"../ethregistrar/IBaseRegistrar.sol\";\nimport {INameWrapper} from \"../wrapper/INameWrapper.sol\";\nimport {Controllable} from \"../wrapper/Controllable.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract MigrationHelper is Ownable, Controllable {\n    IBaseRegistrar public immutable registrar;\n    INameWrapper public immutable wrapper;\n    address public migrationTarget;\n\n    error MigrationTargetNotSet();\n\n    event MigrationTargetUpdated(address indexed target);\n\n    constructor(IBaseRegistrar _registrar, INameWrapper _wrapper) {\n        registrar = _registrar;\n        wrapper = _wrapper;\n    }\n\n    function setMigrationTarget(address target) external onlyOwner {\n        migrationTarget = target;\n        emit MigrationTargetUpdated(target);\n    }\n\n    function migrateNames(\n        address nameOwner,\n        uint256[] memory tokenIds,\n        bytes memory data\n    ) external onlyController {\n        if (migrationTarget == address(0)) {\n            revert MigrationTargetNotSet();\n        }\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            registrar.safeTransferFrom(\n                nameOwner,\n                migrationTarget,\n                tokenIds[i],\n                data\n            );\n        }\n    }\n\n    function migrateWrappedNames(\n        address nameOwner,\n        uint256[] memory tokenIds,\n        bytes memory data\n    ) external onlyController {\n        if (migrationTarget == address(0)) {\n            revert MigrationTargetNotSet();\n        }\n\n        uint256[] memory amounts = new uint256[](tokenIds.length);\n        for (uint256 i = 0; i < amounts.length; i++) {\n            amounts[i] = 1;\n        }\n        wrapper.safeBatchTransferFrom(\n            nameOwner,\n            migrationTarget,\n            tokenIds,\n            amounts,\n            data\n        );\n    }\n}\n"
    },
    "contracts/utils/NameCoder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {HexUtils} from \"../utils/HexUtils.sol\";\n\n/// @dev Library for encoding/decoding names.\n///\n/// An ENS name is stop-separated labels, eg. \"aaa.bb.c\".\n///\n/// A DNS-encoded name is composed of byte length-prefixed labels with a terminator byte.\n/// eg. \"\\x03aaa\\x02bb\\x01c\\x00\".\n/// - maximum label length is 255 bytes.\n/// - length = 0 is reserved for the terminator (root).\n///\n/// To encode a label larger than 255 bytes, use a hashed label.\n/// A label of any length can be converted to a hashed label.\n///\n/// A hashed label is encoded as \"[\" + toHex(keccak256(label)) + \"]\".\n/// eg. [af2caa1c2ca1d027f1ac823b529d0a67cd144264b2789fa2ea4d63a67c7103cc] = \"vitalik\".\n/// - always 66 bytes.\n/// - matches: `/^\\[[0-9a-f]{64}\\]$/`.\n///\n/// w/o hashed labels: `dns.length == 2 + ens.length` and the mapping is injective.\n///  w/ hashed labels: `dns.length == 2 + ens.split('.').map(x => x.utf8Length).sum(n => n > 255 ? 66 : n)`.\n///\nlibrary NameCoder {\n    /// @dev The DNS-encoded name is malformed.\n    ///      Error selector: `0xba4adc23`\n    error DNSDecodingFailed(bytes dns);\n\n    /// @dev A label of the ENS name has an invalid size.\n    ///      Error selector: `0x9a4c3e3b`\n    error DNSEncodingFailed(string ens);\n\n    /// @dev Read the `size` of the label at `offset`.\n    ///      If `size = 0`, it must be the end of `name` (no junk at end).\n    ///      Reverts `DNSDecodingFailed`.\n    /// @param name The DNS-encoded name.\n    /// @param offset The offset into `name` to start reading.\n    /// @return size The size of the label in bytes.\n    /// @return nextOffset The offset into `name` of the next label.\n    function nextLabel(\n        bytes memory name,\n        uint256 offset\n    ) internal pure returns (uint8 size, uint256 nextOffset) {\n        assembly {\n            size := byte(0, mload(add(add(name, 32), offset))) // uint8(name[offset])\n            nextOffset := add(offset, add(1, size)) // offset + 1 + size\n        }\n        if (size > 0 ? nextOffset >= name.length : nextOffset != name.length) {\n            revert DNSDecodingFailed(name);\n        }\n    }\n\n    /// @dev Find the offset of the label before `offset` in `name`.\n    ///      * `prevOffset(name, 0)` reverts.\n    ///      * `prevOffset(name, name.length + 1)` reverts.\n    ///      * `prevOffset(name, name.length) = name.length - 1`.\n    ///      * `prevOffset(name, name.length - 1) = <tld>`.\n    ///      Reverts `DNSDecodingFailed`.\n    /// @param name The DNS-encoded name.\n    /// @param offset The offset into `name` to start reading backwards.\n    /// @return prevOffset The offset into `name` of the previous label.\n    function prevLabel(\n        bytes memory name,\n        uint256 offset\n    ) internal pure returns (uint256 prevOffset) {\n        while (true) {\n            (, uint256 nextOffset) = nextLabel(name, prevOffset);\n            if (nextOffset == offset) break;\n            if (nextOffset > offset) {\n                revert DNSDecodingFailed(name);\n            }\n            prevOffset = nextOffset;\n        }\n    }\n\n    /// @dev Compute the ENS labelhash of the label at `offset` and the offset for the next label.\n    ///      Disallows hashed label of zero (eg. `[0..0]`) to prevent confusion with terminator.\n    ///      Reverts `DNSDecodingFailed`.\n    /// @param name The DNS-encoded name.\n    /// @param offset The offset into `name` to start reading.\n    /// @param parseHashed If true, supports hashed labels.\n    /// @return labelHash The resulting labelhash.\n    /// @return nextOffset The offset into `name` of the next label.\n    /// @return size The size of the label in bytes.\n    /// @return wasHashed If true, the label was interpreted as a hashed label.\n    function readLabel(\n        bytes memory name,\n        uint256 offset,\n        bool parseHashed\n    )\n        internal\n        pure\n        returns (\n            bytes32 labelHash,\n            uint256 nextOffset,\n            uint8 size,\n            bool wasHashed\n        )\n    {\n        (size, nextOffset) = nextLabel(name, offset);\n        if (\n            parseHashed &&\n            size == 66 &&\n            name[offset + 1] == \"[\" &&\n            name[nextOffset - 1] == \"]\"\n        ) {\n            (labelHash, wasHashed) = HexUtils.hexStringToBytes32(\n                name,\n                offset + 2,\n                nextOffset - 1\n            ); // will not revert\n            if (!wasHashed || labelHash == bytes32(0)) {\n                revert DNSDecodingFailed(name); // \"readLabel: malformed\" or null literal\n            }\n        } else if (size > 0) {\n            assembly {\n                labelHash := keccak256(add(add(name, offset), 33), size)\n            }\n        }\n    }\n\n    /// @dev Same as `BytesUtils.namehash()` but supports hashed labels.\n    function readLabel(\n        bytes memory name,\n        uint256 offset\n    ) internal pure returns (bytes32 labelHash, uint256 nextOffset) {\n        (labelHash, nextOffset, , ) = readLabel(name, offset, true);\n    }\n\n    /// @dev Compute the ENS namehash of `name[:offset]`.\n    ///      Supports hashed labels.\n    ///      Reverts `DNSDecodingFailed`.\n    /// @param name The DNS-encoded name.\n    /// @param offset The offset into name start hashing.\n    /// @return hash The namehash of `name[:offset]`.\n    function namehash(\n        bytes memory name,\n        uint256 offset\n    ) internal pure returns (bytes32 hash) {\n        (hash, offset) = readLabel(name, offset);\n        if (hash != bytes32(0)) {\n            hash = namehash(namehash(name, offset), hash);\n        }\n    }\n\n    /// @dev Compute a child namehash from a parent namehash.\n    /// @param parentNode The namehash of the parent.\n    /// @param labelHash The labelhash of the child.\n    /// @return node The namehash of the child.\n    function namehash(\n        bytes32 parentNode,\n        bytes32 labelHash\n    ) internal pure returns (bytes32 node) {\n        // ~100 gas less than: keccak256(abi.encode(parentNode, labelHash))\n        assembly {\n            mstore(0, parentNode)\n            mstore(32, labelHash)\n            node := keccak256(0, 64)\n        }\n    }\n\n    /// @dev Convert DNS-encoded name to ENS name.\n    ///      Reverts `DNSDecodingFailed`.\n    /// @param dns The DNS-encoded name to convert, eg. `\\x03aaa\\x02bb\\x01c\\x00`.\n    /// @return ens The equivalent ENS name, eg. `aaa.bb.c`.\n    function decode(\n        bytes memory dns\n    ) internal pure returns (string memory ens) {\n        unchecked {\n            uint256 n = dns.length;\n            if (n == 1 && dns[0] == 0) return \"\"; // only valid answer is root\n            if (n < 3) revert DNSDecodingFailed(dns);\n            bytes memory v = new bytes(n - 2); // always 2-shorter\n            uint256 src;\n            uint256 dst;\n            while (src < n) {\n                uint8 len = uint8(dns[src++]);\n                if (len == 0) break;\n                uint256 end = src + len;\n                if (end > dns.length) revert DNSDecodingFailed(dns); // overflow\n                if (dst > 0) v[dst++] = \".\"; // skip first stop\n                while (src < end) {\n                    bytes1 x = dns[src++]; // read byte\n                    if (x == \".\") revert DNSDecodingFailed(dns); // malicious label\n                    v[dst++] = x; // write byte\n                }\n            }\n            if (src != dns.length) revert DNSDecodingFailed(dns); // junk at end\n            return string(v);\n        }\n    }\n\n    /// @dev Convert ENS name to DNS-encoded name.\n    ///      Hashes labels longer than 255 bytes.\n    ///      Reverts `DNSEncodingFailed`.\n    /// @param ens The ENS name to convert, eg. `aaa.bb.c`.\n    /// @return dns The corresponding DNS-encoded name, eg. `\\x03aaa\\x02bb\\x01c\\x00`.\n    function encode(\n        string memory ens\n    ) internal pure returns (bytes memory dns) {\n        unchecked {\n            uint256 n = bytes(ens).length;\n            if (n == 0) return hex\"00\"; // root\n            dns = new bytes(n + 2);\n            uint256 start;\n            assembly {\n                start := add(dns, 32) // first byte of output\n            }\n            uint256 end = start; // remember position to write length\n            for (uint256 i; i < n; i++) {\n                bytes1 x = bytes(ens)[i]; // read byte\n                if (x == \".\") {\n                    start = _createHashedLabel(start, end);\n                    if (start == 0) revert DNSEncodingFailed(ens);\n                    end = start; // jump to next position\n                } else {\n                    assembly {\n                        end := add(end, 1) // increase length\n                        mstore(end, x) // write byte\n                    }\n                }\n            }\n            start = _createHashedLabel(start, end);\n            if (start == 0) revert DNSEncodingFailed(ens);\n            assembly {\n                mstore8(start, 0) // terminal byte\n                mstore(dns, sub(start, add(dns, 31))) // truncate length\n            }\n        }\n    }\n\n    /// @dev Write the label length.\n    ///      If longer than 255, writes a hashed label instead.\n    /// @param start The memory offset of the length-prefixed label.\n    /// @param end The memory offset at the end of the label.\n    /// @return next The memory offset for the next label.\n    ///              Returns 0 if label is empty (handled by caller).\n    function _createHashedLabel(\n        uint256 start,\n        uint256 end\n    ) internal pure returns (uint256 next) {\n        uint256 size = end - start; // length of label\n        if (size > 255) {\n            assembly {\n                mstore(0, keccak256(add(start, 1), size)) // compute hash of label\n            }\n            HexUtils.unsafeHex(0, start + 2, 64); // override label with hex(hash)\n            assembly {\n                mstore8(add(start, 1), 0x5B) // \"[\"\n                mstore8(add(start, 66), 0x5D) // \"]\"\n            }\n            size = 66;\n        }\n        if (size > 0) {\n            assembly {\n                mstore8(start, size) // update length\n            }\n            next = start + 1 + size; // advance\n        }\n    }\n\n    /// @dev Find the offset of `name` that namehashes to `nodeSuffix`.\n    /// @param name The name to search.\n    /// @param nodeSuffix The node to match.\n    /// @return matched True if `name` ends with the suffix.\n    /// @return node The namehash of `name[offset:]`.\n    /// @return prevOffset The offset into `name` of the label before the suffix, or `matchOffset` if no match or prior label.\n    /// @return matchOffset The offset into `name` that namehashes to the `nodeSuffix`, or 0 if no match.\n    function matchSuffix(\n        bytes memory name,\n        uint256 offset,\n        bytes32 nodeSuffix\n    )\n        internal\n        pure\n        returns (\n            bool matched,\n            bytes32 node,\n            uint256 prevOffset,\n            uint256 matchOffset\n        )\n    {\n        (bytes32 labelHash, uint256 next) = readLabel(name, offset);\n        if (labelHash != bytes32(0)) {\n            (matched, node, prevOffset, matchOffset) = matchSuffix(\n                name,\n                next,\n                nodeSuffix\n            );\n            if (node == nodeSuffix) {\n                matched = true;\n                prevOffset = offset;\n                matchOffset = next;\n            }\n            node = namehash(node, labelHash);\n        }\n        if (node == nodeSuffix) {\n            matched = true;\n            prevOffset = matchOffset = offset;\n        }\n    }\n}\n"
    },
    "contracts/utils/StringUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nlibrary StringUtils {\n    /// @dev Returns the length of a given string\n    /// @param s The string to measure the length of\n    /// @return The length of the input string\n    function strlen(string memory s) internal pure returns (uint256) {\n        uint256 len;\n        uint256 i = 0;\n        uint256 bytelength = bytes(s).length;\n        for (len = 0; i < bytelength; len++) {\n            bytes1 b = bytes(s)[i];\n            if (b < 0x80) {\n                i += 1;\n            } else if (b < 0xE0) {\n                i += 2;\n            } else if (b < 0xF0) {\n                i += 3;\n            } else if (b < 0xF8) {\n                i += 4;\n            } else if (b < 0xFC) {\n                i += 5;\n            } else {\n                i += 6;\n            }\n        }\n        return len;\n    }\n\n    /// @dev Escapes special characters in a given string\n    /// @param str The string to escape\n    /// @return The escaped string\n    function escape(string memory str) internal pure returns (string memory) {\n        bytes memory strBytes = bytes(str);\n        uint extraChars = 0;\n\n        // count extra space needed for escaping\n        for (uint i = 0; i < strBytes.length; i++) {\n            if (_needsEscaping(strBytes[i])) {\n                extraChars++;\n            }\n        }\n\n        // allocate buffer with the exact size needed\n        bytes memory buffer = new bytes(strBytes.length + extraChars);\n        uint index = 0;\n\n        // escape characters\n        for (uint i = 0; i < strBytes.length; i++) {\n            if (_needsEscaping(strBytes[i])) {\n                buffer[index++] = \"\\\\\";\n                buffer[index++] = _getEscapedChar(strBytes[i]);\n            } else {\n                buffer[index++] = strBytes[i];\n            }\n        }\n\n        return string(buffer);\n    }\n\n    // determine if a character needs escaping\n    function _needsEscaping(bytes1 char) private pure returns (bool) {\n        return\n            char == '\"' ||\n            char == \"/\" ||\n            char == \"\\\\\" ||\n            char == \"\\n\" ||\n            char == \"\\r\" ||\n            char == \"\\t\";\n    }\n\n    // get the escaped character\n    function _getEscapedChar(bytes1 char) private pure returns (bytes1) {\n        if (char == \"\\n\") return \"n\";\n        if (char == \"\\r\") return \"r\";\n        if (char == \"\\t\") return \"t\";\n        return char;\n    }\n}\n"
    },
    "contracts/utils/TestBytesUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {BytesUtils} from \"../../contracts/utils/BytesUtils.sol\";\n\ncontract TestBytesUtils {\n    using BytesUtils for *;\n\n    function test_keccak() public pure {\n        require(\n            \"\".keccak(0, 0) ==\n                bytes32(\n                    0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\n                ),\n            \"Incorrect hash of empty string\"\n        );\n        require(\n            \"foo\".keccak(0, 3) ==\n                bytes32(\n                    0x41b1a0649752af1b28b3dc29a1556eee781e4a4c3a1f7f53f90fa834de098c4d\n                ),\n            \"Incorrect hash of 'foo'\"\n        );\n        require(\n            \"foo\".keccak(0, 0) ==\n                bytes32(\n                    0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\n                ),\n            \"Incorrect hash of empty string\"\n        );\n    }\n\n    function test_equals() public pure {\n        require(\"hello\".equals(\"hello\"), \"String equality\");\n        require(!\"hello\".equals(\"goodbye\"), \"String inequality\");\n        require(\"hello\".equals(1, \"ello\"), \"Substring to string equality\");\n        require(\n            \"hello\".equals(1, \"jello\", 1, 4),\n            \"Substring to substring equality\"\n        );\n        require(\n            \"zhello\".equals(1, \"abchello\", 3),\n            \"Compare different value with multiple length\"\n        );\n        require(\n            !\"0x0102030000\".equals(0, \"0x010203\"),\n            \"Compare with offset and trailing bytes\"\n        );\n    }\n\n    function test_compare_partial() public pure {\n        require(\"xax\".compare(1, 1, \"xxbxx\", 2, 1) < 0, \"Compare same length\");\n        require(\n            \"xax\".compare(1, 1, \"xxabxx\", 2, 2) < 0,\n            \"Compare different length\"\n        );\n        require(\n            \"xax\".compare(1, 1, \"xxaxx\", 2, 1) == 0,\n            \"Compare same with different offset\"\n        );\n        require(\n            \"01234567890123450123456789012345ab\".compare(\n                0,\n                33,\n                \"01234567890123450123456789012345aa\",\n                0,\n                33\n            ) == 0,\n            \"Compare different long strings same length smaller partial length which must be equal\"\n        );\n        require(\n            \"01234567890123450123456789012345ab\".compare(\n                0,\n                33,\n                \"01234567890123450123456789012345aa\",\n                0,\n                34\n            ) < 0,\n            \"Compare long strings same length different partial length\"\n        );\n        require(\n            \"0123456789012345012345678901234a\".compare(\n                0,\n                32,\n                \"0123456789012345012345678901234b\",\n                0,\n                32\n            ) < 0,\n            \"Compare strings exactly 32 characters long\"\n        );\n    }\n\n    function test_compare() public pure {\n        require(\"a\".compare(\"a\") == 0, \"a == a\");\n        require(\"a\".compare(\"b\") < 0, \"a < b\");\n        require(\"b\".compare(\"a\") > 0, \"b > a\");\n        require(\"aa\".compare(\"ab\") < 0, \"aa < ab\");\n        require(\"a\".compare(\"aa\") < 0, \"a < aa\");\n        require(\"aa\".compare(\"a\") > 0, \"aa > a\");\n        bytes memory v = \"123456789012345678901234567890123\"; // 33\n        require(v.compare(v) == 0, \"long == long\");\n        require(v.compare(abi.encodePacked(\"0\", v)) > 0, \"long > 0long\");\n        require(v.compare(abi.encodePacked(v, \"0\")) < 0, \"long < long0\");\n        require(\n            abi.encodePacked(type(int256).min).compare(\n                abi.encodePacked(type(int256).max)\n            ) > 0,\n            \"Compare maximum difference\"\n        );\n    }\n\n    function test_copyBytes() public pure {\n        bytes memory v = \"0123456789abcdef0123456789abcdef\";\n        {\n            bytes memory u = new bytes(5);\n            BytesUtils.copyBytes(v, 0, u, 0, u.length);\n            require(keccak256(u) == keccak256(\"01234\"), \"5\");\n        }\n        {\n            bytes memory u = new bytes(6);\n            BytesUtils.copyBytes(v, 1, u, 0, u.length);\n            require(keccak256(u) == keccak256(\"123456\"), \"6\");\n        }\n        {\n            bytes memory u = new bytes(v.length);\n            BytesUtils.copyBytes(v, 0, u, 0, u.length);\n            require(keccak256(u) == keccak256(v), \"all\");\n        }\n    }\n\n    // this uses copyBytes() underneath\n    function test_substring() public pure {\n        bytes memory v = \"abc\";\n        require(keccak256(v.substring(0, 0)) == keccak256(\"\"), \"[]abc\");\n        require(keccak256(v.substring(0, 2)) == keccak256(\"ab\"), \"[ab]c\");\n        require(keccak256(v.substring(1, 2)) == keccak256(\"bc\"), \"a[bc]\");\n        require(keccak256(v.substring(0, 3)) == keccak256(\"abc\"), \"[abc]\");\n    }\n\n    function testFail_substring_overflow() public pure {\n        \"\".substring(0, 1);\n    }\n\n    function test_readUint8() public pure {\n        bytes memory v = \"abc\";\n        require(v.readUint8(0) == uint8(bytes1(\"a\")), \"0\");\n        require(v.readUint8(1) == uint8(bytes1(\"b\")), \"1\");\n        require(v.readUint8(2) == uint8(bytes1(\"c\")), \"2\");\n    }\n\n    function test_readUint16() public pure {\n        bytes memory v = \"abcd\";\n        require(v.readUint16(0) == uint16(bytes2(\"ab\")), \"0\");\n        require(v.readUint16(1) == uint16(bytes2(\"bc\")), \"1\");\n        require(v.readUint16(2) == uint16(bytes2(\"cd\")), \"2\");\n    }\n\n    function test_readUint32() public pure {\n        bytes memory v = \"0123456789abc\";\n        require(v.readUint32(0) == uint32(bytes4(\"0123\")), \"0\");\n        require(v.readUint32(4) == uint32(bytes4(\"4567\")), \"4\");\n        require(v.readUint32(8) == uint32(bytes4(\"89ab\")), \"8\");\n    }\n\n    function test_readBytes20() public pure {\n        bytes memory v = \"0123456789abcdef0123456789abcdef\";\n        bytes22 x = 0x30313233343536373839616263646566303132333435;\n        require(v.readBytes20(0) == bytes20(x), \"0\");\n        require(v.readBytes20(1) == bytes20(x << 8), \"1\");\n        require(v.readBytes20(2) == bytes20(x << 16), \"2\");\n    }\n\n    function test_readBytes32() public pure {\n        bytes memory v = \"0123456789abcdef0123456789abcdef\\x00\\x00\";\n        bytes32 x = 0x3031323334353637383961626364656630313233343536373839616263646566;\n        require(v.readBytes32(0) == x, \"0\");\n        require(v.readBytes32(1) == x << 8, \"1\");\n        require(v.readBytes32(2) == x << 16, \"2\");\n    }\n\n    function test_readBytesN() public pure {\n        bytes memory v = \"0123456789abcdef0123456789abcdef\";\n        bytes32 x = 0x3031323334353637383961626364656630313233343536373839616263646566;\n        require(v.readBytesN(0, 0) == 0, \"0\");\n        require(v.readBytesN(0, 1) == bytes1(x), \"1\");\n        require(v.readBytesN(0, 2) == bytes2(x), \"2\");\n        require(v.readBytesN(0, 3) == bytes3(x), \"3\");\n        require(v.readBytesN(0, 4) == bytes4(x), \"4\");\n        require(v.readBytesN(0, 5) == bytes5(x), \"5\");\n        require(v.readBytesN(0, 6) == bytes6(x), \"6\");\n        require(v.readBytesN(0, 7) == bytes7(x), \"7\");\n        require(v.readBytesN(0, 8) == bytes8(x), \"8\");\n        require(v.readBytesN(0, 9) == bytes9(x), \"9\");\n        require(v.readBytesN(0, 10) == bytes10(x), \"10\");\n        require(v.readBytesN(0, 11) == bytes11(x), \"11\");\n        require(v.readBytesN(0, 12) == bytes12(x), \"12\");\n        require(v.readBytesN(0, 13) == bytes13(x), \"13\");\n        require(v.readBytesN(0, 14) == bytes14(x), \"14\");\n        require(v.readBytesN(0, 15) == bytes15(x), \"15\");\n        require(v.readBytesN(0, 16) == bytes16(x), \"16\");\n        require(v.readBytesN(0, 17) == bytes17(x), \"17\");\n        require(v.readBytesN(0, 18) == bytes18(x), \"18\");\n        require(v.readBytesN(0, 19) == bytes19(x), \"19\");\n        require(v.readBytesN(0, 20) == bytes20(x), \"20\");\n        require(v.readBytesN(0, 21) == bytes21(x), \"21\");\n        require(v.readBytesN(0, 22) == bytes22(x), \"22\");\n        require(v.readBytesN(0, 23) == bytes23(x), \"23\");\n        require(v.readBytesN(0, 24) == bytes24(x), \"24\");\n        require(v.readBytesN(0, 25) == bytes25(x), \"25\");\n        require(v.readBytesN(0, 26) == bytes26(x), \"26\");\n        require(v.readBytesN(0, 27) == bytes27(x), \"27\");\n        require(v.readBytesN(0, 28) == bytes28(x), \"28\");\n        require(v.readBytesN(0, 29) == bytes29(x), \"29\");\n        require(v.readBytesN(0, 30) == bytes30(x), \"30\");\n        require(v.readBytesN(0, 31) == bytes31(x), \"31\");\n        require(v.readBytesN(0, 32) == x, \"32\");\n        require(v.readBytesN(1, 31) == bytes32(x) << 8, \"1+31\");\n        require(v.readBytesN(31, 1) == bytes32(x) << 248, \"31+1\");\n    }\n\n    function testFail_readBytesN_overflow() public pure {\n        \"\".readBytesN(0, 1);\n    }\n\n    function testFail_readBytesN_largeN() public pure {\n        new bytes(64).readBytesN(0, 33);\n    }\n\n    function test_find() public pure {\n        bytes memory v = \"0123456789abcdef0123456789abcdef\";\n        require(v.find(0, v.length, \"0\") == 0, \"0\");\n        require(v.find(1, v.length, \"0\") == 16, \"2nd 0\");\n        require(v.find(0, v.length, \"z\") == type(uint256).max, \"z\");\n        require(v.find(0, v.length, \"A\") == type(uint256).max, \"A\");\n        require(v.find(0, 10, \"a\") == type(uint256).max, \"a\");\n    }\n}\n"
    },
    "contracts/utils/TestENSIP19.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ENSIP19} from \"./ENSIP19.sol\";\n\ncontract TestENSIP19 {\n    function reverseName(\n        bytes memory encodedAddress,\n        uint256 coinType\n    ) external pure returns (string memory) {\n        return ENSIP19.reverseName(encodedAddress, coinType);\n    }\n\n    function parse(\n        bytes memory name\n    ) external pure returns (bytes memory, uint256) {\n        return ENSIP19.parse(name);\n    }\n\n    function parseNamespace(\n        bytes memory name,\n        uint256 offset\n    ) external pure returns (bool, uint256) {\n        return ENSIP19.parseNamespace(name, offset);\n    }\n\n    function chainFromCoinType(\n        uint256 coinType\n    ) external pure returns (uint32) {\n        return ENSIP19.chainFromCoinType(coinType);\n    }\n\n    function isEVMCoinType(uint256 coinType) external pure returns (bool) {\n        return ENSIP19.isEVMCoinType(coinType);\n    }\n}\n"
    },
    "contracts/utils/TestHexUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {HexUtils} from \"./HexUtils.sol\";\n\ncontract TestHexUtils {\n    function hexToBytes(\n        bytes calldata name,\n        uint256 off,\n        uint256 end\n    ) public pure returns (bytes memory, bool) {\n        return HexUtils.hexToBytes(name, off, end);\n    }\n\n    function hexStringToBytes32(\n        bytes calldata name,\n        uint256 off,\n        uint256 end\n    ) public pure returns (bytes32, bool) {\n        return HexUtils.hexStringToBytes32(name, off, end);\n    }\n\n    function hexToAddress(\n        bytes calldata input,\n        uint256 off,\n        uint256 end\n    ) public pure returns (address, bool) {\n        return HexUtils.hexToAddress(input, off, end);\n    }\n\n    function addressToHex(\n        address addr\n    ) external pure returns (string memory hexString) {\n        return HexUtils.addressToHex(addr);\n    }\n\n    function unpaddedUintToHex(\n        uint256 value,\n        bool dropZeroNibble\n    ) external pure returns (string memory hexString) {\n        return HexUtils.unpaddedUintToHex(value, dropZeroNibble);\n    }\n\n    function bytesToHex(\n        bytes memory v\n    ) external pure returns (string memory hexString) {\n        return HexUtils.bytesToHex(v);\n    }\n}\n"
    },
    "contracts/utils/TestNameCoder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {NameCoder} from \"./NameCoder.sol\";\n\ncontract TestNameCoder {\n    function nextLabel(\n        bytes memory name,\n        uint256 offset\n    ) external pure returns (uint8 size, uint256 nextOffset) {\n        return NameCoder.nextLabel(name, offset);\n    }\n\n    function prevLabel(\n        bytes memory name,\n        uint256 offset\n    ) external pure returns (uint256) {\n        return NameCoder.prevLabel(name, offset);\n    }\n\n    function readLabel(\n        bytes memory name,\n        uint256 offset,\n        bool parseHashed\n    )\n        external\n        pure\n        returns (\n            bytes32 labelHash,\n            uint256 nextOffset,\n            uint8 size,\n            bool wasHashed\n        )\n    {\n        (labelHash, nextOffset, size, wasHashed) = NameCoder.readLabel(\n            name,\n            offset,\n            parseHashed\n        );\n    }\n\n    function namehash(\n        bytes memory name,\n        uint256 offset\n    ) external pure returns (bytes32 nameHash) {\n        return NameCoder.namehash(name, offset);\n    }\n\n    function encode(\n        string memory ens\n    ) external pure returns (bytes memory dns) {\n        return NameCoder.encode(ens);\n    }\n\n    function decode(\n        bytes memory dns\n    ) external pure returns (string memory ens) {\n        return NameCoder.decode(dns);\n    }\n\n    function matchSuffix(\n        bytes memory name,\n        uint256 offset,\n        bytes32 nodeSuffix\n    )\n        external\n        pure\n        returns (\n            bool matched,\n            bytes32 node,\n            uint256 prevOffset,\n            uint256 matchOffset\n        )\n    {\n        return NameCoder.matchSuffix(name, offset, nodeSuffix);\n    }\n}\n"
    },
    "contracts/utils/TestRRUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {RRUtils} from \"../../contracts/dnssec-oracle/RRUtils.sol\";\n\ncontract TestRRUtils {\n    using RRUtils for *;\n\n    uint16 constant DNSTYPE_A = 1;\n    uint16 constant DNSTYPE_CNAME = 5;\n    uint16 constant DNSTYPE_MX = 15;\n    uint16 constant DNSTYPE_TEXT = 16;\n    uint16 constant DNSTYPE_RRSIG = 46;\n    uint16 constant DNSTYPE_TYPE1234 = 1234;\n\n    function testNameLength() public pure {\n        require(hex\"00\".nameLength(0) == 1, \"nameLength('.') == 1\");\n        require(hex\"0361626300\".nameLength(4) == 1, \"nameLength('.') == 1\");\n        require(hex\"0361626300\".nameLength(0) == 5, \"nameLength('abc.') == 5\");\n    }\n\n    function testLabelCount() public pure {\n        require(hex\"00\".labelCount(0) == 0, \"labelCount('.') == 0\");\n        require(hex\"016100\".labelCount(0) == 1, \"labelCount('a.') == 1\");\n        require(\n            hex\"016201610000\".labelCount(0) == 2,\n            \"labelCount('b.a.') == 2\"\n        );\n        require(\n            hex\"066574686c61620378797a00\".labelCount(6 + 1) == 1,\n            \"nameLength('(bthlab).xyz.') == 6\"\n        );\n    }\n\n    function testIterateRRs() public pure {\n        // a. IN A 3600 127.0.0.1\n        // b.a. IN A 3600 192.168.1.1\n        bytes\n            memory rrs = hex\"0161000001000100000e1000047400000101620161000001000100000e100004c0a80101\";\n        bytes[2] memory names = [bytes(hex\"016100\"), bytes(hex\"0162016100\")];\n        bytes[2] memory rdatas = [bytes(hex\"74000001\"), bytes(hex\"c0a80101\")];\n        uint i = 0;\n        for (\n            RRUtils.RRIterator memory iter = rrs.iterateRRs(0);\n            !iter.done();\n            iter.next()\n        ) {\n            require(uint(iter.dnstype) == 1, \"Type matches\");\n            require(uint(iter.class) == 1, \"Class matches\");\n            require(uint(iter.ttl) == 3600, \"TTL matches\");\n            require(\n                keccak256(iter.name()) == keccak256(names[i]),\n                \"Name matches\"\n            );\n            require(\n                keccak256(iter.rdata()) == keccak256(rdatas[i]),\n                \"Rdata matches\"\n            );\n            i++;\n        }\n        require(i == 2, \"Expected 2 records\");\n    }\n\n    // Canonical ordering https://tools.ietf.org/html/rfc4034#section-6.1\n    function testCompareNames() public pure {\n        bytes memory bthLabXyz = hex\"066274686c61620378797a00\";\n        bytes memory ethLabXyz = hex\"066574686c61620378797a00\";\n        bytes memory xyz = hex\"0378797a00\";\n        bytes memory a_b_c = hex\"01610162016300\";\n        bytes memory b_b_c = hex\"01620162016300\";\n        bytes memory c = hex\"016300\";\n        bytes memory d = hex\"016400\";\n        bytes memory a_d_c = hex\"01610164016300\";\n        bytes memory b_a_c = hex\"01620161016300\";\n        bytes memory ab_c_d = hex\"0261620163016400\";\n        bytes memory a_c_d = hex\"01610163016400\";\n        bytes\n            memory verylong1_eth = hex\"223031323334353637383930313233343536373839303132333435363738393031613031303132333435363738393031323334353637383930313233343536373839303132333435363738393031323334353637380365746800\";\n        bytes\n            memory verylong2_eth = hex\"2130313233343536373839303132333435363738393031323334353637383930316131303132333435363738393031323334353637383930313233343536373839303132333435363738393031323334353637380365746800\";\n\n        require(\n            hex\"0301616100\".compareNames(hex\"0302616200\") < 0,\n            \"label lengths are correctly checked\"\n        );\n        require(\n            a_b_c.compareNames(c) > 0,\n            \"one name has a difference of >1 label to with the same root name\"\n        );\n        require(\n            a_b_c.compareNames(d) < 0,\n            \"one name has a difference of >1 label to with different root name\"\n        );\n        require(\n            a_b_c.compareNames(a_d_c) < 0,\n            \"two names start the same but have differences in later labels\"\n        );\n        require(\n            a_b_c.compareNames(b_a_c) > 0,\n            \"the first label sorts later, but the first label sorts earlier\"\n        );\n        require(\n            ab_c_d.compareNames(a_c_d) > 0,\n            \"two names where the first label on one is a prefix of the first label on the other\"\n        );\n        require(\n            a_b_c.compareNames(b_b_c) < 0,\n            \"two names where the first label on one is a prefix of the first label on the other\"\n        );\n        require(xyz.compareNames(ethLabXyz) < 0, \"xyz comes before ethLab.xyz\");\n        require(\n            bthLabXyz.compareNames(ethLabXyz) < 0,\n            \"bthLab.xyz comes before ethLab.xyz\"\n        );\n        require(\n            bthLabXyz.compareNames(bthLabXyz) == 0,\n            \"bthLab.xyz and bthLab.xyz are the same\"\n        );\n        require(\n            ethLabXyz.compareNames(bthLabXyz) > 0,\n            \"ethLab.xyz comes after bethLab.xyz\"\n        );\n        require(bthLabXyz.compareNames(xyz) > 0, \"bthLab.xyz comes after xyz\");\n\n        require(\n            verylong1_eth.compareNames(verylong2_eth) > 0,\n            \"longa.vlong.eth comes after long.vlong.eth\"\n        );\n    }\n\n    function testSerialNumberGt() public pure {\n        require(RRUtils.serialNumberGte(1, 0), \"1 >= 0\");\n        require(!RRUtils.serialNumberGte(0, 1), \"!(0 <= 1)\");\n        require(RRUtils.serialNumberGte(0, 0xFFFFFFFF), \"0 >= 0xFFFFFFFF\");\n        require(!RRUtils.serialNumberGte(0xFFFFFFFF, 0), \"!(0 <= 0xFFFFFFFF)\");\n        require(\n            RRUtils.serialNumberGte(0x11111111, 0xAAAAAAAA),\n            \"0x11111111 >= 0xAAAAAAAA\"\n        );\n        require(RRUtils.serialNumberGte(1, 1), \"1 >= 1\");\n    }\n\n    function testKeyTag() public pure {\n        require(\n            hex\"0101030803010001a80020a95566ba42e886bb804cda84e47ef56dbd7aec612615552cec906d2116d0ef207028c51554144dfeafe7c7cb8f005dd18234133ac0710a81182ce1fd14ad2283bc83435f9df2f6313251931a176df0da51e54f42e604860dfb359580250f559cc543c4ffd51cbe3de8cfd06719237f9fc47ee729da06835fa452e825e9a18ebc2ecbcf563474652c33cf56a9033bcdf5d973121797ec8089041b6e03a1b72d0a735b984e03687309332324f27c2dba85e9db15e83a0143382e974b0621c18e625ecec907577d9e7bade95241a81ebbe8a901d4d3276e40b114c0a2e6fc38d19c2e6aab02644b2813f575fc21601e0dee49cd9ee96a43103e524d62873d\"\n                .computeKeytag() == 19036,\n            \"Invalid keytag\"\n        );\n        require(\n            hex\"010003050440000003ba2fa05a75e173bede89eb71831ab14035f2408ad09df4d8dc8f8f72e8f13506feaddf7b04cb14958b82966e3420562302c4002bc4fd088432e160519bb14dae82443850c1423e06085710b5caf070d46b7ba7e481414f6a5fe225fdca984c959091645d0cf1c9a1a313d7e7fb7ba60b967b71a65f8cef2c3768e11b081c8fcf\"\n                .computeKeytag() == 21693,\n            \"Invalid keytag (2)\"\n        );\n        require(\n            hex\"0100030503010001bfa54c38d909fabb0f937d70d775ba0df4c0badb09707d995249406950407a621c794c68b186b15dbf8f9f9ea231e9f96414ccda4eceb50b17a9ac6c4bd4b95da04849e96ee791578b703bc9ae184fb1794bac792a0787f693a40f19f523ee6dbd3599dbaaa9a50437926ecf6438845d1d49448962524f2a1a7a36b3a0a1eca3\"\n                .computeKeytag() == 33630\n        );\n        require(\n            hex\"0101030803010001acffb409bcc939f831f7a1e5ec88f7a59255ec53040be432027390a4ce896d6f9086f3c5e177fbfe118163aaec7af1462c47945944c4e2c026be5e98bbcded25978272e1e3e079c5094d573f0e83c92f02b32d3513b1550b826929c80dd0f92cac966d17769fd5867b647c3f38029abdc48152eb8f207159ecc5d232c7c1537c79f4b7ac28ff11682f21681bf6d6aba555032bf6f9f036beb2aaa5b3778d6eebfba6bf9ea191be4ab0caea759e2f773a1f9029c73ecb8d5735b9321db085f1b8e2d8038fe2941992548cee0d67dd4547e11dd63af9c9fc1c5466fb684cf009d7197c2cf79e792ab501e6a8a1ca519af2cb9b5f6367e94c0d47502451357be1b5\"\n                .computeKeytag() == 20326,\n            \"Invalid keytag (3)\"\n        );\n    }\n}\n"
    },
    "contracts/utils/TestStringUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {StringUtils} from \"../../contracts/utils/StringUtils.sol\";\n\nlibrary TestStringUtils {\n    function escape(string memory s) external pure returns (string memory) {\n        return StringUtils.escape(s);\n    }\n    \n    function strlen(string memory s) external pure returns (uint256) {\n        return StringUtils.strlen(s);\n    }\n}\n"
    },
    "contracts/utils/UniversalSigValidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.19;\n\n// Copy-paste from https://eips.ethereum.org/EIPS/eip-6492\n// you can use `ValidateSigOffchain` for this library in exactly the same way that the other contract (DeploylessUniversalSigValidator.sol) is used\n// As per ERC-1271\ninterface IERC1271Wallet {\n    function isValidSignature(\n        bytes32 hash,\n        bytes calldata signature\n    ) external view returns (bytes4 magicValue);\n}\n\nerror ERC1271Revert(bytes error);\nerror ERC6492DeployFailed(bytes error);\n\ncontract UniversalSigValidator {\n    bytes32 private constant ERC6492_DETECTION_SUFFIX =\n        0x6492649264926492649264926492649264926492649264926492649264926492;\n    bytes4 private constant ERC1271_SUCCESS = 0x1626ba7e;\n\n    function isValidSigImpl(\n        address _signer,\n        bytes32 _hash,\n        bytes calldata _signature,\n        bool allowSideEffects\n    ) public returns (bool) {\n        uint contractCodeLen = address(_signer).code.length;\n        bytes memory sigToValidate;\n        // The order here is striclty defined in https://eips.ethereum.org/EIPS/eip-6492\n        // - ERC-6492 suffix check and verification first, while being permissive in case the contract is already deployed; if the contract is deployed we will check the sig against the deployed version, this allows 6492 signatures to still be validated while taking into account potential key rotation\n        // - ERC-1271 verification if there's contract code\n        // - finally, ecrecover\n        bool isCounterfactual = _signature.length >= 32 &&\n            bytes32(_signature[_signature.length - 32:_signature.length]) ==\n            ERC6492_DETECTION_SUFFIX;\n        if (isCounterfactual) {\n            address create2Factory;\n            bytes memory factoryCalldata;\n            (create2Factory, factoryCalldata, sigToValidate) = abi.decode(\n                _signature[0:_signature.length - 32],\n                (address, bytes, bytes)\n            );\n\n            if (contractCodeLen == 0) {\n                (bool success, bytes memory err) = create2Factory.call(\n                    factoryCalldata\n                );\n                if (!success) revert ERC6492DeployFailed(err);\n            }\n        } else {\n            sigToValidate = _signature;\n        }\n\n        // Try ERC-1271 verification\n        if (isCounterfactual || contractCodeLen > 0) {\n            try\n                IERC1271Wallet(_signer).isValidSignature(_hash, sigToValidate)\n            returns (bytes4 magicValue) {\n                bool isValid = magicValue == ERC1271_SUCCESS;\n\n                if (\n                    contractCodeLen == 0 &&\n                    isCounterfactual &&\n                    !allowSideEffects\n                ) {\n                    // if the call had side effects we need to return the\n                    // result using a `revert` (to undo the state changes)\n                    assembly {\n                        mstore(0, isValid)\n                        revert(31, 1)\n                    }\n                }\n\n                return isValid;\n            } catch (bytes memory err) {\n                revert ERC1271Revert(err);\n            }\n        }\n\n        // ecrecover verification\n        require(\n            _signature.length == 65,\n            \"SignatureValidator#recoverSigner: invalid signature length\"\n        );\n        bytes32 r = bytes32(_signature[0:32]);\n        bytes32 s = bytes32(_signature[32:64]);\n        uint8 v = uint8(_signature[64]);\n        if (v != 27 && v != 28) {\n            revert(\"SignatureValidator: invalid signature v value\");\n        }\n        return ecrecover(_hash, v, r, s) == _signer;\n    }\n\n    function isValidSigWithSideEffects(\n        address _signer,\n        bytes32 _hash,\n        bytes calldata _signature\n    ) external returns (bool) {\n        return this.isValidSigImpl(_signer, _hash, _signature, true);\n    }\n\n    function isValidSig(\n        address _signer,\n        bytes32 _hash,\n        bytes calldata _signature\n    ) external returns (bool) {\n        try this.isValidSigImpl(_signer, _hash, _signature, false) returns (\n            bool isValid\n        ) {\n            return isValid;\n        } catch (bytes memory error) {\n            // in order to avoid side effects from the contract getting deployed, the entire call will revert with a single byte result\n            uint len = error.length;\n            if (len == 1) return error[0] == 0x01;\n            // all other errors are simply forwarded, but in custom formats so that nothing else can revert with a single byte in the call\n            else\n                assembly {\n                    revert(add(error, 0x20), len)\n                }\n        }\n    }\n}\n"
    },
    "contracts/wrapper/Controllable.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ~0.8.17;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract Controllable is Ownable {\n    mapping(address => bool) public controllers;\n\n    event ControllerChanged(address indexed controller, bool active);\n\n    function setController(address controller, bool active) public onlyOwner {\n        controllers[controller] = active;\n        emit ControllerChanged(controller, active);\n    }\n\n    modifier onlyController() {\n        require(\n            controllers[msg.sender],\n            \"Controllable: Caller is not a controller\"\n        );\n        _;\n    }\n}\n"
    },
    "contracts/wrapper/ERC1155Fuse.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ~0.8.17;\n\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/* This contract is a variation on ERC1155 with the additions of _setData, getData and _beforeTransfer and ownerOf. _setData and getData allows the use of the other 96 bits next to the address of the owner for extra data. We use this to store 'fuses' that control permissions that can be burnt. 32 bits are used for the fuses themselves and 64 bits are used for the expiry of the name. When a name has expired, its fuses will be be set back to 0 */\n\nabstract contract ERC1155Fuse is ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n    /// @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n    event Approval(\n        address indexed owner,\n        address indexed approved,\n        uint256 indexed tokenId\n    );\n    mapping(uint256 => uint256) public _tokens;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) internal _tokenApprovals;\n\n    /**************************************************************************\n     * ERC721 methods\n     *************************************************************************/\n\n    function ownerOf(uint256 id) public view virtual returns (address) {\n        (address owner, , ) = getData(id);\n        return owner;\n    }\n\n    /// @dev See {IERC721-approve}.\n    function approve(address to, uint256 tokenId) public virtual {\n        address owner = ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            msg.sender == owner || isApprovedForAll(owner, msg.sender),\n            \"ERC721: approve caller is not token owner or approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /// @dev See {IERC721-getApproved}.\n    function getApproved(\n        uint256 tokenId\n    ) public view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\n\n    /// @dev See {IERC165-supportsInterface}.\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /// @dev See {IERC1155-balanceOf}.\n    /// Requirements:\n    /// - `account` cannot be the zero address.\n    function balanceOf(\n        address account,\n        uint256 id\n    ) public view virtual override returns (uint256) {\n        require(\n            account != address(0),\n            \"ERC1155: balance query for the zero address\"\n        );\n        address owner = ownerOf(id);\n        if (owner == account) {\n            return 1;\n        }\n        return 0;\n    }\n\n    /// @dev See {IERC1155-balanceOfBatch}.\n    /// Requirements:\n    /// - `accounts` and `ids` must have the same length.\n    function balanceOfBatch(\n        address[] memory accounts,\n        uint256[] memory ids\n    ) public view virtual override returns (uint256[] memory) {\n        require(\n            accounts.length == ids.length,\n            \"ERC1155: accounts and ids length mismatch\"\n        );\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /// @dev See {IERC1155-setApprovalForAll}.\n    function setApprovalForAll(\n        address operator,\n        bool approved\n    ) public virtual override {\n        require(\n            msg.sender != operator,\n            \"ERC1155: setting approval status for self\"\n        );\n\n        _operatorApprovals[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /// @dev See {IERC1155-isApprovedForAll}.\n    function isApprovedForAll(\n        address account,\n        address operator\n    ) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /// @dev Returns the Name's owner address and fuses\n    function getData(\n        uint256 tokenId\n    ) public view virtual returns (address owner, uint32 fuses, uint64 expiry) {\n        uint256 t = _tokens[tokenId];\n        owner = address(uint160(t));\n        expiry = uint64(t >> 192);\n        fuses = uint32(t >> 160);\n    }\n\n    /// @dev See {IERC1155-safeTransferFrom}.\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == msg.sender || isApprovedForAll(from, msg.sender),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        _transfer(from, to, id, amount, data);\n    }\n\n    /// @dev See {IERC1155-safeBatchTransferFrom}.\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            ids.length == amounts.length,\n            \"ERC1155: ids and amounts length mismatch\"\n        );\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == msg.sender || isApprovedForAll(from, msg.sender),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            (address oldOwner, uint32 fuses, uint64 expiry) = getData(id);\n\n            _beforeTransfer(id, fuses, expiry);\n\n            require(\n                amount == 1 && oldOwner == from,\n                \"ERC1155: insufficient balance for transfer\"\n            );\n            _setData(id, to, fuses, expiry);\n        }\n\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(\n            msg.sender,\n            from,\n            to,\n            ids,\n            amounts,\n            data\n        );\n    }\n\n    /**************************************************************************\n     * Internal/private methods\n     *************************************************************************/\n\n    /// @dev Sets the Name's owner address and fuses\n    function _setData(\n        uint256 tokenId,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal virtual {\n        _tokens[tokenId] =\n            uint256(uint160(owner)) |\n            (uint256(fuses) << 160) |\n            (uint256(expiry) << 192);\n    }\n\n    function _beforeTransfer(\n        uint256 id,\n        uint32 fuses,\n        uint64 expiry\n    ) internal virtual;\n\n    function _clearOwnerAndFuses(\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal virtual returns (address, uint32);\n\n    function _mint(\n        bytes32 node,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) internal virtual {\n        uint256 tokenId = uint256(node);\n        (address oldOwner, uint32 oldFuses, uint64 oldExpiry) = getData(\n            uint256(node)\n        );\n\n        uint32 parentControlledFuses = (uint32(type(uint16).max) << 16) &\n            oldFuses;\n\n        if (oldExpiry > expiry) {\n            expiry = oldExpiry;\n        }\n\n        if (oldExpiry >= block.timestamp) {\n            fuses = fuses | parentControlledFuses;\n        }\n\n        require(oldOwner == address(0), \"ERC1155: mint of existing token\");\n        require(owner != address(0), \"ERC1155: mint to the zero address\");\n        require(\n            owner != address(this),\n            \"ERC1155: newOwner cannot be the NameWrapper contract\"\n        );\n\n        _setData(tokenId, owner, fuses, expiry);\n        emit TransferSingle(msg.sender, address(0x0), owner, tokenId, 1);\n        _doSafeTransferAcceptanceCheck(\n            msg.sender,\n            address(0),\n            owner,\n            tokenId,\n            1,\n            \"\"\n        );\n    }\n\n    function _burn(uint256 tokenId) internal virtual {\n        (address oldOwner, uint32 fuses, uint64 expiry) = ERC1155Fuse.getData(\n            tokenId\n        );\n        (, fuses) = _clearOwnerAndFuses(oldOwner, fuses, expiry);\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n        // Fuses and expiry are kept on burn\n        _setData(tokenId, address(0x0), fuses, expiry);\n        emit TransferSingle(msg.sender, oldOwner, address(0x0), tokenId, 1);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal {\n        (address oldOwner, uint32 fuses, uint64 expiry) = getData(id);\n\n        _beforeTransfer(id, fuses, expiry);\n\n        require(\n            amount == 1 && oldOwner == from,\n            \"ERC1155: insufficient balance for transfer\"\n        );\n\n        if (oldOwner == to) {\n            return;\n        }\n\n        _setData(id, to, fuses, expiry);\n\n        emit TransferSingle(msg.sender, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(msg.sender, from, to, id, amount, data);\n    }\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try\n                IERC1155Receiver(to).onERC1155Received(\n                    operator,\n                    from,\n                    id,\n                    amount,\n                    data\n                )\n            returns (bytes4 response) {\n                if (\n                    response != IERC1155Receiver(to).onERC1155Received.selector\n                ) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try\n                IERC1155Receiver(to).onERC1155BatchReceived(\n                    operator,\n                    from,\n                    ids,\n                    amounts,\n                    data\n                )\n            returns (bytes4 response) {\n                if (\n                    response !=\n                    IERC1155Receiver(to).onERC1155BatchReceived.selector\n                ) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    /* ERC721 internal functions */\n\n    /// @dev Approve `to` to operate on `tokenId`\n    /// Emits an {Approval} event.\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ownerOf(tokenId), to, tokenId);\n    }\n}\n"
    },
    "contracts/wrapper/IMetadataService.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ~0.8.17;\n\ninterface IMetadataService {\n    function uri(uint256) external view returns (string memory);\n}\n"
    },
    "contracts/wrapper/INameWrapper.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ~0.8.17;\n\nimport \"../registry/ENS.sol\";\nimport \"../ethregistrar/IBaseRegistrar.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"./IMetadataService.sol\";\nimport \"./INameWrapperUpgrade.sol\";\n\nuint32 constant CANNOT_UNWRAP = 1;\nuint32 constant CANNOT_BURN_FUSES = 2;\nuint32 constant CANNOT_TRANSFER = 4;\nuint32 constant CANNOT_SET_RESOLVER = 8;\nuint32 constant CANNOT_SET_TTL = 16;\nuint32 constant CANNOT_CREATE_SUBDOMAIN = 32;\nuint32 constant CANNOT_APPROVE = 64;\n//uint16 reserved for parent controlled fuses from bit 17 to bit 32\nuint32 constant PARENT_CANNOT_CONTROL = 1 << 16;\nuint32 constant IS_DOT_ETH = 1 << 17;\nuint32 constant CAN_EXTEND_EXPIRY = 1 << 18;\nuint32 constant CAN_DO_EVERYTHING = 0;\nuint32 constant PARENT_CONTROLLED_FUSES = 0xFFFF0000;\n// all fuses apart from IS_DOT_ETH\nuint32 constant USER_SETTABLE_FUSES = 0xFFFDFFFF;\n\ninterface INameWrapper is IERC1155 {\n    event NameWrapped(\n        bytes32 indexed node,\n        bytes name,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    );\n\n    event NameUnwrapped(bytes32 indexed node, address owner);\n\n    event FusesSet(bytes32 indexed node, uint32 fuses);\n    event ExpiryExtended(bytes32 indexed node, uint64 expiry);\n\n    function ens() external view returns (ENS);\n\n    function registrar() external view returns (IBaseRegistrar);\n\n    function metadataService() external view returns (IMetadataService);\n\n    function names(bytes32) external view returns (bytes memory);\n\n    function name() external view returns (string memory);\n\n    function upgradeContract() external view returns (INameWrapperUpgrade);\n\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) external;\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint16 ownerControlledFuses,\n        address resolver\n    ) external returns (uint64 expires);\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint16 ownerControlledFuses\n    ) external returns (uint256 registrarExpiry);\n\n    function renew(\n        uint256 labelHash,\n        uint256 duration\n    ) external returns (uint256 expires);\n\n    function unwrap(bytes32 node, bytes32 label, address owner) external;\n\n    function unwrapETH2LD(\n        bytes32 label,\n        address newRegistrant,\n        address newController\n    ) external;\n\n    function upgrade(bytes calldata name, bytes calldata extraData) external;\n\n    function setFuses(\n        bytes32 node,\n        uint16 ownerControlledFuses\n    ) external returns (uint32 newFuses);\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        string calldata label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function extendExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    ) external returns (uint64);\n\n    function canModifyName(\n        bytes32 node,\n        address addr\n    ) external view returns (bool);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function ownerOf(uint256 id) external view returns (address owner);\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address);\n\n    function getData(\n        uint256 id\n    ) external view returns (address, uint32, uint64);\n\n    function setMetadataService(IMetadataService _metadataService) external;\n\n    function uri(uint256 tokenId) external view returns (string memory);\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress) external;\n\n    function allFusesBurned(\n        bytes32 node,\n        uint32 fuseMask\n    ) external view returns (bool);\n\n    function isWrapped(bytes32) external view returns (bool);\n\n    function isWrapped(bytes32, bytes32) external view returns (bool);\n}\n"
    },
    "contracts/wrapper/INameWrapperUpgrade.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ~0.8.17;\n\ninterface INameWrapperUpgrade {\n    function wrapFromUpgrade(\n        bytes calldata name,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry,\n        address approved,\n        bytes calldata extraData\n    ) external;\n}\n"
    },
    "contracts/wrapper/mocks/ERC1155ReceiverMock.sol": {
      "content": "// Based on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.1.0/test/token/ERC1155/ERC1155.behaviour.js\n// Copyright (c) 2016-2020 zOS Global Limited\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\ncontract ERC1155ReceiverMock is IERC1155Receiver, ERC165 {\n    bytes4 private _recRetval;\n    bool private _recReverts;\n    bytes4 private _batRetval;\n    bool private _batReverts;\n\n    event Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes data\n    );\n    event BatchReceived(\n        address operator,\n        address from,\n        uint256[] ids,\n        uint256[] values,\n        bytes data\n    );\n\n    constructor(\n        bytes4 recRetval,\n        bool recReverts,\n        bytes4 batRetval,\n        bool batReverts\n    ) {\n        _recRetval = recRetval;\n        _recReverts = recReverts;\n        _batRetval = batRetval;\n        _batReverts = batReverts;\n    }\n\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external override returns (bytes4) {\n        require(!_recReverts, \"ERC1155ReceiverMock: reverting on receive\");\n        emit Received(operator, from, id, value, data);\n        return _recRetval;\n    }\n\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external override returns (bytes4) {\n        require(\n            !_batReverts,\n            \"ERC1155ReceiverMock: reverting on batch receive\"\n        );\n        emit BatchReceived(operator, from, ids, values, data);\n        return _batRetval;\n    }\n}\n"
    },
    "contracts/wrapper/mocks/TestUnwrap.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\nimport \"../../registry/ENS.sol\";\nimport \"../../ethregistrar/IBaseRegistrar.sol\";\nimport {NameCoder} from \"../../utils/NameCoder.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract TestUnwrap is Ownable {\n    bytes32 private constant ETH_NODE =\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n\n    ENS public immutable ens;\n    IBaseRegistrar public immutable registrar;\n    mapping(address => bool) public approvedWrapper;\n\n    constructor(ENS _ens, IBaseRegistrar _registrar) {\n        ens = _ens;\n        registrar = _registrar;\n    }\n\n    function setWrapperApproval(\n        address wrapper,\n        bool approved\n    ) public onlyOwner {\n        approvedWrapper[wrapper] = approved;\n    }\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry,\n        address resolver\n    ) public {\n        _unwrapETH2LD(keccak256(bytes(label)), wrappedOwner, msg.sender);\n    }\n\n    function setSubnodeRecord(\n        bytes32 parentNode,\n        string memory label,\n        address newOwner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    ) public {\n        bytes32 node = _makeNode(parentNode, keccak256(bytes(label)));\n        _unwrapSubnode(node, newOwner, msg.sender);\n    }\n\n    function wrapFromUpgrade(\n        bytes calldata name,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry,\n        address approved,\n        bytes calldata extraData\n    ) public {\n        (bytes32 labelhash, uint256 offset) = NameCoder.readLabel(name, 0);\n        bytes32 parentNode = NameCoder.namehash(name, offset);\n        bytes32 node = _makeNode(parentNode, labelhash);\n\n        if (parentNode == ETH_NODE) {\n            _unwrapETH2LD(labelhash, wrappedOwner, msg.sender);\n        } else {\n            _unwrapSubnode(node, wrappedOwner, msg.sender);\n        }\n    }\n\n    function _unwrapETH2LD(\n        bytes32 labelhash,\n        address wrappedOwner,\n        address sender\n    ) private {\n        uint256 tokenId = uint256(labelhash);\n        address registrant = registrar.ownerOf(tokenId);\n\n        require(\n            approvedWrapper[sender] &&\n                sender == registrant &&\n                registrar.isApprovedForAll(registrant, address(this)),\n            \"Unauthorised\"\n        );\n\n        registrar.reclaim(tokenId, wrappedOwner);\n        registrar.transferFrom(registrant, wrappedOwner, tokenId);\n    }\n\n    function _unwrapSubnode(\n        bytes32 node,\n        address newOwner,\n        address sender\n    ) private {\n        address owner = ens.owner(node);\n\n        require(\n            approvedWrapper[sender] &&\n                owner == sender &&\n                ens.isApprovedForAll(owner, address(this)),\n            \"Unauthorised\"\n        );\n\n        ens.setOwner(node, newOwner);\n    }\n\n    function _makeNode(\n        bytes32 node,\n        bytes32 labelhash\n    ) private pure returns (bytes32) {\n        return keccak256(abi.encodePacked(node, labelhash));\n    }\n}\n"
    },
    "contracts/wrapper/mocks/UpgradedNameWrapperMock.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\nimport {INameWrapperUpgrade} from \"../INameWrapperUpgrade.sol\";\nimport \"../../registry/ENS.sol\";\nimport \"../../ethregistrar/IBaseRegistrar.sol\";\nimport {NameCoder} from \"../../utils/NameCoder.sol\";\n\ncontract UpgradedNameWrapperMock is INameWrapperUpgrade {\n    bytes32 private constant ETH_NODE =\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n\n    ENS public immutable ens;\n    IBaseRegistrar public immutable registrar;\n\n    constructor(ENS _ens, IBaseRegistrar _registrar) {\n        ens = _ens;\n        registrar = _registrar;\n    }\n\n    event NameUpgraded(\n        bytes name,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry,\n        address approved,\n        bytes extraData\n    );\n\n    function wrapFromUpgrade(\n        bytes calldata name,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry,\n        address approved,\n        bytes calldata extraData\n    ) public {\n        (bytes32 labelhash, uint256 offset) = NameCoder.readLabel(name, 0);\n        bytes32 parentNode = NameCoder.namehash(name, offset);\n        bytes32 node = _makeNode(parentNode, labelhash);\n\n        if (parentNode == ETH_NODE) {\n            address registrant = registrar.ownerOf(uint256(labelhash));\n            require(\n                msg.sender == registrant &&\n                    registrar.isApprovedForAll(registrant, address(this)),\n                \"No approval for registrar\"\n            );\n        } else {\n            address owner = ens.owner(node);\n            require(\n                msg.sender == owner &&\n                    ens.isApprovedForAll(owner, address(this)),\n                \"No approval for registry\"\n            );\n        }\n        emit NameUpgraded(\n            name,\n            wrappedOwner,\n            fuses,\n            expiry,\n            approved,\n            extraData\n        );\n    }\n\n    function _makeNode(\n        bytes32 node,\n        bytes32 labelhash\n    ) private pure returns (bytes32) {\n        return keccak256(abi.encodePacked(node, labelhash));\n    }\n}\n"
    },
    "contracts/wrapper/StaticMetadataService.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ~0.8.17;\n\ncontract StaticMetadataService {\n    string private _uri;\n\n    constructor(string memory _metaDataUri) {\n        _uri = _metaDataUri;\n    }\n\n    function uri(uint256) public view returns (string memory) {\n        return _uri;\n    }\n}\n"
    },
    "contracts/wrapper/test/NameGriefer.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ~0.8.17;\n\nimport {INameWrapper} from \"../INameWrapper.sol\";\nimport {ENS} from \"../../registry/ENS.sol\";\nimport {NameCoder} from \"../../utils/NameCoder.sol\";\nimport {IERC1155Receiver} from \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\n\ncontract NameGriefer is IERC1155Receiver {\n    ENS public immutable ens;\n    INameWrapper public immutable wrapper;\n\n    constructor(INameWrapper _wrapper) {\n        wrapper = _wrapper;\n        ENS _ens = _wrapper.ens();\n        ens = _ens;\n        _ens.setApprovalForAll(address(_wrapper), true);\n    }\n\n    function destroy(bytes calldata name) public {\n        wrapper.wrap(name, address(this), address(0));\n    }\n\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256,\n        bytes calldata\n    ) external override returns (bytes4) {\n        require(operator == address(this), \"Operator must be us\");\n        require(from == address(0), \"Token must be new\");\n\n        // Unwrap the name\n        bytes memory name = wrapper.names(bytes32(id));\n        (bytes32 labelhash, uint256 offset) = NameCoder.readLabel(name, 0);\n        bytes32 parentNode = NameCoder.namehash(name, offset);\n        wrapper.unwrap(parentNode, labelhash, address(this));\n\n        // Here we can do something with the name before it's permanently burned, like\n        // set the resolver or create subdomains.\n\n        return NameGriefer.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external override returns (bytes4) {\n        return NameGriefer.onERC1155BatchReceived.selector;\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) external view override returns (bool) {\n        return\n            interfaceID == 0x01ffc9a7 || // ERC-165 support (i.e. `bytes4(keccak256('supportsInterface(bytes4)'))`).\n            interfaceID == 0x4e2312e0; // ERC-1155 `ERC1155TokenReceiver` support (i.e. `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\")) ^ bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`).\n    }\n}\n"
    },
    "contracts/wrapper/test/TestNameWrapperReentrancy.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ~0.8.17;\n\nimport \"../INameWrapper.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\ncontract TestNameWrapperReentrancy is ERC165, IERC1155Receiver {\n    INameWrapper nameWrapper;\n    address owner;\n    bytes32 parentNode;\n    bytes32 labelHash;\n    uint256 tokenId;\n\n    constructor(\n        address _owner,\n        INameWrapper _nameWrapper,\n        bytes32 _parentNode,\n        bytes32 _labelHash\n    ) {\n        owner = _owner;\n        nameWrapper = _nameWrapper;\n        parentNode = _parentNode;\n        labelHash = _labelHash;\n    }\n\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155Receiver).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    function onERC1155Received(\n        address,\n        address,\n        uint256 _id,\n        uint256,\n        bytes calldata\n    ) public override returns (bytes4) {\n        tokenId = _id;\n        nameWrapper.unwrap(parentNode, labelHash, owner);\n\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    function claimToOwner() public {\n        nameWrapper.safeTransferFrom(address(this), owner, tokenId, 1, \"\");\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "metadata": {
      "useLiteralContent": true
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}